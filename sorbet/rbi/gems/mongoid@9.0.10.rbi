# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mongoid` gem.
# Please instead update this file by running `bin/tapioca gem mongoid`.


class ActiveSupport::TimeWithZone
  include ::Mongoid::Extensions::TimeWithZone
  include ::Mongoid::Criteria::Queryable::Extensions::TimeWithZone
  extend ::Mongoid::Extensions::TimeWithZone::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::TimeWithZone::ClassMethods
end

class Array
  include ::Enumerable
  include ::Mongoid::Extensions::Array
  include ::Mongoid::Criteria::Queryable::Extensions::Array
  extend ::Mongoid::Extensions::Array::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Array::ClassMethods
end

class BSON::Binary
  include ::Mongoid::Extensions::Binary
  extend ::Mongoid::Extensions::Binary::ClassMethods
end

class BSON::Decimal128
  include ::Mongoid::Extensions::Decimal128
  extend ::Mongoid::Extensions::Decimal128::ClassMethods
end

class BSON::ObjectId
  include ::Mongoid::Extensions::ObjectId
  extend ::Mongoid::Extensions::ObjectId::ClassMethods
end

class BSON::Regexp::Raw
  include ::Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_
  extend ::Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_::ClassMethods
end

class BigDecimal < ::Numeric
  include ::Mongoid::Extensions::BigDecimal
  extend ::Mongoid::Extensions::BigDecimal::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::BigDecimal::ClassMethods
end

class Date
  include ::Comparable
  include ::Mongoid::Extensions::Date
  include ::Mongoid::Criteria::Queryable::Extensions::Date
  extend ::Mongoid::Extensions::Date::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Date::ClassMethods
end

class DateTime < ::Date
  include ::Mongoid::Extensions::DateTime
  include ::Mongoid::Criteria::Queryable::Extensions::DateTime
  extend ::Mongoid::Extensions::DateTime::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::DateTime::ClassMethods
end

class FalseClass
  include ::Mongoid::Extensions::FalseClass
end

class Float < ::Numeric
  include ::Mongoid::Extensions::Float
  include ::Mongoid::Criteria::Queryable::Extensions::Numeric
  extend ::Mongoid::Extensions::Float::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
end

class Hash
  include ::Enumerable
  include ::Mongoid::Extensions::Hash
  include ::Mongoid::Criteria::Queryable::Extensions::Hash
  extend ::Mongoid::Extensions::Hash::ClassMethods
end

class Integer < ::Numeric
  include ::Mongoid::Extensions::Integer
  include ::Mongoid::Criteria::Queryable::Extensions::Numeric
  extend ::Mongoid::Extensions::Integer::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
end

class Module
  include ::Mize::CacheMethods
  include ::Mongoid::Extensions::Module
end

module Mongoid
  extend ::Mongoid::Deprecable
  extend ::Forwardable
  extend ::Mongoid::Loggable
  extend ::Mongoid::Loadable
  extend ::Mongoid
  extend ::Mongoid::Clients::Sessions::ClassMethods
  extend ::Mongoid::GlobalDiscriminatorKeyAssignment

  def RawValue(*args); end
  def allow_bson5_decimal128(*args, **_arg1, &block); end
  def allow_bson5_decimal128=(*args, **_arg1, &block); end
  def allow_bson5_decimal128?(*args, **_arg1, &block); end
  def allow_scopes_to_unset_default_scope(*args, **_arg1, &block); end
  def allow_scopes_to_unset_default_scope=(*args, **_arg1, &block); end
  def allow_scopes_to_unset_default_scope?(*args, **_arg1, &block); end
  def app_name(*args, **_arg1, &block); end
  def app_name=(*args, **_arg1, &block); end
  def app_name?(*args, **_arg1, &block); end
  def around_callbacks_for_embeds(*args, **_arg1, &block); end
  def around_callbacks_for_embeds=(*args, **_arg1, &block); end
  def around_callbacks_for_embeds?(*args, **_arg1, &block); end
  def async_query_executor(*args, **_arg1, &block); end
  def async_query_executor=(*args, **_arg1, &block); end
  def async_query_executor?(*args, **_arg1, &block); end
  def background_indexing(*args, **_arg1, &block); end
  def background_indexing=(*args, **_arg1, &block); end
  def background_indexing?(*args, **_arg1, &block); end
  def belongs_to_required_by_default(*args, **_arg1, &block); end
  def belongs_to_required_by_default=(*args, **_arg1, &block); end
  def belongs_to_required_by_default?(*args, **_arg1, &block); end
  def client(name); end
  def clients(*args, **_arg1, &block); end
  def config(*args, **_arg1, &block); end
  def configure(&block); end
  def configured?(*args, **_arg1, &block); end
  def connect_to(*args, **_arg1, &block); end
  def default_client; end
  def deregister_model(*args, **_arg1, &block); end
  def destructive_fields(*args, **_arg1, &block); end
  def disconnect_clients; end
  def discriminator_key(*args, **_arg1, &block); end
  def discriminator_key=(*args, **_arg1, &block); end
  def discriminator_key?(*args, **_arg1, &block); end
  def duplicate_fields_exception(*args, **_arg1, &block); end
  def duplicate_fields_exception=(*args, **_arg1, &block); end
  def duplicate_fields_exception?(*args, **_arg1, &block); end
  def global_executor_concurrency(*args, **_arg1, &block); end
  def global_executor_concurrency=(*args, **_arg1, &block); end
  def global_executor_concurrency?(*args, **_arg1, &block); end
  def immutable_ids(*args, **_arg1, &block); end
  def immutable_ids=(*args, **_arg1, &block); end
  def immutable_ids?(*args, **_arg1, &block); end
  def include_root_in_json(*args, **_arg1, &block); end
  def include_root_in_json=(*args, **_arg1, &block); end
  def include_root_in_json?(*args, **_arg1, &block); end
  def include_type_for_serialization(*args, **_arg1, &block); end
  def include_type_for_serialization=(*args, **_arg1, &block); end
  def include_type_for_serialization?(*args, **_arg1, &block); end
  def join_contexts(*args, **_arg1, &block); end
  def join_contexts=(*args, **_arg1, &block); end
  def join_contexts?(*args, **_arg1, &block); end
  def legacy_persistence_context_behavior(*args, **_arg1, &block); end
  def legacy_persistence_context_behavior=(*args, **_arg1, &block); end
  def legacy_persistence_context_behavior?(*args, **_arg1, &block); end
  def legacy_readonly(*args, **_arg1, &block); end
  def legacy_readonly=(*args, **_arg1, &block); end
  def legacy_readonly?(*args, **_arg1, &block); end
  def load!(*args, **_arg1, &block); end
  def load_configuration(*args, **_arg1, &block); end
  def log_level=(*args, **_arg1, &block); end
  def log_level?(*args, **_arg1, &block); end
  def map_big_decimal_to_decimal128(*args, **_arg1, &block); end
  def map_big_decimal_to_decimal128=(*args, **_arg1, &block); end
  def map_big_decimal_to_decimal128?(*args, **_arg1, &block); end
  def models(*args, **_arg1, &block); end
  def options=(*args, **_arg1, &block); end
  def override_client(*args, **_arg1, &block); end
  def override_database(*args, **_arg1, &block); end
  def persistence_context; end
  def preload_models(*args, **_arg1, &block); end
  def preload_models=(*args, **_arg1, &block); end
  def preload_models?(*args, **_arg1, &block); end
  def prevent_multiple_calls_of_embedded_callbacks(*args, **_arg1, &block); end
  def prevent_multiple_calls_of_embedded_callbacks=(*args, **_arg1, &block); end
  def prevent_multiple_calls_of_embedded_callbacks?(*args, **_arg1, &block); end
  def purge!(*args, **_arg1, &block); end
  def raise_not_found_error(*args, **_arg1, &block); end
  def raise_not_found_error=(*args, **_arg1, &block); end
  def raise_not_found_error?(*args, **_arg1, &block); end
  def reconnect_clients; end
  def register_model(*args, **_arg1, &block); end
  def running_with_passenger?(*args, **_arg1, &block); end
  def scope_overwrite_exception(*args, **_arg1, &block); end
  def scope_overwrite_exception=(*args, **_arg1, &block); end
  def scope_overwrite_exception?(*args, **_arg1, &block); end
  def storage_options; end
  def time_zone(*args, **_arg1, &block); end
  def truncate!(*args, **_arg1, &block); end
  def use_utc(*args, **_arg1, &block); end
  def use_utc=(*args, **_arg1, &block); end
  def use_utc?(*args, **_arg1, &block); end
end

module Mongoid::Association
  include ::Mongoid::Association::Referenced::Syncable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::Syncable::ClassMethods

  def _association; end
  def _association=(_arg0); end
  def association_name; end
  def embedded?; end
  def embedded_many?; end
  def embedded_one?; end
  def referenced_many?; end
  def referenced_one?; end
  def reload_relations; end

  module GeneratedClassMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

module Mongoid::Association::Accessors
  extend ::ActiveSupport::Concern

  def __build__(name, object, association, selected_fields = T.unsafe(nil)); end
  def create_relation(object, association, selected_fields = T.unsafe(nil)); end
  def reset_relation_criteria(name); end
  def set_relation(name, relation); end

  private

  def _mongoid_filter_selected_fields(assoc_key); end
  def get_relation(name, association, object, reload = T.unsafe(nil)); end
  def needs_no_database_query?(object, association); end
  def parse_args(*args); end
  def without_autobuild; end
  def without_autobuild?; end

  class << self
    def define_builder!(association); end
    def define_creator!(association); end
    def define_existence_check!(association); end
    def define_getter!(association); end
    def define_ids_getter!(association); end
    def define_ids_setter!(association); end
    def define_setter!(association); end
  end
end

module Mongoid::Association::Bindable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  def initialize(base, target, association); end

  def _association; end
  def _base; end
  def _target; end
  def binding; end

  private

  def bind_foreign_key(keyed, id); end
  def bind_from_relational_parent(doc); end
  def bind_inverse(doc, inverse); end
  def bind_polymorphic_inverse_type(typed, name); end
  def bind_polymorphic_type(typed, name); end
  def check_inverse!(doc); end
  def record_id(_base); end
  def remove_associated(doc); end
  def remove_associated_in_to(doc, inverse); end
  def remove_associated_many(doc, inverse); end
  def set_base_association; end
  def try_method(object, method_name, *args); end
  def unbind_from_relational_parent(doc); end
end

module Mongoid::Association::Builders
  extend ::ActiveSupport::Concern

  private

  def parse_args(*args); end

  class << self
    def define_builder!(association); end
    def define_creator!(association); end
  end
end

module Mongoid::Association::Constrainable
  def convert_to_foreign_key(object); end

  private

  def convert_polymorphic(object); end
end

module Mongoid::Association::Depending
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods

  def apply_destroy_dependencies!; end

  private

  def _dependent_delete_all!(association); end
  def _dependent_destroy!(association); end
  def _dependent_nullify!(association); end
  def _dependent_restrict_with_error!(association); end
  def _dependent_restrict_with_exception!(association); end

  class << self
    def define_dependency!(association); end
    def validate!(association); end
  end

  module GeneratedClassMethods
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
  end

  module GeneratedInstanceMethods
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
  end
end

module Mongoid::Association::Depending::ClassMethods
  def _all_dependents; end
end

Mongoid::Association::Depending::STRATEGIES = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Eager
  def initialize(associations, docs); end

  def run; end

  protected

  def each_loaded_document(&block); end
  def group_by_key; end
  def grouped_docs; end
  def keys_from_docs; end
  def preload; end
  def set_on_parent(id, element); end
  def set_relation(doc, element); end

  private

  def each_loaded_document_of_class(cls, keys); end
  def shift_association; end
end

module Mongoid::Association::EagerLoadable
  def eager_load(docs); end
  def eager_loadable?; end
  def preload(associations, docs); end
end

module Mongoid::Association::Embedded; end

module Mongoid::Association::Embedded::Batchable
  include ::Mongoid::Positional

  def batch_clear(docs); end
  def batch_insert(docs); end
  def batch_remove(docs, method = T.unsafe(nil)); end
  def batch_replace(docs); end

  private

  def add_atomic_sets(sets); end
  def clear_atomic_path_cache; end
  def execute_batch_push(docs); end
  def execute_batch_set(docs); end
  def insertable?; end
  def inserts_valid; end
  def inserts_valid=(value); end
  def normalize_docs(docs); end
  def path; end
  def path=(value); end
  def post_process_batch_insert(docs); end
  def post_process_batch_remove(docs, method); end
  def pre_process_batch_insert(docs); end
  def pre_process_batch_remove(docs, method); end
  def selector; end
end

module Mongoid::Association::Embedded::Cyclic
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods

  module GeneratedClassMethods
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
  end

  module GeneratedInstanceMethods
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
  end
end

module Mongoid::Association::Embedded::Cyclic::ClassMethods
  def recursively_embeds_many(options = T.unsafe(nil)); end
  def recursively_embeds_one(options = T.unsafe(nil)); end

  private

  def cyclic_child_name(many = T.unsafe(nil)); end
  def cyclic_parent_name; end
end

class Mongoid::Association::Embedded::Eager < ::Mongoid::Association::Eager
  private

  def preload; end
end

class Mongoid::Association::Embedded::EmbeddedIn
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Embedded::EmbeddedIn::Buildable

  def embedded?; end
  def key; end
  def nested_builder(attributes, options); end
  def polymorphic?; end
  def primary_key; end
  def relation; end
  def setup!; end
  def stores_foreign_key?; end
  def validation_default; end

  private

  def determine_inverses(other); end
  def polymorphic_inverses(other = T.unsafe(nil)); end
  def relation_complements; end
  def setup_defaults!; end
  def setup_instance_methods!; end
end

Mongoid::Association::Embedded::EmbeddedIn::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Embedded::EmbeddedIn::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  def bind_one; end
  def unbind_one; end

  private

  def check_polymorphic_inverses!(doc); end
end

module Mongoid::Association::Embedded::EmbeddedIn::Buildable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end
end

class Mongoid::Association::Embedded::EmbeddedIn::Proxy < ::Mongoid::Association::One
  def initialize(base, target, association); end

  def substitute(replacement); end

  private

  def binding; end
  def characterize_one(document); end
  def persistable?; end

  class << self
    def eager_loader(associations, docs); end
    def embedded?; end
    def path(document); end
  end
end

Mongoid::Association::Embedded::EmbeddedIn::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Embedded::EmbedsMany
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Embedded::EmbedsMany::Buildable

  def criteria(base, target); end
  def embedded?; end
  def key; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorphic?; end
  def primary_key; end
  def relation; end
  def setup!; end
  def store_as; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end

  private

  def apply_ordering(criteria); end
  def determine_inverses(other); end
  def polymorphic_inverses(other = T.unsafe(nil)); end
  def relation_complements; end
  def setup_instance_methods!; end
end

Mongoid::Association::Embedded::EmbedsMany::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Embedded::EmbedsMany::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  def bind_one(doc); end
  def unbind_one(doc); end
end

module Mongoid::Association::Embedded::EmbedsMany::Buildable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end
end

class Mongoid::Association::Embedded::EmbedsMany::Proxy < ::Mongoid::Association::Many
  include ::Mongoid::Positional
  include ::Mongoid::Association::Embedded::Batchable
  extend ::Mongoid::Association::Embedded::EmbedsMany::Proxy::ClassMethods

  def initialize(base, target, association); end

  def <<(*args); end
  def _remove(document); end
  def as_document; end
  def build(attributes = T.unsafe(nil), type = T.unsafe(nil)); end
  def clear; end
  def concat(docs); end
  def count(*args, &block); end
  def delete(document); end
  def delete_all(conditions = T.unsafe(nil)); end
  def delete_if; end
  def delete_one(document); end
  def destroy_all(conditions = T.unsafe(nil)); end
  def exists?(id_or_conditions = T.unsafe(nil)); end
  def find(*args, **_arg1, &block); end
  def in_memory; end
  def new(attributes = T.unsafe(nil), type = T.unsafe(nil)); end
  def pluck(*args, **_arg1, &block); end
  def pop(count = T.unsafe(nil)); end
  def push(*args); end
  def shift(count = T.unsafe(nil)); end
  def substitute(docs); end
  def unscoped; end

  private

  def _unscoped; end
  def _unscoped=(_arg0); end
  def append(document); end
  def append_many(documents, &block); end
  def as_attributes; end
  def binding; end
  def criteria; end
  def id_of(doc); end
  def integrate(document); end
  def method_missing(name, *args, **_arg2, &block); end
  def object_already_related?(document); end
  def persistable?; end
  def process_incoming_docs(documents, &block); end
  def reindex; end
  def remove_all(conditions = T.unsafe(nil), method = T.unsafe(nil)); end
  def scope(docs); end
  def update_attributes_hash; end
end

module Mongoid::Association::Embedded::EmbedsMany::Proxy::ClassMethods
  def eager_loader(associations, docs); end
  def embedded?; end
  def foreign_key_suffix; end
end

Mongoid::Association::Embedded::EmbedsMany::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Embedded::EmbedsOne
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Embedded::EmbedsOne::Buildable

  def embedded?; end
  def key; end
  def nested_builder(attributes, options); end
  def polymorphic?; end
  def primary_key; end
  def relation; end
  def setup!; end
  def store_as; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end

  private

  def determine_inverses(other); end
  def polymorphic_inverses(other = T.unsafe(nil)); end
  def relation_complements; end
  def setup_instance_methods!; end
end

Mongoid::Association::Embedded::EmbedsOne::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Embedded::EmbedsOne::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  def bind_one; end
  def unbind_one; end
end

module Mongoid::Association::Embedded::EmbedsOne::Buildable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  def build(base, object, _type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  def clear_associated(doc); end
end

class Mongoid::Association::Embedded::EmbedsOne::Proxy < ::Mongoid::Association::One
  def initialize(base, target, association); end

  def substitute(replacement); end

  private

  def binding; end
  def persistable?; end
  def replace_with(replacement); end
  def replace_with_nil_document(replacement); end
  def update_attributes_hash(replacement); end
  def update_target_when_not_assigning(replacement); end

  class << self
    def eager_loader(associations, docs); end
    def embedded?; end
    def path(document); end
  end
end

Mongoid::Association::Embedded::EmbedsOne::Proxy::VALID_OPTIONS = T.let(T.unsafe(nil), Array)
Mongoid::Association::Embedded::EmbedsOne::VALID_OPTIONS = T.let(T.unsafe(nil), Array)
Mongoid::Association::MACRO_MAPPING = T.let(T.unsafe(nil), Hash)

module Mongoid::Association::Macros
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods

  def associations; end

  module GeneratedClassMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

module Mongoid::Association::Macros::ClassMethods
  def belongs_to(name, options = T.unsafe(nil), &block); end
  def embedded_in(name, options = T.unsafe(nil), &block); end
  def embeds_many(name, options = T.unsafe(nil), &block); end
  def embeds_one(name, options = T.unsafe(nil), &block); end
  def has_and_belongs_to_many(name, options = T.unsafe(nil), &block); end
  def has_many(name, options = T.unsafe(nil), &block); end
  def has_one(name, options = T.unsafe(nil), &block); end

  private

  def define_association!(macro_name, name, options = T.unsafe(nil), &block); end
end

class Mongoid::Association::Many < ::Mongoid::Association::Proxy
  include ::Enumerable

  def any?(*args, **_arg1, &block); end
  def avg(*args, **_arg1, &block); end
  def blank?; end
  def create(attributes = T.unsafe(nil), type = T.unsafe(nil), &block); end
  def create!(attributes = T.unsafe(nil), type = T.unsafe(nil), &block); end
  def find_or_create_by(attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end
  def find_or_create_by!(attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end
  def find_or_initialize_by(attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end
  def length(*args, **_arg1, &block); end
  def max(*args, **_arg1, &block); end
  def min(*args, **_arg1, &block); end
  def nil?; end
  def respond_to?(name, include_private = T.unsafe(nil)); end
  def scoped; end
  def serializable_hash(options = T.unsafe(nil)); end
  def size(*args, **_arg1, &block); end
  def sum(*args, **_arg1, &block); end
  def unscoped; end

  private

  def _session; end
  def find_or(method, attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end
end

module Mongoid::Association::Marshalable
  def marshal_dump; end
  def marshal_load(data); end
end

module Mongoid::Association::Nested; end

module Mongoid::Association::Nested::Buildable
  def allow_destroy?; end
  def association; end
  def association=(_arg0); end
  def attributes; end
  def attributes=(_arg0); end
  def convert_id(klass, id); end
  def existing; end
  def existing=(_arg0); end
  def options; end
  def options=(_arg0); end
  def reject?(document, attrs); end
  def update_only?; end

  private

  def delete_id(hash); end
  def extract_id(hash); end
end

Mongoid::Association::Nested::DESTROY_FLAGS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Nested::Many
  include ::Mongoid::Association::Nested::Buildable

  def initialize(association, attributes, options = T.unsafe(nil)); end

  def build(parent, options = T.unsafe(nil)); end

  private

  def destroy(parent, relation, doc); end
  def destroy_document(relation, doc); end
  def destroyable?(attributes); end
  def over_limit?(attributes); end
  def process_attributes(parent, attrs); end
  def update_document(doc, attrs); end
  def update_nested_relation(parent, id, attrs); end
end

class Mongoid::Association::Nested::One
  include ::Mongoid::Association::Nested::Buildable

  def initialize(association, attributes, options); end

  def build(parent); end
  def destroy; end
  def destroy=(_arg0); end

  private

  def acceptable_id?; end
  def check_for_id_violation!; end
  def class_from(name_or_class); end
  def delete?; end
  def destroyable?; end
  def extracted_id; end
  def replace?; end
  def update?; end
end

class Mongoid::Association::One < ::Mongoid::Association::Proxy
  def __evolve_object_id__; end
  def clear; end
  def in_memory; end
  def respond_to?(name, include_private = T.unsafe(nil)); end
end

module Mongoid::Association::Options
  def as; end
  def autobuilding?; end
  def autosave; end
  def autosave?; end
  def cascading_callbacks?; end
  def counter_cached?; end
  def cyclic?; end
  def dependent; end
  def forced_nil_inverse?; end
  def indexed?; end
  def inverse_of; end
  def order; end
  def polymorphic?; end
  def primary_key; end
  def store_as; end
  def touch_field; end
  def touchable?; end
  def type; end
end

class Mongoid::Association::Proxy
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Marshalable
  extend ::Forwardable
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  def initialize(base, target, association); end

  def _association; end
  def _association=(_arg0); end
  def _base; end
  def _base=(_arg0); end
  def _target; end
  def _target=(_arg0); end
  def bind_one(*args, **_arg1, &block); end
  def collection_name(*args, **_arg1, &block); end
  def extend_proxies(*extension); end
  def extend_proxy(*_arg0); end
  def foreign_key(*args, **_arg1, &block); end
  def inverse_foreign_key(*args, **_arg1, &block); end
  def klass; end
  def reset_unloaded; end
  def substitutable; end
  def unbind_one(*args, **_arg1, &block); end

  protected

  def characterize_one(document); end
  def collection; end
  def execute_callback(callback, doc); end
  def execute_callbacks_around(name, doc); end
  def method_missing(name, *args, **_arg2, &block); end
  def raise_mixed; end
  def raise_unsaved(doc); end

  private

  def respond_to_missing?(name, *args, **_arg2); end

  class << self
    def apply_ordering(criteria, association); end
  end
end

Mongoid::Association::Proxy::KEEPER_METHODS = T.let(T.unsafe(nil), Array)
module Mongoid::Association::Referenced; end

module Mongoid::Association::Referenced::AutoSave
  extend ::ActiveSupport::Concern

  def __autosaving__; end
  def autosaved?; end
  def changed_for_autosave?(doc); end

  class << self
    def define_autosave!(association); end
  end
end

class Mongoid::Association::Referenced::BelongsTo
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::BelongsTo::Buildable

  def embedded?; end
  def foreign_key; end
  def inverse_type; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorphic?; end
  def relation; end
  def relation_complements; end
  def resolver; end
  def scope; end
  def setup!; end
  def stores_foreign_key?; end
  def validation_default; end

  private

  def create_foreign_key_field!; end
  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def index_spec; end
  def polymorph!; end
  def polymorphic_inverses(other = T.unsafe(nil)); end
  def require_association?; end
  def setup_instance_methods!; end
end

Mongoid::Association::Referenced::BelongsTo::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Referenced::BelongsTo::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  def bind_one; end
  def unbind_one; end

  private

  def check_polymorphic_inverses!(doc); end
end

module Mongoid::Association::Referenced::BelongsTo::Buildable
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  def execute_query(object, type); end
  def query?(object); end
  def query_criteria(object, type); end
end

class Mongoid::Association::Referenced::BelongsTo::Eager < ::Mongoid::Association::Eager
  private

  def each_loaded_document(&block); end
  def group_by_key; end
  def key; end
  def keys_by_type_from_docs; end
  def preload; end
end

Mongoid::Association::Referenced::BelongsTo::FOREIGN_KEY_FIELD_TYPE = Object
Mongoid::Association::Referenced::BelongsTo::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

class Mongoid::Association::Referenced::BelongsTo::Proxy < ::Mongoid::Association::One
  include ::Mongoid::Evolvable

  def initialize(base, target, association); end

  def nullify; end
  def substitute(replacement); end

  private

  def binding; end
  def normalize(replacement); end
  def persistable?; end

  class << self
    def eager_loader(association, docs); end
    def embedded?; end
  end
end

Mongoid::Association::Referenced::BelongsTo::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Association::Referenced::CounterCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods

  def reset_counters(*counters); end

  class << self
    def define_callbacks!(association); end
  end
end

module Mongoid::Association::Referenced::CounterCache::ClassMethods
  def decrement_counter(counter_name, id); end
  def increment_counter(counter_name, id); end
  def reset_counters(id, *counters); end
  def update_counters(id, counters); end
end

class Mongoid::Association::Referenced::HasAndBelongsToMany
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable

  def bindable?(doc); end
  def criteria(base, id_list = T.unsafe(nil)); end
  def embedded?; end
  def forced_nil_inverse?; end
  def foreign_key; end
  def inverse_foreign_key; end
  def inverse_foreign_key_setter; end
  def nested_builder(attributes, options); end
  def path(document); end
  def relation; end
  def relation_complements; end
  def scope; end
  def setup!; end
  def stores_foreign_key?; end
  def validation_default; end

  private

  def create_foreign_key_field!; end
  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def index_spec; end
  def query_criteria(id_list); end
  def setup_instance_methods!; end
  def setup_syncing!; end
  def synced_destroy; end
  def synced_save; end
  def with_ordering(criteria); end
end

Mongoid::Association::Referenced::HasAndBelongsToMany::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Referenced::HasAndBelongsToMany::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  def bind_one(doc); end
  def determine_inverse_association(doc); end
  def inverse_record_id(doc); end
  def unbind_one(doc); end
end

module Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  def query?(object); end
end

class Mongoid::Association::Referenced::HasAndBelongsToMany::Eager < ::Mongoid::Association::Eager
  private

  def group_by_key; end
  def key; end
  def keys_from_docs; end
  def preload; end
  def set_relation(doc, element); end
end

Mongoid::Association::Referenced::HasAndBelongsToMany::FOREIGN_KEY_FIELD_TYPE = Array
Mongoid::Association::Referenced::HasAndBelongsToMany::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

class Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy < ::Mongoid::Association::Referenced::HasMany::Proxy
  extend ::Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy::ClassMethods

  def <<(*args); end
  def build(attributes = T.unsafe(nil), type = T.unsafe(nil)); end
  def clear(replacement = T.unsafe(nil)); end
  def concat(documents); end
  def delete(document); end
  def delete_one(document); end
  def new(attributes = T.unsafe(nil), type = T.unsafe(nil)); end
  def nullify(replacement = T.unsafe(nil)); end
  def nullify_all(replacement = T.unsafe(nil)); end
  def purge(replacement = T.unsafe(nil)); end
  def push(*args); end
  def substitute(replacement); end
  def unscoped; end

  private

  def append(document); end
  def append_document(doc, ids, docs, inserts); end
  def binding; end
  def child_persistable?(doc); end
  def cleanup_inverse_for(replacement); end
  def clear_foreign_key_changes; end
  def clear_target_for_nullify; end
  def criteria(id_list = T.unsafe(nil)); end
  def inverse_primary_key; end
  def reset_foreign_key_changes; end
  def unsynced(doc, key); end
end

module Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy::ClassMethods
  def eager_loader(association, docs); end
  def embedded?; end
end

Mongoid::Association::Referenced::HasAndBelongsToMany::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Referenced::HasMany
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::HasMany::Buildable
  include ::Mongoid::Association::Referenced::WithPolymorphicCriteria

  def add_polymorphic_criterion(*args, **_arg1, &block); end
  def bindable?(doc); end
  def criteria(base); end
  def embedded?; end
  def foreign_key; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorphic?; end
  def relation; end
  def relation_complements; end
  def scope; end
  def setup!; end
  def setup_instance_methods!; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end

  private

  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def polymorphic_inverses(other); end
  def query_criteria(object, base); end
  def with_inverse_field_criterion(criteria); end
  def with_ordering(criteria); end
end

Mongoid::Association::Referenced::HasMany::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Referenced::HasMany::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  def bind_one(doc); end
  def unbind_one(doc); end
end

module Mongoid::Association::Referenced::HasMany::Buildable
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  def query?(object); end
end

class Mongoid::Association::Referenced::HasMany::Eager < ::Mongoid::Association::Eager
  private

  def group_by_key; end
  def key; end
  def preload; end
  def set_relation(doc, element); end
end

class Mongoid::Association::Referenced::HasMany::Enumerable
  include ::Enumerable
  include ::Mongoid::Pluckable
  extend ::Forwardable

  def initialize(target, base = T.unsafe(nil), association = T.unsafe(nil)); end

  def <<(document); end
  def ==(other); end
  def ===(other); end
  def _added; end
  def _added=(_arg0); end
  def _loaded; end
  def _loaded=(_arg0); end
  def _loaded?; end
  def _unloaded; end
  def _unloaded=(_arg0); end
  def any?(*args); end
  def as_json(options = T.unsafe(nil)); end
  def clear; end
  def clone; end
  def delete(document); end
  def delete_if(&block); end
  def each; end
  def empty?; end
  def first(limit = T.unsafe(nil)); end
  def in_memory; end
  def include?(doc); end
  def inspect; end
  def is_a?(*args, **_arg1, &block); end
  def kind_of?(*args, **_arg1, &block); end
  def last(limit = T.unsafe(nil)); end
  def length; end
  def load_all!(*_arg0); end
  def marshal_dump; end
  def marshal_load(data); end
  def pluck(*keys); end
  def push(document); end
  def reset; end
  def reset_unloaded(criteria); end
  def respond_to?(name, include_private = T.unsafe(nil)); end
  def size; end
  def to_json(options = T.unsafe(nil)); end
  def uniq; end

  private

  def method_missing(name, *args, **_arg2, &block); end
  def set_base(document); end
  def unloaded_documents; end
  def unsatisfiable_criteria?(selector); end
end

Mongoid::Association::Referenced::HasMany::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

class Mongoid::Association::Referenced::HasMany::Proxy < ::Mongoid::Association::Many
  extend ::Mongoid::Association::Referenced::HasMany::Proxy::ClassMethods

  def initialize(base, target, association); end

  def <<(*args); end
  def build(attributes = T.unsafe(nil), type = T.unsafe(nil)); end
  def clear; end
  def concat(documents); end
  def count(*args, **_arg1, &block); end
  def delete(document); end
  def delete_all(conditions = T.unsafe(nil)); end
  def delete_one(document); end
  def destroy_all(conditions = T.unsafe(nil)); end
  def each(&block); end
  def exists?(id_or_conditions = T.unsafe(nil)); end
  def find(*args, &block); end
  def first(*args, **_arg1, &block); end
  def in_memory(*args, **_arg1, &block); end
  def last(*args, **_arg1, &block); end
  def new(attributes = T.unsafe(nil), type = T.unsafe(nil)); end
  def nullify; end
  def nullify_all; end
  def pluck(*fields); end
  def purge; end
  def push(*args); end
  def reset(*args, **_arg1, &block); end
  def substitute(replacement); end
  def uniq(*args, **_arg1, &block); end
  def unscoped; end

  private

  def already_related?(document); end
  def append(document); end
  def binding; end
  def cascade!(document); end
  def collection; end
  def criteria; end
  def method_missing(name, *args, **_arg2, &block); end
  def persist_delayed(docs, inserts); end
  def persistable?; end
  def remove_all(conditions = T.unsafe(nil), method = T.unsafe(nil)); end
  def remove_not_in(ids); end
  def save_or_delay(doc, docs, inserts); end
  def update_or_delete_all(removed); end
  def with_add_callbacks(document, already_related); end
end

module Mongoid::Association::Referenced::HasMany::Proxy::ClassMethods
  def eager_loader(association, docs); end
  def embedded?; end
end

Mongoid::Association::Referenced::HasMany::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Referenced::HasOne
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::WithPolymorphicCriteria
  include ::Mongoid::Association::Referenced::HasOne::Buildable

  def bindable?(doc); end
  def embedded?; end
  def foreign_key; end
  def nested_builder(attributes, options); end
  def path(document); end
  def polymorphic?; end
  def relation; end
  def relation_complements; end
  def scope; end
  def setup!; end
  def stores_foreign_key?; end
  def type; end
  def validation_default; end

  private

  def default_foreign_key_field; end
  def default_primary_key; end
  def determine_inverses(other); end
  def polymorphic_inverses(other); end
  def setup_instance_methods!; end
end

Mongoid::Association::Referenced::HasOne::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Association::Referenced::HasOne::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  def bind_one; end
  def unbind_one; end
end

module Mongoid::Association::Referenced::HasOne::Buildable
  include ::Mongoid::Association::Referenced::WithPolymorphicCriteria

  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  def clear_associated(object); end
  def execute_query(object, base); end
  def query?(object); end
  def query_criteria(object, base); end
end

class Mongoid::Association::Referenced::HasOne::Eager < ::Mongoid::Association::Eager
  private

  def group_by_key; end
  def key; end
  def preload; end
end

Mongoid::Association::Referenced::HasOne::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

class Mongoid::Association::Referenced::HasOne::Proxy < ::Mongoid::Association::One
  extend ::Mongoid::Association::Referenced::HasOne::Proxy::ClassMethods

  def initialize(base, target, association); end

  def nullify; end
  def substitute(replacement); end

  private

  def binding; end
  def persistable?; end
  def prepare_for_replacement; end
end

module Mongoid::Association::Referenced::HasOne::Proxy::ClassMethods
  def eager_loader(association, docs); end
  def embedded?; end
end

Mongoid::Association::Referenced::HasOne::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Association::Referenced::Syncable
  def _syncable?(association); end
  def _synced; end
  def _synced?(foreign_key); end
  def remove_inverse_keys(association); end
  def update_inverse_keys(association); end
end

module Mongoid::Association::Referenced::Syncable::ClassMethods
  def _synced(association); end

  private

  def synced_destroy(association); end
  def synced_save(association); end
end

module Mongoid::Association::Referenced::WithPolymorphicCriteria
  def with_polymorphic_criterion(criteria, base); end
end

module Mongoid::Association::Reflections
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods

  def reflect_on_all_association(*macros); end
  def reflect_on_association(name); end
end

module Mongoid::Association::Reflections::ClassMethods
  def reflect_on_all_associations(*macros); end
  def reflect_on_association(name); end
end

module Mongoid::Association::Relatable
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options

  def initialize(_class, name, opts = T.unsafe(nil), &block); end

  def ==(other); end
  def bindable?(doc); end
  def class_name; end
  def counter_cache_column_name; end
  def create_relation(owner, target); end
  def destructive?; end
  def extension; end
  def foreign_key_check; end
  def foreign_key_setter; end
  def get_callbacks(callback_type); end
  def in_to?; end
  def inverse(other = T.unsafe(nil)); end
  def inverse_association(other = T.unsafe(nil)); end
  def inverse_class; end
  def inverse_class_name; end
  def inverse_klass; end
  def inverse_setter(other = T.unsafe(nil)); end
  def inverse_type; end
  def inverse_type_setter; end
  def inverses(other = T.unsafe(nil)); end
  def key; end
  def klass; end
  def many?; end
  def name; end
  def one?; end
  def options; end
  def parent_inclusions; end
  def parent_inclusions=(_arg0); end
  def path(document); end
  def relation_class; end
  def relation_class_name; end
  def setter; end
  def type_setter; end
  def validate?; end

  private

  def create_extension!(&block); end
  def default_inverse; end
  def define_autosaver!; end
  def define_builder!; end
  def define_counter_cache_callbacks!; end
  def define_creator!; end
  def define_dependency!; end
  def define_existence_check!; end
  def define_getter!; end
  def define_ids_getter!; end
  def define_ids_setter!; end
  def define_setter!; end
  def define_touchable!; end
  def inverse_association_classes; end
  def namespace_hierarchy(mod); end
  def polymorph!; end
  def resolve_name(mod, name); end
  def setup_index!; end
  def validate!; end
end

Mongoid::Association::Relatable::PRIMARY_KEY_DEFAULT = T.let(T.unsafe(nil), String)
Mongoid::Association::Relatable::SHARED_OPTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Atomic
  extend ::ActiveSupport::Concern

  def _updates(_use_indexes = T.unsafe(nil)); end
  def add_atomic_pull(document); end
  def add_atomic_unset(document); end
  def atomic_array_add_to_sets; end
  def atomic_array_pulls; end
  def atomic_array_pushes; end
  def atomic_attribute_name(name); end
  def atomic_delete_modifier; end
  def atomic_insert_modifier; end
  def atomic_path; end
  def atomic_paths; end
  def atomic_position; end
  def atomic_pulls; end
  def atomic_pushes; end
  def atomic_sets; end
  def atomic_unsets; end
  def atomic_updates(_use_indexes = T.unsafe(nil)); end
  def delayed_atomic_pulls; end
  def delayed_atomic_sets; end
  def delayed_atomic_unsets; end
  def flag_as_destroyed; end
  def flagged_destroys; end
  def process_flagged_destroys; end

  private

  def generate_atomic_updates(mods, doc); end
  def reset_atomic_updates!; end
end

class Mongoid::Atomic::Modifiers < ::Hash
  def add_to_set(modifications); end
  def pull(modifications); end
  def pull_all(modifications); end
  def push(modifications); end
  def set(modifications); end
  def unset(modifications); end

  private

  def add_each_operation(mods, field, value); end
  def add_operation(mods, field, value); end
  def add_to_sets; end
  def conflicting_pulls; end
  def conflicting_pushes; end
  def conflicting_sets; end
  def conflicts; end
  def pull_alls; end
  def pull_fields; end
  def pulls; end
  def push_conflict?(field); end
  def push_fields; end
  def pushes; end
  def set_conflict?(field); end
  def set_fields; end
  def sets; end
  def unsets; end
end

module Mongoid::Atomic::Paths; end

module Mongoid::Atomic::Paths::Embedded
  def delete_modifier; end
  def document; end
  def insert_modifier; end
  def parent; end
  def path; end
end

class Mongoid::Atomic::Paths::Embedded::Many
  include ::Mongoid::Atomic::Paths::Embedded

  def initialize(document); end

  def position; end

  class << self
    def position_without_document(parent, association); end
  end
end

class Mongoid::Atomic::Paths::Embedded::One
  include ::Mongoid::Atomic::Paths::Embedded

  def initialize(document); end

  def position; end
end

class Mongoid::Atomic::Paths::Root
  def initialize(document); end

  def document; end
  def insert_modifier; end
  def path; end
  def position; end
end

Mongoid::Atomic::UPDATES = T.let(T.unsafe(nil), Array)

class Mongoid::AtomicUpdatePreparer
  class << self
    def prepare(attributes, klass); end

    private

    def mongoize_for(operator, klass, key, value); end
    def prepare_operation(klass, key, value); end
    def value_for(operator, klass, key, value); end
  end
end

module Mongoid::Attributes
  include ::Mongoid::Attributes::Processing
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::ClassMethods

  def [](name); end
  def []=(name, value); end
  def assign_attributes(attrs = T.unsafe(nil)); end
  def attribute_missing?(name); end
  def attribute_present?(name); end
  def attributes; end
  def attributes=(attrs = T.unsafe(nil)); end
  def attributes_before_type_cast; end
  def has_attribute?(name); end
  def has_attribute_before_type_cast?(name); end
  def process_raw_attribute(name, raw, field); end
  def raw_attributes; end
  def read_attribute(name); end
  def read_attribute_before_type_cast(name); end
  def remove_attribute(name); end
  def typed_attributes; end
  def write_attribute(name, value); end
  def write_attributes(attrs = T.unsafe(nil)); end

  private

  def attribute_will_not_change?(field_name, typed_value); end
  def hash_dot_syntax?(string); end
  def lookup_attribute_presence(name, value); end
  def normalize_value(value); end
  def read_raw_attribute(name); end
  def typed_value_for(key, value); end

  module GeneratedClassMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end

  module GeneratedInstanceMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end
end

module Mongoid::Attributes::ClassMethods
  def alias_attribute(name, original); end
  def unalias_attribute(name); end
end

module Mongoid::Attributes::Dynamic
  extend ::ActiveSupport::Concern

  def define_dynamic_before_type_cast_reader(name); end
  def define_dynamic_reader(name); end
  def define_dynamic_writer(name); end
  def inspect_dynamic_fields; end
  def method_missing(name, *args); end
  def process_attribute(name, value); end
  def respond_to?(name, include_private = T.unsafe(nil)); end
end

module Mongoid::Attributes::Embedded
  extend ::Mongoid::Attributes::Embedded

  def traverse(attributes, path); end
end

module Mongoid::Attributes::Nested
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods

  module GeneratedClassMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
  end

  module GeneratedInstanceMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
  end
end

module Mongoid::Attributes::Nested::ClassMethods
  def accepts_nested_attributes_for(*args); end

  private

  def autosave_nested_attributes(association); end
end

Mongoid::Attributes::Nested::ClassMethods::REJECT_ALL_BLANK_PROC = T.let(T.unsafe(nil), Proc)

module Mongoid::Attributes::Processing
  def process_attributes(attrs = T.unsafe(nil)); end

  private

  def pending_attribute?(key, value); end
  def pending_nested; end
  def pending_relations; end
  def process_attribute(name, value); end
  def process_nested; end
  def process_pending; end
  def process_relations; end
  def set_pending_nested(name, aliased, value); end
  def set_pending_relation(name, aliased, value); end
end

class Mongoid::Attributes::Projector
  def initialize(projection); end

  def attribute_or_path_allowed?(name); end
  def content_projection; end
  def id_projection_value; end

  private

  def content_inclusionary?; end
  def value_inclusionary?(value); end
end

module Mongoid::Attributes::Readonly
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods

  def attribute_writable?(name); end

  private

  def _loaded?(name); end
  def as_writable_attribute!(name, value = T.unsafe(nil)); end
  def projected_field?(name); end

  module GeneratedClassMethods
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end

  module GeneratedInstanceMethods
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end
end

module Mongoid::Attributes::Readonly::ClassMethods
  def attr_readonly(*names); end
end

class Mongoid::Boolean
  extend ::Mongoid::Criteria::Queryable::Extensions::Boolean::ClassMethods

  class << self
    def demongoize(object); end
    def mongoize(object); end
  end
end

module Mongoid::Cacheable
  extend ::ActiveSupport::Concern

  def cache_key; end
end

module Mongoid::Changeable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Changeable::ClassMethods

  def attribute_before_last_save(attr); end
  def changed; end
  def changed?; end
  def changed_attributes; end
  def changes; end
  def children_changed?; end
  def children_may_have_changed!; end
  def move_changes; end
  def post_persist; end
  def previous_changes; end
  def remove_change(name); end
  def saved_change_to_attribute(attr); end
  def saved_change_to_attribute?(attr, from: T.unsafe(nil), to: T.unsafe(nil)); end
  def setters; end
  def will_save_change_to_attribute?(attr, **kwargs); end

  private

  def attribute_change(attr); end
  def attribute_changed?(attr, from: T.unsafe(nil), to: T.unsafe(nil)); end
  def attribute_changed_from_default?(attr); end
  def attribute_previously_was(attr); end
  def attribute_was(attr); end
  def attribute_will_change!(attr); end
  def attributes_before_last_save; end
  def changes_before_last_save; end
  def previous_attributes; end
  def reset_attribute!(attr); end
  def reset_attribute_to_default!(attr); end
  def reset_attributes_before_type_cast; end
end

Mongoid::Changeable::ATTRIBUTE_UNCHANGED = T.let(T.unsafe(nil), Mongoid::Changeable::Anything)

class Mongoid::Changeable::Anything
  def ==(_other); end
end

module Mongoid::Changeable::ClassMethods
  private

  def create_dirty_change_accessor(name, meth); end
  def create_dirty_change_check(name, meth); end
  def create_dirty_change_flag(name, meth); end
  def create_dirty_default_change_check(name, meth); end
  def create_dirty_methods(name, meth); end
  def create_dirty_previous_change(name, meth); end
  def create_dirty_previous_value_accessor(name, meth); end
  def create_dirty_previously_changed?(name, meth); end
  def create_dirty_reset(name, meth); end
  def create_dirty_reset_to_default(name, meth); end
end

module Mongoid::Clients
  include ::Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Sessions::ClassMethods

  class << self
    def clear; end
    def clients; end
    def default; end
    def disconnect; end
    def reconnect; end
    def set(name, client); end
    def with_name(name); end
  end

  module GeneratedClassMethods
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
  end

  module GeneratedInstanceMethods; end
end

module Mongoid::Clients::Factory
  extend ::Mongoid::Clients::Factory
  extend ::Mongoid::Loggable

  def create(name = T.unsafe(nil)); end
  def default; end

  private

  def build_auto_encryption_options(opts, database); end
  def create_client(configuration); end
  def driver_version; end
  def options(opts); end
end

Mongoid::Clients::Factory::MONGOID_WRAPPING_LIBRARY = T.let(T.unsafe(nil), Hash)

module Mongoid::Clients::Options
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods

  def collection(parent = T.unsafe(nil)); end
  def collection_name; end
  def mongo_client; end
  def persistence_context; end
  def persistence_context?; end
  def with(options_or_context, &block); end

  private

  def clear_persistence_context(original_cluster = T.unsafe(nil), context = T.unsafe(nil)); end
  def default_storage_options; end
  def set_persistence_context(options_or_context); end
end

module Mongoid::Clients::Options::ClassMethods
  def client_name; end
  def collection; end
  def collection_name; end
  def database_name; end
  def mongo_client; end
  def persistence_context; end
  def with(options, &block); end
end

module Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods

  private

  def ensure_client_compatibility!; end

  class << self
    def included(base); end
  end
end

module Mongoid::Clients::Sessions::ClassMethods
  def after_commit(*args, &block); end
  def after_create_commit(*args, &block); end
  def after_destroy_commit(*args, &block); end
  def after_rollback(*args, &block); end
  def after_save_commit(*args, &block); end
  def after_update_commit(*args, &block); end
  def transaction(options = T.unsafe(nil), session_options: T.unsafe(nil)); end
  def with_session(options = T.unsafe(nil)); end

  private

  def _session; end
  def assert_valid_transaction_action(actions); end
  def in_transaction?; end
  def run_abort_callbacks(session); end
  def run_commit_callbacks(session); end
  def set_options_for_callbacks!(args, enforced_options = T.unsafe(nil)); end
  def transaction_include_any_action?(actions); end
  def transactions_not_supported_exceptions; end
end

Mongoid::Clients::Sessions::ClassMethods::CALLBACK_ACTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Clients::StorageOptions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods

  def remember_storage_options!; end
  def remembered_storage_options; end
  def remembered_storage_options=(_arg0); end
  def storage_options; end

  module GeneratedClassMethods
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
  end

  module GeneratedInstanceMethods; end
end

module Mongoid::Clients::StorageOptions::ClassMethods
  def reset_storage_options!; end
  def storage_options_defaults; end
  def store_in(options); end
end

module Mongoid::Clients::Validators; end

module Mongoid::Clients::Validators::Storage
  extend ::Mongoid::Clients::Validators::Storage

  def validate(klass, options); end

  private

  def valid_keys?(options); end
end

Mongoid::Clients::Validators::Storage::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::CollectionConfigurable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::CollectionConfigurable::ClassMethods
end

module Mongoid::CollectionConfigurable::ClassMethods
  def create_collection(force: T.unsafe(nil)); end
end

module Mongoid::Composable
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::Mongoid::Evolvable
  include ::Mongoid::Inspectable
  include ::Mongoid::Reloadable
  include ::Mongoid::Stateful
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations
  include ::ActiveModel::Conversion
  include ::ActiveModel::API
  include ::ActiveModel::Model
  include ::ActiveModel::Serializers::JSON
  include ::Mongoid::Atomic
  include ::Mongoid::Changeable
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients
  include ::Mongoid::CollectionConfigurable
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly
  include ::Mongoid::Attributes
  include ::Mongoid::Fields
  include ::Mongoid::Identifiable
  include ::Mongoid::Indexable
  include ::Mongoid::Matchable
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable
  include ::Mongoid::Persistable
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections
  include ::Mongoid::Association
  include ::Mongoid::Scopable
  include ::Mongoid::SearchIndexable
  include ::Mongoid::Selectable
  include ::Mongoid::Serializable
  include ::Mongoid::Shardable
  include ::Mongoid::Cacheable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Traversable
  include ::Mongoid::Validatable::Macros
  include ::Mongoid::Validatable
  include ::ActiveModel::Validations::Callbacks
  include ::Mongoid::Interceptable
  include ::Mongoid::Copyable
  include ::Mongoid::Equality
  include ::Mongoid::Encryptable

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveModel::Conversion::ClassMethods
  mixes_in_class_methods ::Mongoid::Changeable::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Sessions::ClassMethods
  mixes_in_class_methods ::Mongoid::CollectionConfigurable::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::ClassMethods
  mixes_in_class_methods ::Mongoid::Fields::ClassMethods
  mixes_in_class_methods ::Mongoid::Identifiable::ClassMethods
  mixes_in_class_methods ::Mongoid::Indexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::Syncable::ClassMethods
  mixes_in_class_methods ::Mongoid::Scopable::ClassMethods
  mixes_in_class_methods ::Mongoid::SearchIndexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Shardable::ClassMethods
  mixes_in_class_methods ::Mongoid::Threaded::Lifecycle::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorRetrieval
  mixes_in_class_methods ::Mongoid::Validatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Validatable::Macros
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::Mongoid::Equality::ClassMethods
  mixes_in_class_methods ::Mongoid::Encryptable::ClassMethods
  mixes_in_class_methods ::Mongoid::Findable
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorAssignment

  class << self
    def prohibited_methods; end
  end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def discriminator_key; end
    def discriminator_key=(value); end
    def discriminator_key?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter; end
    def param_delimiter=(value); end
    def param_delimiter?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter=(value); end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

Mongoid::Composable::MODULES = T.let(T.unsafe(nil), Array)
Mongoid::Composable::RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Array)

module Mongoid::Config
  include ::Mongoid::Config::DeprecatedOptions
  extend ::Forwardable
  extend ::Mongoid::Config::Options
  extend ::Mongoid::Config::Defaults
  extend ::Mongoid::Config::Encryption
  extend ::Mongoid::Config
  extend ::Mongoid::Config::DeprecatedOptions

  def allow_bson5_decimal128; end
  def allow_bson5_decimal128=(value); end
  def allow_bson5_decimal128?; end
  def allow_scopes_to_unset_default_scope; end
  def allow_scopes_to_unset_default_scope=(value); end
  def allow_scopes_to_unset_default_scope?; end
  def app_name; end
  def app_name=(value); end
  def app_name?; end
  def around_callbacks_for_embeds; end
  def around_callbacks_for_embeds=(value); end
  def around_callbacks_for_embeds?; end
  def async_query_executor; end
  def async_query_executor=(value); end
  def async_query_executor?; end
  def background_indexing; end
  def background_indexing=(value); end
  def background_indexing?; end
  def belongs_to_required_by_default; end
  def belongs_to_required_by_default=(value); end
  def belongs_to_required_by_default?; end
  def clients; end
  def config; end
  def configured?; end
  def connect_to(name, options = T.unsafe(nil)); end
  def deregister_model(klass); end
  def destructive_fields; end
  def discriminator_key; end
  def discriminator_key=(value); end
  def discriminator_key?; end
  def duplicate_fields_exception; end
  def duplicate_fields_exception=(value); end
  def duplicate_fields_exception?; end
  def global_executor_concurrency; end
  def global_executor_concurrency=(value); end
  def global_executor_concurrency?; end
  def immutable_ids; end
  def immutable_ids=(value); end
  def immutable_ids?; end
  def include_root_in_json; end
  def include_root_in_json=(value); end
  def include_root_in_json?; end
  def include_type_for_serialization; end
  def include_type_for_serialization=(value); end
  def include_type_for_serialization?; end
  def join_contexts; end
  def join_contexts=(value); end
  def join_contexts?; end
  def legacy_persistence_context_behavior; end
  def legacy_persistence_context_behavior=(value); end
  def legacy_persistence_context_behavior?; end
  def legacy_readonly; end
  def legacy_readonly=(value); end
  def legacy_readonly?; end
  def load!(path, environment = T.unsafe(nil)); end
  def load_configuration(settings); end
  def log_level=(value); end
  def log_level?; end
  def logger(*args, **_arg1, &block); end
  def logger=(*args, **_arg1, &block); end
  def map_big_decimal_to_decimal128; end
  def map_big_decimal_to_decimal128=(value); end
  def map_big_decimal_to_decimal128?; end
  def models; end
  def options=(options); end
  def override_client(name); end
  def override_database(name); end
  def preload_models; end
  def preload_models=(value); end
  def preload_models?; end
  def prevent_multiple_calls_of_embedded_callbacks; end
  def prevent_multiple_calls_of_embedded_callbacks=(value); end
  def prevent_multiple_calls_of_embedded_callbacks?; end
  def purge!; end
  def raise_not_found_error; end
  def raise_not_found_error=(value); end
  def raise_not_found_error?; end
  def register_model(klass); end
  def running_with_passenger?(*args, **_arg1, &block); end
  def scope_overwrite_exception; end
  def scope_overwrite_exception=(value); end
  def scope_overwrite_exception?; end
  def time_zone; end
  def truncate!; end
  def use_utc; end
  def use_utc=(value); end
  def use_utc?; end

  private

  def clients=(clients); end
  def global_client; end
  def set_log_levels; end
end

module Mongoid::Config::Defaults
  def load_defaults(version); end
end

module Mongoid::Config::DeprecatedOptions; end
Mongoid::Config::DeprecatedOptions::OPTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Config::Encryption
  extend ::Mongoid::Config::Encryption

  def encryption_schema_map(default_database, models = T.unsafe(nil)); end

  private

  def algorithm_for(field); end
  def bson_type_for(field); end
  def key_id_for(key_id_base64, key_name_field); end
  def metadata_for(model); end
  def properties_for(model, visited); end
  def properties_for_fields(model); end
  def properties_for_relations(model, visited); end
end

Mongoid::Config::Encryption::DETERMINISTIC_ALGORITHM = T.let(T.unsafe(nil), String)
Mongoid::Config::Encryption::RANDOM_ALGORITHM = T.let(T.unsafe(nil), String)
Mongoid::Config::Encryption::TYPE_MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongoid::Config::Environment
  extend ::Mongoid::Config::Environment

  def env_name; end
  def load_yaml(path, environment = T.unsafe(nil)); end
end

module Mongoid::Config::Introspection
  extend ::Mongoid::Config::Introspection

  def options(include_deprecated: T.unsafe(nil)); end
end

Mongoid::Config::Introspection::CONFIG_RB_PATH = T.let(T.unsafe(nil), String)
Mongoid::Config::Introspection::OPTION_PATTERN = T.let(T.unsafe(nil), Regexp)

class Mongoid::Config::Introspection::Option
  def initialize(name, default, comment); end

  def ==(option); end
  def comment; end
  def default; end
  def deprecated?; end
  def indented_comment(indent: T.unsafe(nil), indent_first_line: T.unsafe(nil)); end
  def name; end

  private

  def unindent(text); end

  class << self
    def from_captures(captures); end
  end
end

Mongoid::Config::LOCK = T.let(T.unsafe(nil), Thread::Mutex)

module Mongoid::Config::Options
  def defaults; end
  def log_level; end
  def option(name, options = T.unsafe(nil)); end
  def reset; end
  def settings; end
end

module Mongoid::Config::Validators; end

module Mongoid::Config::Validators::AsyncQueryExecutor
  extend ::Mongoid::Config::Validators::AsyncQueryExecutor

  def validate(options); end
end

module Mongoid::Config::Validators::Client
  extend ::Mongoid::Config::Validators::Client

  def validate(clients); end

  private

  def both_uri_and_standard?(config); end
  def no_database_or_uri?(config); end
  def no_hosts_or_uri?(config); end
  def validate_client_database(name, config); end
  def validate_client_hosts(name, config); end
  def validate_client_uri(name, config); end
end

Mongoid::Config::Validators::Client::STANDARD = T.let(T.unsafe(nil), Array)

module Mongoid::Config::Validators::Option
  extend ::Mongoid::Config::Validators::Option

  def validate(option); end
end

module Mongoid::Contextual
  extend ::Forwardable

  def add_each_to_set(*args, **_arg1, &block); end
  def add_to_set(*args, **_arg1, &block); end
  def aggregates(*args, **_arg1, &block); end
  def avg(*args, **_arg1, &block); end
  def bit(*args, **_arg1, &block); end
  def blank?(*args, **_arg1, &block); end
  def clamp_lower_bound(*args, **_arg1, &block); end
  def clamp_upper_bound(*args, **_arg1, &block); end
  def collection(*args, **_arg1, &block); end
  def context; end
  def count(*args, **_arg1, &block); end
  def criteria(*args, **_arg1, &block); end
  def database_field_name(*args, **_arg1, &block); end
  def delete(*args, **_arg1, &block); end
  def delete_all(*args, **_arg1, &block); end
  def destroy(*args, **_arg1, &block); end
  def destroy_all(*args, **_arg1, &block); end
  def distinct(*args, **_arg1, &block); end
  def documents_loader(*args, **_arg1, &block); end
  def each(*args, **_arg1, &block); end
  def empty?(*args, **_arg1, &block); end
  def estimated_count(*args, **_arg1, &block); end
  def exists?(*args, **_arg1, &block); end
  def explain(*args, **_arg1, &block); end
  def fifth(*args, **_arg1, &block); end
  def fifth!(*args, **_arg1, &block); end
  def find_first(*args, **_arg1, &block); end
  def find_one_and_delete(*args, **_arg1, &block); end
  def find_one_and_replace(*args, **_arg1, &block); end
  def find_one_and_update(*args, **_arg1, &block); end
  def first(*args, **_arg1, &block); end
  def first!(*args, **_arg1, &block); end
  def fourth(*args, **_arg1, &block); end
  def fourth!(*args, **_arg1, &block); end
  def inc(*args, **_arg1, &block); end
  def klass(*args, **_arg1, &block); end
  def last(*args, **_arg1, &block); end
  def last!(*args, **_arg1, &block); end
  def length(*args, **_arg1, &block); end
  def load_async; end
  def map_reduce(*args, **_arg1, &block); end
  def max(*args, **_arg1, &block); end
  def min(*args, **_arg1, &block); end
  def mul(*args, **_arg1, &block); end
  def one(*args, **_arg1, &block); end
  def pick(*args, **_arg1, &block); end
  def pluck(*args, **_arg1, &block); end
  def pop(*args, **_arg1, &block); end
  def pull(*args, **_arg1, &block); end
  def pull_all(*args, **_arg1, &block); end
  def push(*args, **_arg1, &block); end
  def push_all(*args, **_arg1, &block); end
  def rename(*args, **_arg1, &block); end
  def second(*args, **_arg1, &block); end
  def second!(*args, **_arg1, &block); end
  def second_to_last(*args, **_arg1, &block); end
  def second_to_last!(*args, **_arg1, &block); end
  def set(*args, **_arg1, &block); end
  def set_max(*args, **_arg1, &block); end
  def set_min(*args, **_arg1, &block); end
  def size(*args, **_arg1, &block); end
  def sort(*args, **_arg1, &block); end
  def sum(*args, **_arg1, &block); end
  def take(*args, **_arg1, &block); end
  def take!(*args, **_arg1, &block); end
  def tally(*args, **_arg1, &block); end
  def third(*args, **_arg1, &block); end
  def third!(*args, **_arg1, &block); end
  def third_to_last(*args, **_arg1, &block); end
  def third_to_last!(*args, **_arg1, &block); end
  def unset(*args, **_arg1, &block); end
  def update(*args, **_arg1, &block); end
  def update_all(*args, **_arg1, &block); end
  def view(*args, **_arg1, &block); end

  private

  def create_context; end
end

module Mongoid::Contextual::Aggregable; end
Mongoid::Contextual::Aggregable::EMPTY_RESULT = T.let(T.unsafe(nil), Hash)

module Mongoid::Contextual::Aggregable::Memory
  def aggregates(field); end
  def avg(field); end
  def max(field = T.unsafe(nil)); end
  def min(field = T.unsafe(nil)); end
  def sum(field = T.unsafe(nil)); end

  private

  def aggregate_by(field, method); end
end

module Mongoid::Contextual::Aggregable::Mongo
  def aggregates(field); end
  def avg(field); end
  def max(field = T.unsafe(nil)); end
  def min(field = T.unsafe(nil)); end
  def sum(field = T.unsafe(nil)); end

  private

  def pipeline(field); end
end

module Mongoid::Contextual::Aggregable::None
  def aggregates(_field); end
  def avg(_field); end
  def max(_field = T.unsafe(nil)); end
  def min(_field = T.unsafe(nil)); end
  def sum(_field = T.unsafe(nil)); end
end

module Mongoid::Contextual::Atomic
  def add_each_to_set(adds); end
  def add_to_set(adds); end
  def bit(bits); end
  def clamp_lower_bound(fields); end
  def clamp_upper_bound(fields); end
  def inc(incs); end
  def mul(factors); end
  def pop(pops); end
  def pull(pulls); end
  def pull_all(pulls); end
  def push(pushes); end
  def push_all(pushes); end
  def rename(renames); end
  def set(sets); end
  def set_max(fields); end
  def set_min(fields); end
  def unset(*unsets); end

  private

  def collect_each_operations(ops); end
  def collect_operations(ops, aggregator = T.unsafe(nil)); end
  def collect_unset_operations(ops); end
end

module Mongoid::Contextual::Command
  def client; end
  def collection; end
  def command; end
  def criteria; end
end

class Mongoid::Contextual::MapReduce
  include ::Enumerable
  include ::Mongoid::Contextual::Command
  extend ::Forwardable

  def initialize(collection, criteria, map, reduce); end

  def ==(*args, **_arg1, &block); end
  def [](*args, **_arg1, &block); end
  def command; end
  def counts; end
  def each; end
  def emitted; end
  def empty?(*args, **_arg1, &block); end
  def execute; end
  def finalize(function); end
  def input; end
  def inspect; end
  def js_mode; end
  def out(location); end
  def output; end
  def raw; end
  def reduced; end
  def results; end
  def scope(object); end
  def time; end

  private

  def _session; end
  def validate_out!; end
end

class Mongoid::Contextual::Memory
  include ::Enumerable
  include ::Mongoid::Contextual::Aggregable::Memory
  include ::Mongoid::Association::EagerLoadable
  include ::Mongoid::Contextual::Queryable
  include ::Mongoid::Positional

  def initialize(criteria); end

  def ==(other); end
  def delete; end
  def delete_all; end
  def destroy; end
  def destroy_all; end
  def distinct(field); end
  def documents; end
  def each; end
  def exists?(id_or_conditions = T.unsafe(nil)); end
  def fifth; end
  def fifth!; end
  def find_first(limit = T.unsafe(nil)); end
  def first(limit = T.unsafe(nil)); end
  def first!; end
  def fourth; end
  def fourth!; end
  def inc(incs); end
  def last(limit = T.unsafe(nil)); end
  def last!; end
  def length; end
  def limit(value); end
  def one(limit = T.unsafe(nil)); end
  def path; end
  def pick(*fields); end
  def pluck(*fields); end
  def root; end
  def second; end
  def second!; end
  def second_to_last; end
  def second_to_last!; end
  def selector; end
  def size; end
  def skip(value); end
  def sort(values); end
  def take(limit = T.unsafe(nil)); end
  def take!; end
  def tally(field); end
  def third; end
  def third!; end
  def third_to_last; end
  def third_to_last!; end
  def update(attributes = T.unsafe(nil)); end
  def update_all(attributes = T.unsafe(nil)); end

  private

  def _session; end
  def apply_options; end
  def apply_sorting; end
  def compare(a, b); end
  def compare_operand(value); end
  def documents_for_iteration; end
  def in_place_sort(values); end
  def limiting; end
  def limiting=(value); end
  def pluck_from_doc(doc, *fields); end
  def prepare_remove(doc); end
  def raise_document_not_found_error; end
  def retrieve_value_at_path(document, field_path); end
  def skipping; end
  def skipping=(value); end
  def update_documents(attributes, docs); end
end

class Mongoid::Contextual::Mongo
  include ::Enumerable
  include ::Mongoid::Contextual::Aggregable::Mongo
  include ::Mongoid::Contextual::Atomic
  include ::Mongoid::Association::EagerLoadable
  include ::Mongoid::Contextual::Queryable
  include ::Mongoid::Pluckable
  extend ::Forwardable

  def initialize(criteria); end

  def count(options = T.unsafe(nil), &block); end
  def database_field_name(*args, **_arg1, &block); end
  def delete; end
  def delete_all; end
  def destroy; end
  def destroy_all; end
  def distinct(field); end
  def documents_loader; end
  def each(&block); end
  def estimated_count(options = T.unsafe(nil)); end
  def exists?(id_or_conditions = T.unsafe(nil)); end
  def explain(*args, **_arg1, &block); end
  def fifth; end
  def fifth!; end
  def find_first; end
  def find_one_and_delete; end
  def find_one_and_replace(replacement, options = T.unsafe(nil)); end
  def find_one_and_update(update, options = T.unsafe(nil)); end
  def first(limit = T.unsafe(nil)); end
  def first!; end
  def fourth; end
  def fourth!; end
  def last(limit = T.unsafe(nil)); end
  def last!; end
  def length; end
  def limit(value); end
  def load_async; end
  def map_reduce(map, reduce); end
  def one(limit = T.unsafe(nil)); end
  def pick(*fields); end
  def pluck(*fields); end
  def second; end
  def second!; end
  def second_to_last; end
  def second_to_last!; end
  def size; end
  def skip(value); end
  def sort(values = T.unsafe(nil), &block); end
  def take(limit = T.unsafe(nil)); end
  def take!; end
  def tally(field); end
  def third; end
  def third!; end
  def third_to_last; end
  def third_to_last!; end
  def update(attributes = T.unsafe(nil), opts = T.unsafe(nil)); end
  def update_all(attributes = T.unsafe(nil), opts = T.unsafe(nil)); end
  def view; end

  private

  def _session; end
  def acknowledged_write?; end
  def apply_fields; end
  def apply_option(name); end
  def apply_options; end
  def demongoize_with_field(field, value, is_translation); end
  def documents_for_iteration; end
  def inverse_sorting; end
  def process_raw_docs(raw_docs, limit); end
  def raise_document_not_found_error; end
  def recursive_demongoize(field_name, value, is_translation); end
  def retrieve_nth(n); end
  def retrieve_nth_to_last(n); end
  def retrieve_nth_to_last_with_limit(n, limit); end
  def retrieve_nth_with_limit(n, limit); end
  def update_documents(attributes, method = T.unsafe(nil), opts = T.unsafe(nil)); end
  def valid_for_count_documents?(hash = T.unsafe(nil)); end
  def yield_document(document, &block); end
end

class Mongoid::Contextual::Mongo::DocumentsLoader
  include ::Mongoid::Association::EagerLoadable
  extend ::Forwardable

  def initialize(view, klass, criteria, executor: T.unsafe(nil)); end

  def criteria; end
  def criteria=(_arg0); end
  def execute; end
  def pending?; end
  def started?; end
  def unschedule; end
  def value(*args, **_arg1, &block); end
  def value!(*args, **_arg1, &block); end
  def wait(*args, **_arg1, &block); end
  def wait!(*args, **_arg1, &block); end

  private

  def start; end

  class << self
    def executor(name = T.unsafe(nil)); end
    def global_thread_pool_async_query_executor; end
    def immediate_executor; end
  end
end

Mongoid::Contextual::Mongo::OPTIONS = T.let(T.unsafe(nil), Array)

class Mongoid::Contextual::None
  include ::Enumerable
  include ::Mongoid::Contextual::Aggregable::None
  include ::Mongoid::Contextual::Queryable

  def initialize(criteria); end

  def ==(other); end
  def criteria; end
  def distinct(_field); end
  def each; end
  def exists?(id_or_conditions = T.unsafe(nil)); end
  def fifth; end
  def fifth!; end
  def find_first(limit = T.unsafe(nil)); end
  def first(limit = T.unsafe(nil)); end
  def first!; end
  def fourth; end
  def fourth!; end
  def klass; end
  def last(limit = T.unsafe(nil)); end
  def last!; end
  def length; end
  def one(limit = T.unsafe(nil)); end
  def pick(*_fields); end
  def pluck(*_fields); end
  def second; end
  def second!; end
  def second_to_last; end
  def second_to_last!; end
  def size; end
  def take(limit = T.unsafe(nil)); end
  def take!; end
  def tally(_field); end
  def third; end
  def third!; end
  def third_to_last; end
  def third_to_last!; end

  private

  def raise_document_not_found_error; end
end

module Mongoid::Contextual::Queryable
  def blank?; end
  def collection; end
  def criteria; end
  def empty?; end
  def klass; end
end

module Mongoid::Copyable
  extend ::ActiveSupport::Concern

  def clone; end
  def dup; end

  private

  def clone_document; end
  def process_localized_attributes(klass, attrs); end

  class << self
    def clone_with_hash(klass, attrs); end
  end
end

class Mongoid::Criteria
  include ::Enumerable
  include ::Mongoid::Contextual
  include ::Mongoid::Criteria::Queryable::Storable
  include ::Mongoid::Criteria::Queryable::Expandable
  include ::Mongoid::Criteria::Queryable::Mergeable
  include ::Mongoid::Criteria::Queryable::Aggregable
  include ::Mongoid::Criteria::Queryable::Selectable
  include ::Mongoid::Criteria::Queryable::Optional
  include ::Mongoid::Criteria::Queryable
  include ::Mongoid::Criteria::Findable
  include ::Mongoid::Criteria::Inspectable
  include ::Mongoid::Criteria::Includable
  include ::Mongoid::Criteria::Marshalable
  include ::Mongoid::Criteria::Modifiable
  include ::Mongoid::Criteria::Scopable
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods
  include ::Mongoid::Criteria::Options
  extend ::Mongoid::Clients::Options::ClassMethods

  def initialize(klass); end

  def ==(other); end
  def _enumerable_find(*_arg0); end
  def _findable_find(*args); end
  def as_json(options = T.unsafe(nil)); end
  def association; end
  def association=(_arg0); end
  def documents; end
  def documents=(docs); end
  def embedded; end
  def embedded=(_arg0); end
  def embedded?; end
  def empty_and_chainable?; end
  def extract_id; end
  def extras(extras); end
  def field_list; end
  def find(*args, &block); end
  def for_js(*args, **_arg1, &block); end
  def freeze; end
  def klass; end
  def klass=(_arg0); end
  def merge(other); end
  def merge!(other); end
  def none; end
  def only(*args); end
  def parent_document; end
  def parent_document=(_arg0); end
  def read(value = T.unsafe(nil)); end
  def respond_to?(name, include_private = T.unsafe(nil)); end
  def to_ary(*_arg0); end
  def to_criteria(*args, **_arg1, &block); end
  def to_proc; end
  def type(types); end
  def where(*args); end
  def without(*args); end
  def without_options; end

  private

  def check_for_missing_documents!(result, ids); end
  def initialize_copy(other); end
  def merge_type_selection; end
  def method_missing(name, *args, **_arg2, &block); end
  def selector_with_type_selection; end
  def type_selectable?; end
  def type_selection; end

  class << self
    def from_hash(*args, **_arg1, &block); end
  end
end

Mongoid::Criteria::ALLOWED_FROM_HASH_METHODS = T.let(T.unsafe(nil), Array)
Mongoid::Criteria::CHECK = T.let(T.unsafe(nil), Array)

module Mongoid::Criteria::Findable
  def execute_or_raise(ids, multi); end
  def find(*args); end
  def for_ids(ids); end
  def multiple_from_db(ids); end

  private

  def from_database(ids); end
  def from_database_selector(ids); end
  def id_finder; end
  def mongoize_ids(ids); end
  def multi_args?(args); end
  def prepare_ids_for_find(args); end
  def raise_invalid; end
end

module Mongoid::Criteria::Includable
  def includes(*relations); end
  def inclusions; end
  def inclusions=(value); end

  private

  def add_inclusion(association, parent = T.unsafe(nil)); end
  def extract_includes_list(_parent_class, parent, *relations_list); end
end

module Mongoid::Criteria::Inspectable
  def inspect; end
end

module Mongoid::Criteria::Marshalable
  def marshal_dump; end
  def marshal_load(data); end

  private

  def dump_hash(name); end
  def load_hash(hash_class, raw); end
end

module Mongoid::Criteria::Modifiable
  def build(attrs = T.unsafe(nil), &block); end
  def create(attrs = T.unsafe(nil), &block); end
  def create!(attrs = T.unsafe(nil), &block); end
  def create_attrs; end
  def create_with(attrs = T.unsafe(nil)); end
  def find_or_create_by(attrs = T.unsafe(nil), &block); end
  def find_or_create_by!(attrs = T.unsafe(nil), &block); end
  def find_or_initialize_by(attrs = T.unsafe(nil), &block); end
  def first_or_create(attrs = T.unsafe(nil), &block); end
  def first_or_create!(attrs = T.unsafe(nil), &block); end
  def first_or_initialize(attrs = T.unsafe(nil), &block); end
  def new(attrs = T.unsafe(nil), &block); end

  private

  def create_document(method, attrs = T.unsafe(nil), &block); end
  def find_or(method, attrs = T.unsafe(nil), &block); end
  def first_or(method, attrs = T.unsafe(nil), &block); end
  def invalid_embedded_doc?(value); end
  def invalid_key?(hash, key); end
end

module Mongoid::Criteria::Options
  private

  def clear_persistence_context(original_cluster, original_context); end
  def persistence_context; end
  def set_persistence_context(options); end
end

module Mongoid::Criteria::Queryable
  include ::Mongoid::Criteria::Queryable::Storable
  include ::Mongoid::Criteria::Queryable::Expandable
  include ::Mongoid::Criteria::Queryable::Mergeable
  include ::Mongoid::Criteria::Queryable::Aggregable
  include ::Mongoid::Criteria::Queryable::Selectable
  include ::Mongoid::Criteria::Queryable::Optional

  def initialize(aliases = T.unsafe(nil), serializers = T.unsafe(nil), associations = T.unsafe(nil), aliased_associations = T.unsafe(nil)); end

  def ==(other); end
  def aliases; end
  def serializers; end

  private

  def initialize_copy(other); end
end

module Mongoid::Criteria::Queryable::Aggregable
  extend ::Mongoid::Criteria::Queryable::Macroable

  def aggregating=(_arg0); end
  def aggregating?; end
  def group(operation); end
  def pipeline; end
  def project(operation = T.unsafe(nil)); end
  def unwind(field); end

  private

  def aggregation(operation); end
end

module Mongoid::Criteria::Queryable::Expandable
  private

  def expand_condition_to_array_values(criterion); end
  def expand_one_condition(field, value); end
end

module Mongoid::Criteria::Queryable::Extensions; end

module Mongoid::Criteria::Queryable::Extensions::Array
  def __add__(object); end
  def __array__; end
  def __deep_copy__; end
  def __evolve_date__; end
  def __evolve_time__; end
  def __expand_complex__; end
  def __intersect__(object); end
  def __sort_option__; end
  def __sort_pair__; end

  private

  def multi; end
end

module Mongoid::Criteria::Queryable::Extensions::Array::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::BigDecimal; end

module Mongoid::Criteria::Queryable::Extensions::BigDecimal::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Boolean; end

module Mongoid::Criteria::Queryable::Extensions::Boolean::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Date
  def __evolve_date__; end
  def __evolve_time__; end
end

module Mongoid::Criteria::Queryable::Extensions::Date::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::DateTime
  def __evolve_time__; end
end

module Mongoid::Criteria::Queryable::Extensions::DateTime::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Hash
  def __add__(object); end
  def __add_from_array__(array); end
  def __deep_copy__; end
  def __expand_complex__; end
  def __intersect__(object); end
  def __intersect_from_array__(array); end
  def __intersect_from_object__(object); end
  def __sort_option__; end
  def __union__(object); end
  def __union_from_object__(object); end

  private

  def apply_strategy(strategy, object); end
end

module Mongoid::Criteria::Queryable::Extensions::NilClass
  def __add__(object); end
  def __evolve_date__; end
  def __evolve_time__; end
  def __expanded__(object); end
  def __intersect__(object); end
  def __override__(object); end
  def __union__(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Numeric
  def __evolve_date__; end
  def __evolve_time__; end
end

module Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
  def __numeric__(object); end
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Object
  def __add__(object); end
  def __add_from_array__(array); end
  def __array__; end
  def __deep_copy__; end
  def __expand_complex__; end
  def __intersect__(object); end
  def __intersect_from_array__(array); end
  def __intersect_from_object__(object); end
  def __union__(object); end
  def __union_from_object__(object); end
  def regexp?(*args, **_arg1, &block); end
end

module Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  def evolve(object); end

  private

  def __evolve__(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Range
  def __array__; end
  def __evolve_date__; end
  def __evolve_range__(serializer: T.unsafe(nil)); end
  def __evolve_time__; end

  private

  def __evolve_range_naive__; end
end

module Mongoid::Criteria::Queryable::Extensions::Range::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Regexp
  def regexp?(*args, **_arg1, &block); end
end

module Mongoid::Criteria::Queryable::Extensions::Regexp::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_
  def regexp?(*args, **_arg1, &block); end
end

module Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Set; end

module Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::String
  def __evolve_date__; end
  def __evolve_time__; end
  def __expr_part__(value, negating = T.unsafe(nil)); end
  def __mongo_expression__; end
  def __sort_option__; end
end

module Mongoid::Criteria::Queryable::Extensions::String::ClassMethods
  def __expr_part__(key, value, negating = T.unsafe(nil)); end
  def evolve(object); end

  private

  def __regexp?(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Symbol
  def __expr_part__(value, negating = T.unsafe(nil)); end
end

module Mongoid::Criteria::Queryable::Extensions::Symbol::ClassMethods
  def add_key(name, strategy, operator, additional = T.unsafe(nil), &block); end
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::Time
  def __evolve_date__; end
  def __evolve_time__; end
end

module Mongoid::Criteria::Queryable::Extensions::Time::ClassMethods
  def evolve(object); end
end

module Mongoid::Criteria::Queryable::Extensions::TimeWithZone
  def __evolve_date__; end
  def __evolve_time__; end
end

module Mongoid::Criteria::Queryable::Extensions::TimeWithZone::ClassMethods
  def evolve(object); end
end

class Mongoid::Criteria::Queryable::Key
  def initialize(name, strategy, operator, expanded = T.unsafe(nil), &block); end

  def ==(other); end
  def __expr_part__(object, negating = T.unsafe(nil)); end
  def __sort_option__; end
  def __sort_pair__; end
  def block; end
  def eql?(other); end
  def expanded; end
  def hash; end
  def name; end
  def operator; end
  def strategy; end
  def to_s; end
  def transform_value(value, negating = T.unsafe(nil)); end
end

module Mongoid::Criteria::Queryable::Macroable
  def key(name, strategy, operator, additional = T.unsafe(nil), &block); end
end

module Mongoid::Criteria::Queryable::Mergeable
  def and_with_operator(criterion, operator); end
  def intersect; end
  def override; end
  def reset_strategies!; end
  def strategy; end
  def strategy=(_arg0); end
  def union; end

  private

  def __add__(criterion, operator); end
  def __expanded__(criterion, outer, inner); end
  def __intersect__(criterion, operator); end
  def __merge__(criterion); end
  def __multi__(criteria, operator); end
  def __override__(criterion, operator); end
  def __union__(criterion, operator); end
  def _mongoid_add_top_level_operation(operator, criteria); end
  def _mongoid_expand_keys(expr); end
  def _mongoid_flatten_arrays(array); end
  def prepare(field, operator, value); end
  def use(strategy); end
  def with_strategy(strategy, criterion, operator); end
end

module Mongoid::Criteria::Queryable::Optional
  extend ::Mongoid::Criteria::Queryable::Macroable

  def asc(*fields); end
  def ascending(*fields); end
  def batch_size(value = T.unsafe(nil)); end
  def collation(collation_doc); end
  def comment(comment = T.unsafe(nil)); end
  def cursor_type(type); end
  def desc(*fields); end
  def descending(*fields); end
  def hint(value = T.unsafe(nil)); end
  def limit(value = T.unsafe(nil)); end
  def max_scan(value = T.unsafe(nil)); end
  def max_time_ms(value = T.unsafe(nil)); end
  def no_timeout; end
  def offset(value = T.unsafe(nil)); end
  def only(*args); end
  def options; end
  def options=(_arg0); end
  def order(*spec); end
  def order_by(*spec); end
  def reorder(*spec); end
  def skip(value = T.unsafe(nil)); end
  def slice(criterion = T.unsafe(nil)); end
  def snapshot; end
  def without(*args); end

  private

  def add_sort_option(options, field, direction); end
  def option(*args); end
  def sort_with_list(*fields, direction); end

  class << self
    def forwardables; end
  end
end

class Mongoid::Criteria::Queryable::Options < ::Mongoid::Criteria::Queryable::Smash
  def []=(key, value, localize = T.unsafe(nil)); end
  def __deep_copy__; end
  def fields; end
  def limit; end
  def skip; end
  def sort; end
  def store(key, value, localize = T.unsafe(nil)); end
  def to_pipeline; end

  private

  def evolve(value, localize = T.unsafe(nil)); end
  def evolve_hash(value, localize = T.unsafe(nil)); end
end

class Mongoid::Criteria::Queryable::Pipeline < ::Array
  def initialize(aliases = T.unsafe(nil)); end

  def __deep_copy__; end
  def aliases; end
  def group(entry); end
  def project(entry); end
  def unwind(field_or_doc); end

  private

  def evolve(entry); end
end

module Mongoid::Criteria::Queryable::Selectable
  extend ::Mongoid::Criteria::Queryable::Macroable

  def all(*criteria); end
  def all_in(*criteria); end
  def all_of(*criteria); end
  def and(*criteria); end
  def any_in(condition); end
  def any_of(*criteria); end
  def between(criterion); end
  def elem_match(criterion); end
  def eq(criterion); end
  def excludes(criterion); end
  def exists(criterion); end
  def geo_spatial(criterion); end
  def gt(criterion); end
  def gte(criterion); end
  def in(condition); end
  def lt(criterion); end
  def lte(criterion); end
  def max_distance(criterion); end
  def mod(criterion); end
  def ne(criterion); end
  def near(criterion); end
  def near_sphere(criterion); end
  def negating; end
  def negating=(_arg0); end
  def negating?; end
  def nin(condition); end
  def none_of(*criteria); end
  def nor(*criteria); end
  def not(*criteria); end
  def not_in(condition); end
  def or(*criteria); end
  def selector; end
  def selector=(_arg0); end
  def text_search(terms, opts = T.unsafe(nil)); end
  def where(*criteria); end
  def with_size(criterion); end
  def with_type(criterion); end

  private

  def expr_query(criterion); end
  def js_query(criterion); end
  def selection(criterion = T.unsafe(nil)); end
  def typed_override(criterion, operator); end

  class << self
    def forwardables; end
  end
end

Mongoid::Criteria::Queryable::Selectable::LINE_STRING = T.let(T.unsafe(nil), String)
Mongoid::Criteria::Queryable::Selectable::POINT = T.let(T.unsafe(nil), String)
Mongoid::Criteria::Queryable::Selectable::POLYGON = T.let(T.unsafe(nil), String)

class Mongoid::Criteria::Queryable::Selector < ::Mongoid::Criteria::Queryable::Smash
  def []=(key, value); end
  def merge!(other); end
  def store(key, value); end
  def to_pipeline; end

  private

  def evolve(serializer, value); end
  def evolve_array(serializer, value); end
  def evolve_hash(serializer, value); end
  def evolve_multi(specs); end
  def evolve_range(key, serializer, value); end
  def multi_selection?(key); end
  def store_creds(name, serializer, value); end
end

class Mongoid::Criteria::Queryable::Smash < ::Hash
  def initialize(aliases = T.unsafe(nil), serializers = T.unsafe(nil), associations = T.unsafe(nil), aliased_associations = T.unsafe(nil)); end

  def [](key); end
  def __deep_copy__; end
  def aliased_associations; end
  def aliases; end
  def associations; end
  def serializers; end

  private

  def get_serializer(name); end
  def localized_key(name, serializer); end
  def storage_pair(key); end
end

module Mongoid::Criteria::Queryable::Storable
  def add_field_expression(field, value); end
  def add_logical_operator_expression(operator, op_expr); end
  def add_one_expression(field, value); end
  def add_operator_expression(operator, op_expr); end
end

module Mongoid::Criteria::Scopable
  def apply_default_scope; end
  def apply_scope(scope); end
  def remove_scoping(other); end
  def scoped(options = T.unsafe(nil)); end
  def scoped?; end
  def scoping_options; end
  def scoping_options=(options); end
  def unscoped; end
  def unscoped?; end
  def with_default_scope; end

  private

  def reject_matching(other, *methods); end
end

module Mongoid::Criteria::Translator
  extend ::Mongoid::Criteria::Translator

  def to_direction(value); end
end

module Mongoid::Deprecable
  def deprecate(target_module, *method_descriptors); end
end

class Mongoid::Deprecation < ::ActiveSupport::Deprecation
  def initialize; end

  def behavior; end
end

module Mongoid::Document
  include ::Mongoid::Touchable::InstanceMethods
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations
  include ::ActiveModel::Conversion
  include ::ActiveModel::API
  include ::ActiveModel::Model
  include ::ActiveModel::Serializers::JSON
  include ::Mongoid::Atomic
  include ::Mongoid::Changeable
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients
  include ::Mongoid::CollectionConfigurable
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly
  include ::Mongoid::Attributes
  include ::Mongoid::Fields
  include ::Mongoid::Identifiable
  include ::Mongoid::Indexable
  include ::Mongoid::Matchable
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable
  include ::Mongoid::Persistable
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections
  include ::Mongoid::Association
  include ::Mongoid::Scopable
  include ::Mongoid::SearchIndexable
  include ::Mongoid::Selectable
  include ::Mongoid::Serializable
  include ::Mongoid::Shardable
  include ::Mongoid::Cacheable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Traversable
  include ::Mongoid::Validatable::Macros
  include ::Mongoid::Validatable
  include ::ActiveModel::Validations::Callbacks
  include ::Mongoid::Interceptable
  include ::Mongoid::Copyable
  include ::Mongoid::Equality
  include ::Mongoid::Encryptable
  include ::Mongoid::Composable

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveModel::Conversion::ClassMethods
  mixes_in_class_methods ::Mongoid::Changeable::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Sessions::ClassMethods
  mixes_in_class_methods ::Mongoid::CollectionConfigurable::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::ClassMethods
  mixes_in_class_methods ::Mongoid::Fields::ClassMethods
  mixes_in_class_methods ::Mongoid::Identifiable::ClassMethods
  mixes_in_class_methods ::Mongoid::Indexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::Syncable::ClassMethods
  mixes_in_class_methods ::Mongoid::Scopable::ClassMethods
  mixes_in_class_methods ::Mongoid::SearchIndexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Shardable::ClassMethods
  mixes_in_class_methods ::Mongoid::Threaded::Lifecycle::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorRetrieval
  mixes_in_class_methods ::Mongoid::Validatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Validatable::Macros
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::Mongoid::Equality::ClassMethods
  mixes_in_class_methods ::Mongoid::Encryptable::ClassMethods
  mixes_in_class_methods ::Mongoid::Findable
  mixes_in_class_methods ::Mongoid::Document::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorAssignment

  def initialize(attrs = T.unsafe(nil), &block); end

  def __selected_fields; end
  def __selected_fields=(_arg0); end
  def _handle_callbacks_after_instantiation(execute_callbacks); end
  def as_document; end
  def becomes(klass); end
  def freeze; end
  def frozen?; end
  def hash; end
  def identity; end
  def internal_state=(state); end
  def model_name; end
  def new_record; end
  def to_key; end

  private

  def add_attributes_for_relation(name, meta); end
  def as_attributes; end
  def construct_document(attrs = T.unsafe(nil), options = T.unsafe(nil)); end
  def internal_state; end
  def logger; end
  def mark_persisted_state_for_embedded_documents(new_record); end
  def model_key; end
  def mongoid_document_check!(klass); end
  def prepare_to_process_attributes; end
  def resolve_post_construction_callbacks(execute_callbacks); end
  def update_discriminator(key_was); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def discriminator_key; end
    def discriminator_key=(value); end
    def discriminator_key?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter; end
    def param_delimiter=(value); end
    def param_delimiter?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter=(value); end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

module Mongoid::Document::ClassMethods
  def _mongoid_clear_types; end
  def _types; end
  def construct_document(attrs = T.unsafe(nil), options = T.unsafe(nil)); end
  def i18n_scope; end
  def instantiate(attrs = T.unsafe(nil), selected_fields = T.unsafe(nil), &block); end
  def instantiate_document(attrs = T.unsafe(nil), selected_fields = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def logger; end
  def with_callbacks(execute_callbacks); end
end

Mongoid::Document::ILLEGAL_KEY = T.let(T.unsafe(nil), Regexp)

module Mongoid::Encryptable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Encryptable::ClassMethods

  module GeneratedClassMethods
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
  end

  module GeneratedInstanceMethods
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
  end
end

module Mongoid::Encryptable::ClassMethods
  def encrypt_with(options = T.unsafe(nil)); end
  def encrypted?; end
  def set_key_id(key_id); end
end

module Mongoid::Equality
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Equality::ClassMethods

  def <=>(other); end
  def ==(other); end
  def eql?(other); end
end

module Mongoid::Equality::ClassMethods
  def ===(other); end
end

module Mongoid::Errors; end

class Mongoid::Errors::AmbiguousRelationship < ::Mongoid::Errors::MongoidError
  def initialize(klass, inverse, name, candidates); end
end

class Mongoid::Errors::AttributeNotLoaded < ::Mongoid::Errors::MongoidError
  def initialize(klass, name); end
end

class Mongoid::Errors::Callback < ::Mongoid::Errors::MongoidError
  def initialize(klass, method); end
end

class Mongoid::Errors::CreateCollectionFailure < ::Mongoid::Errors::MongoidError
  def initialize(collection_name, collection_options, error); end
end

class Mongoid::Errors::CriteriaArgumentRequired < ::Mongoid::Errors::MongoidError
  def initialize(query_method); end
end

class Mongoid::Errors::DeleteRestriction < ::Mongoid::Errors::MongoidError
  def initialize(document, association_name); end
end

class Mongoid::Errors::DocumentNotDestroyed < ::Mongoid::Errors::MongoidError
  def initialize(id, klass); end
end

class Mongoid::Errors::DocumentNotFound < ::Mongoid::Errors::MongoidError
  def initialize(klass, params, unmatched = T.unsafe(nil)); end

  def klass; end
  def params; end

  private

  def message_key(params, unmatched); end
  def missing(unmatched); end
  def searched(params); end
  def shard_key(unmatched); end
  def total(params); end
end

class Mongoid::Errors::EmptyConfigFile < ::Mongoid::Errors::MongoidError
  def initialize(path); end
end

class Mongoid::Errors::ImmutableAttribute < ::Mongoid::Errors::MongoidError
  def initialize(name, value); end
end

class Mongoid::Errors::InMemoryCollationNotSupported < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::InvalidAroundCallback < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::InvalidAutoEncryptionConfiguration < ::Mongoid::Errors::MongoidError
  def initialize(name, kms_provider = T.unsafe(nil)); end
end

class Mongoid::Errors::InvalidCollection < ::Mongoid::Errors::MongoidError
  def initialize(klass); end
end

class Mongoid::Errors::InvalidConfigFile < ::Mongoid::Errors::MongoidError
  def initialize(path); end
end

class Mongoid::Errors::InvalidConfigOption < ::Mongoid::Errors::MongoidError
  def initialize(name); end
end

class Mongoid::Errors::InvalidDependentStrategy < ::Mongoid::Errors::MongoidError
  def initialize(association, invalid_strategy, valid_strategies); end
end

class Mongoid::Errors::InvalidDiscriminatorKeyTarget < ::Mongoid::Errors::MongoidError
  def initialize(class_name, superclass); end
end

class Mongoid::Errors::InvalidDotDollarAssignment < ::Mongoid::Errors::MongoidError
  def initialize(klass, attr); end
end

class Mongoid::Errors::InvalidElemMatchOperator < ::Mongoid::Errors::InvalidQuery
  def initialize(operator); end

  def operator; end
end

Mongoid::Errors::InvalidElemMatchOperator::VALID_OPERATORS = T.let(T.unsafe(nil), Array)

class Mongoid::Errors::InvalidEstimatedCountCriteria < ::Mongoid::Errors::MongoidError
  def initialize(class_name); end
end

class Mongoid::Errors::InvalidEstimatedCountScoping < ::Mongoid::Errors::MongoidError
  def initialize(class_name); end
end

class Mongoid::Errors::InvalidExpressionOperator < ::Mongoid::Errors::InvalidQuery
  def initialize(operator); end

  def operator; end
end

class Mongoid::Errors::InvalidField < ::Mongoid::Errors::MongoidError
  def initialize(klass, field, name); end

  private

  def location(klass, name); end
  def origin(klass, name); end
end

class Mongoid::Errors::InvalidFieldOperator < ::Mongoid::Errors::InvalidQuery
  def initialize(operator); end

  def operator; end
end

Mongoid::Errors::InvalidFieldOperator::VALID_OPERATORS = T.let(T.unsafe(nil), Array)

class Mongoid::Errors::InvalidFieldOption < ::Mongoid::Errors::MongoidError
  def initialize(klass, name, option, valid); end
end

class Mongoid::Errors::InvalidFieldType < ::Mongoid::Errors::MongoidError
  def initialize(klass, field, type); end
end

class Mongoid::Errors::InvalidFind < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::InvalidGlobalExecutorConcurrency < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::InvalidIncludes < ::Mongoid::Errors::MongoidError
  def initialize(klass, args); end
end

class Mongoid::Errors::InvalidIndex < ::Mongoid::Errors::MongoidError
  def initialize(klass, spec, options); end
end

class Mongoid::Errors::InvalidOptions < ::Mongoid::Errors::MongoidError
  def initialize(name, invalid, valid); end
end

class Mongoid::Errors::InvalidPath < ::Mongoid::Errors::MongoidError
  def initialize(klass); end
end

class Mongoid::Errors::InvalidPersistenceOption < ::Mongoid::Errors::MongoidError
  def initialize(invalid, valid); end
end

class Mongoid::Errors::InvalidQuery < ::Mongoid::Errors::MongoidError
  def initialize(msg); end

  class << self
    def truncate_expr(expr); end
  end
end

class Mongoid::Errors::InvalidQueryExecutor < ::Mongoid::Errors::MongoidError
  def initialize(executor); end
end

class Mongoid::Errors::InvalidRelation < ::Mongoid::Errors::MongoidError
  def initialize(klass, name); end

  private

  def location(klass, name); end
  def origin(klass, name); end
end

class Mongoid::Errors::InvalidRelationOption < ::Mongoid::Errors::MongoidError
  def initialize(klass, name, option, valid_options); end
end

class Mongoid::Errors::InvalidScope < ::Mongoid::Errors::MongoidError
  def initialize(klass, value); end
end

class Mongoid::Errors::InvalidSessionNesting < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::InvalidSetPolymorphicRelation < ::Mongoid::Errors::MongoidError
  def initialize(name, klass, other_klass); end
end

class Mongoid::Errors::InvalidStorageOptions < ::Mongoid::Errors::MongoidError
  def initialize(klass, options); end
end

class Mongoid::Errors::InvalidTime < ::Mongoid::Errors::MongoidError
  def initialize(value); end
end

class Mongoid::Errors::InvalidTransactionNesting < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::InverseNotFound < ::Mongoid::Errors::MongoidError
  def initialize(base, name, klass, inverse); end
end

class Mongoid::Errors::MixedClientConfiguration < ::Mongoid::Errors::MongoidError
  def initialize(name, config); end
end

class Mongoid::Errors::MixedRelations < ::Mongoid::Errors::MongoidError
  def initialize(root_klass, embedded_klass); end
end

class Mongoid::Errors::MongoidError < ::StandardError
  def compose_message(key, attributes = T.unsafe(nil)); end
  def problem; end
  def resolution; end
  def summary; end

  private

  def translate(key, options); end
  def translate_problem(key, attributes); end
  def translate_resolution(key, attributes); end
  def translate_summary(key, attributes); end
end

Mongoid::Errors::MongoidError::BASE_KEY = T.let(T.unsafe(nil), String)

class Mongoid::Errors::NestedAttributesMetadataNotFound < ::Mongoid::Errors::MongoidError
  def initialize(klass, name); end
end

class Mongoid::Errors::NoClientConfig < ::Mongoid::Errors::MongoidError
  def initialize(name); end
end

class Mongoid::Errors::NoClientDatabase < ::Mongoid::Errors::MongoidError
  def initialize(name, config); end
end

class Mongoid::Errors::NoClientHosts < ::Mongoid::Errors::MongoidError
  def initialize(name, config); end
end

class Mongoid::Errors::NoClientsConfig < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::NoDefaultClient < ::Mongoid::Errors::MongoidError
  def initialize(keys); end
end

class Mongoid::Errors::NoEnvironment < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::NoMapReduceOutput < ::Mongoid::Errors::MongoidError
  def initialize(command); end
end

class Mongoid::Errors::NoMetadata < ::Mongoid::Errors::MongoidError
  def initialize(klass); end
end

class Mongoid::Errors::NoParent < ::Mongoid::Errors::MongoidError
  def initialize(klass); end
end

class Mongoid::Errors::ReadonlyAttribute < ::Mongoid::Errors::MongoidError
  def initialize(name, value); end
end

class Mongoid::Errors::ReadonlyDocument < ::Mongoid::Errors::MongoidError
  def initialize(klass); end
end

class Mongoid::Errors::Rollback < ::Mongoid::Errors::MongoidError; end

class Mongoid::Errors::ScopeOverwrite < ::Mongoid::Errors::MongoidError
  def initialize(model_name, scope_name); end
end

class Mongoid::Errors::SessionsNotSupported < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::TooManyNestedAttributeRecords < ::Mongoid::Errors::MongoidError
  def initialize(association, limit); end
end

class Mongoid::Errors::TransactionError < ::Mongoid::Errors::MongoidError
  def initialize(error); end
end

class Mongoid::Errors::TransactionsNotSupported < ::Mongoid::Errors::MongoidError
  def initialize; end
end

class Mongoid::Errors::UnknownAttribute < ::Mongoid::Errors::MongoidError
  def initialize(klass, name); end
end

class Mongoid::Errors::UnknownModel < ::Mongoid::Errors::MongoidError
  def initialize(klass, value); end
end

class Mongoid::Errors::UnrecognizedModelAlias < ::Mongoid::Errors::MongoidError
  def initialize(model_alias); end
end

class Mongoid::Errors::UnrecognizedResolver < ::Mongoid::Errors::MongoidError
  def initialize(resolver); end
end

class Mongoid::Errors::UnregisteredClass < ::Mongoid::Errors::MongoidError
  def initialize(klass, resolver); end
end

class Mongoid::Errors::UnsavedDocument < ::Mongoid::Errors::MongoidError
  def initialize(base, document); end
end

class Mongoid::Errors::UnsupportedJavascript < ::Mongoid::Errors::MongoidError
  def initialize(klass, javascript); end
end

class Mongoid::Errors::Validations < ::Mongoid::Errors::MongoidError
  def initialize(document); end

  def document; end
  def record; end
end

module Mongoid::Evolvable
  def __evolve_object_id__; end
end

module Mongoid::Extensions; end

module Mongoid::Extensions::Array
  def __evolve_object_id__; end
  def __find_args__(*args, **_arg1, &block); end
  def __mongoize_object_id__; end
  def __mongoize_time__; end
  def delete_one(object); end
  def mongoize; end
  def multi_arged?(*args, **_arg1, &block); end
  def resizable?; end
end

module Mongoid::Extensions::Array::ClassMethods
  def __mongoize_fk__(*args, **_arg1, &block); end
  def mongoize(object); end
  def resizable?; end
end

module Mongoid::Extensions::BigDecimal
  mixes_in_class_methods ::Mongoid::Extensions::BigDecimal::ClassMethods

  def __to_inc__(*args, **_arg1, &block); end
  def mongoize; end
  def numeric?; end

  class << self
    def included(base); end
  end
end

module Mongoid::Extensions::BigDecimal::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Binary
  def mongoize; end
end

module Mongoid::Extensions::Binary::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Date
  def __mongoize_time__; end
  def mongoize; end
end

module Mongoid::Extensions::Date::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::DateTime
  def __mongoize_time__; end
  def mongoize; end
end

module Mongoid::Extensions::DateTime::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Decimal128
  def __evolve_decimal128__; end
end

module Mongoid::Extensions::Decimal128::ClassMethods
  def evolve(object); end
end

module Mongoid::Extensions::FalseClass
  def __sortable__(*args, **_arg1, &block); end
  def is_a?(other); end
end

module Mongoid::Extensions::Float
  def __mongoize_time__; end
  def numeric?; end
end

module Mongoid::Extensions::Float::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Hash
  def __consolidate__(*args, **_arg1, &block); end
  def __evolve_object_id__; end
  def __mongoize_object_id__; end
  def delete_id(*args, **_arg1, &block); end
  def extract_id(*args, **_arg1, &block); end
  def mongoize; end
  def resizable?; end
  def to_criteria(*args, **_arg1, &block); end
end

module Mongoid::Extensions::Hash::ClassMethods
  def mongoize(object); end
  def resizable?; end
end

module Mongoid::Extensions::Integer
  def __mongoize_time__; end
  def numeric?; end
  def unconvertable_to_bson?(*args, **_arg1, &block); end
end

module Mongoid::Extensions::Integer::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Module
  def re_define_method(name, &block); end
end

module Mongoid::Extensions::NilClass
  def __setter__(*args, **_arg1, &block); end
  def collectionize; end
end

module Mongoid::Extensions::Object
  def __evolve_object_id__; end
  def __find_args__(*args, **_arg1, &block); end
  def __mongoize_object_id__; end
  def __setter__(*args, **_arg1, &block); end
  def __sortable__(*args, **_arg1, &block); end
  def __to_inc__(*args, **_arg1, &block); end
  def do_or_do_not(*args, **_arg1, &block); end
  def ivar(name); end
  def mongoize; end
  def multi_arged?(*args, **_arg1, &block); end
  def numeric?; end
  def remove_ivar(name); end
  def resizable?; end
  def substitutable; end
  def you_must(*args, **_arg1, &block); end

  class << self
    def included(base); end
  end
end

module Mongoid::Extensions::Object::ClassMethods
  def __mongoize_fk__(*args, **_arg1, &block); end
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::ObjectId
  def __evolve_object_id__; end
  def __mongoize_object_id__; end
end

module Mongoid::Extensions::ObjectId::ClassMethods
  def evolve(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Range
  mixes_in_class_methods ::Mongoid::Extensions::Range::ClassMethods

  def __find_args__(*args, **_arg1, &block); end
  def mongoize; end
  def resizable?; end

  class << self
    def included(base); end
  end
end

module Mongoid::Extensions::Range::ClassMethods
  def demongoize(object); end
  def mongoize(object); end

  private

  def __mongoize_hash__(object); end
  def __mongoize_range__(object); end
end

module Mongoid::Extensions::Regexp; end

module Mongoid::Extensions::Regexp::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Set
  def mongoize; end
  def resizable?; end
end

module Mongoid::Extensions::Set::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::String
  def __evolve_object_id__; end
  def __mongoize_object_id__; end
  def __mongoize_time__; end
  def before_type_cast?; end
  def collectionize; end
  def mongoid_id?(*args, **_arg1, &block); end
  def numeric?; end
  def reader; end
  def unconvertable_to_bson(*args, **_arg1, &block); end
  def unconvertable_to_bson=(*args, **_arg1, &block); end
  def unconvertable_to_bson?(*args, **_arg1, &block); end
  def valid_method_name?; end
  def writer?; end

  private

  def convert_to_object_id; end
end

module Mongoid::Extensions::String::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Symbol
  def mongoid_id?(*args, **_arg1, &block); end
end

module Mongoid::Extensions::Symbol::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::Time
  def __mongoize_time__; end
  def mongoize; end
end

module Mongoid::Extensions::Time::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::TimeWithZone
  def __mongoize_time__; end
  def _bson_to_i; end
  def mongoize; end
end

module Mongoid::Extensions::TimeWithZone::ClassMethods
  def demongoize(object); end
  def mongoize(object); end
end

module Mongoid::Extensions::TrueClass
  def __sortable__(*args, **_arg1, &block); end
  def is_a?(other); end
end

module Mongoid::Factory
  extend ::Mongoid::Factory

  def build(klass, attributes = T.unsafe(nil)); end
  def execute_build(klass, attributes = T.unsafe(nil), options = T.unsafe(nil)); end
  def execute_from_db(klass, attributes = T.unsafe(nil), criteria = T.unsafe(nil), selected_fields = T.unsafe(nil), execute_callbacks: T.unsafe(nil)); end
  def from_db(klass, attributes = T.unsafe(nil), criteria = T.unsafe(nil), selected_fields = T.unsafe(nil)); end
end

class Mongoid::Factory::Instantiator
  def initialize(klass, attributes, criteria, selected_fields); end

  def attributes; end
  def criteria; end
  def instance(execute_callbacks: T.unsafe(nil)); end
  def klass; end
  def selected_fields; end
  def type; end

  private

  def constantize(type); end
  def constantized_type; end
  def instantiate_with_type(execute_callbacks); end
  def instantiate_without_type(execute_callbacks); end
end

module Mongoid::Fields
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Fields::ClassMethods

  def apply_default(name); end
  def apply_defaults; end
  def apply_post_processed_defaults; end
  def apply_pre_processed_defaults; end
  def attribute_names; end
  def database_field_name(name); end
  def dot_dollar_field?(name); end
  def lazy_settable?(field, value); end
  def using_object_ids?; end
  def validate_writable_field_name!(name); end

  class << self
    def database_field_name(name, relations, aliased_fields, aliased_associations); end
    def option(option_name, &block); end
    def options; end
    def traverse_association_tree(key, fields, associations, aliased_associations); end
  end

  module GeneratedClassMethods
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
  end

  module GeneratedInstanceMethods
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
  end
end

Mongoid::Fields::Boolean = Mongoid::Boolean

module Mongoid::Fields::ClassMethods
  def attribute_names; end
  def cleanse_localized_field_names(name); end
  def database_field_name(name); end
  def extract_id_field(attributes); end
  def field(name, options = T.unsafe(nil)); end
  def id_fields; end
  def replace_field(name, type); end
  def traverse_association_tree(key, &block); end
  def using_object_ids?; end

  protected

  def add_defaults(field); end
  def add_field(name, options = T.unsafe(nil)); end
  def create_accessors(name, meth, options = T.unsafe(nil)); end
  def create_field_check(name, meth); end
  def create_field_getter(name, meth, field); end
  def create_field_getter_before_type_cast(name, meth); end
  def create_field_setter(name, meth, field); end
  def create_translations_getter(name, meth); end
  def create_translations_setter(name, meth, field); end
  def field_for(name, options); end
  def generated_methods; end
  def process_options(field); end
  def remove_defaults(name); end
  def retrieve_and_validate_type(name, type); end
  def unmapped_type(type); end
  def unsupported_type?(type); end
end

class Mongoid::Fields::Encrypted < ::Mongoid::Fields::Standard
  def initialize(name, options = T.unsafe(nil)); end

  def deterministic?; end
  def key_id; end
  def key_name_field; end
  def set_key_id(key_id); end
end

class Mongoid::Fields::ForeignKey < ::Mongoid::Fields::Standard
  def add_atomic_changes(document, name, key, mods, new_elements, old_elements); end
  def evolve(object); end
  def foreign_key?; end
  def lazy?; end
  def mongoize(object); end
  def object_id_field?; end
  def resizable?; end

  private

  def evaluate_default_proc(doc); end
  def mongoize_foreign_key(object); end
  def primary_key_field; end
  def related_id_field; end
  def serialize_default(object); end
end

Mongoid::Fields::IDS = T.let(T.unsafe(nil), Array)
Mongoid::Fields::INVALID_BSON_CLASSES = T.let(T.unsafe(nil), Array)

class Mongoid::Fields::Localized < ::Mongoid::Fields::Standard
  def demongoize(object); end
  def localize_present?; end
  def localized?; end
  def mongoize(object); end

  private

  def fallbacks?; end
  def lookup(object); end
end

class Mongoid::Fields::Standard
  extend ::Forwardable

  def initialize(name, options = T.unsafe(nil)); end

  def add_atomic_changes(document, name, key, mods, new, old); end
  def association; end
  def default_val; end
  def default_val=(_arg0); end
  def demongoize(*args, **_arg1, &block); end
  def eval_default(doc); end
  def evolve(*args, **_arg1, &block); end
  def foreign_key?; end
  def label; end
  def label=(_arg0); end
  def lazy?; end
  def localize_present?; end
  def localized?; end
  def mongoize(*args, **_arg1, &block); end
  def name; end
  def name=(_arg0); end
  def object_id_field?; end
  def options; end
  def options=(_arg0); end
  def pre_processed?; end
  def type; end

  private

  def default_name; end
  def define_default_method(object); end
  def evaluate_default_proc(doc); end
  def evaluated_default(doc); end
  def included?(fields); end
  def serialize_default(object); end
end

Mongoid::Fields::StringifiedSymbol = Mongoid::StringifiedSymbol
Mongoid::Fields::TRANSLATIONS_SFX = T.let(T.unsafe(nil), String)
Mongoid::Fields::TYPE_MAPPINGS = T.let(T.unsafe(nil), ActiveSupport::HashWithIndifferentAccess)
module Mongoid::Fields::Validators; end

module Mongoid::Fields::Validators::Macro
  extend ::Mongoid::Fields::Validators::Macro

  def validate(klass, name, options); end
  def validate_field_name(klass, name); end
  def validate_relation(klass, name, options = T.unsafe(nil)); end

  private

  def validate_name_uniqueness(klass, name, options); end
  def validate_options(klass, name, options); end
end

Mongoid::Fields::Validators::Macro::OPTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Findable
  extend ::Forwardable

  def aggregates(*args, **_arg1, &block); end
  def all(*args, **_arg1, &block); end
  def all_in(*args, **_arg1, &block); end
  def all_of(*args, **_arg1, &block); end
  def and(*args, **_arg1, &block); end
  def any_in(*args, **_arg1, &block); end
  def any_of(*args, **_arg1, &block); end
  def asc(*args, **_arg1, &block); end
  def ascending(*args, **_arg1, &block); end
  def avg(*args, **_arg1, &block); end
  def batch_size(*args, **_arg1, &block); end
  def between(*args, **_arg1, &block); end
  def collation(*args, **_arg1, &block); end
  def comment(*args, **_arg1, &block); end
  def count(*args, **_arg1, &block); end
  def create_with(*args, **_arg1, &block); end
  def cursor_type(*args, **_arg1, &block); end
  def desc(*args, **_arg1, &block); end
  def descending(*args, **_arg1, &block); end
  def distinct(*args, **_arg1, &block); end
  def each(*args, **_arg1, &block); end
  def each_with_index(*args, **_arg1, &block); end
  def elem_match(*args, **_arg1, &block); end
  def empty?; end
  def eq(*args, **_arg1, &block); end
  def estimated_count; end
  def excludes(*args, **_arg1, &block); end
  def exists(*args, **_arg1, &block); end
  def exists?(id_or_conditions = T.unsafe(nil)); end
  def extras(*args, **_arg1, &block); end
  def fifth(*args, **_arg1, &block); end
  def fifth!(*args, **_arg1, &block); end
  def find(*args, &block); end
  def find_by(attrs = T.unsafe(nil)); end
  def find_by!(attrs = T.unsafe(nil)); end
  def find_one_and_delete(*args, **_arg1, &block); end
  def find_one_and_replace(*args, **_arg1, &block); end
  def find_one_and_update(*args, **_arg1, &block); end
  def find_or_create_by(*args, **_arg1, &block); end
  def find_or_create_by!(*args, **_arg1, &block); end
  def find_or_initialize_by(*args, **_arg1, &block); end
  def first(limit = T.unsafe(nil)); end
  def first!(*args, **_arg1, &block); end
  def first_or_create(*args, **_arg1, &block); end
  def first_or_create!(*args, **_arg1, &block); end
  def first_or_initialize(*args, **_arg1, &block); end
  def for_js(*args, **_arg1, &block); end
  def fourth(*args, **_arg1, &block); end
  def fourth!(*args, **_arg1, &block); end
  def geo_spatial(*args, **_arg1, &block); end
  def gt(*args, **_arg1, &block); end
  def gte(*args, **_arg1, &block); end
  def hint(*args, **_arg1, &block); end
  def in(*args, **_arg1, &block); end
  def includes(*args, **_arg1, &block); end
  def last(limit = T.unsafe(nil)); end
  def last!(*args, **_arg1, &block); end
  def limit(*args, **_arg1, &block); end
  def lt(*args, **_arg1, &block); end
  def lte(*args, **_arg1, &block); end
  def map_reduce(*args, **_arg1, &block); end
  def max(*args, **_arg1, &block); end
  def max_distance(*args, **_arg1, &block); end
  def max_scan(*args, **_arg1, &block); end
  def max_time_ms(*args, **_arg1, &block); end
  def min(*args, **_arg1, &block); end
  def mod(*args, **_arg1, &block); end
  def ne(*args, **_arg1, &block); end
  def near(*args, **_arg1, &block); end
  def near_sphere(*args, **_arg1, &block); end
  def nin(*args, **_arg1, &block); end
  def no_timeout(*args, **_arg1, &block); end
  def none(*args, **_arg1, &block); end
  def none_of(*args, **_arg1, &block); end
  def nor(*args, **_arg1, &block); end
  def not(*args, **_arg1, &block); end
  def not_in(*args, **_arg1, &block); end
  def offset(*args, **_arg1, &block); end
  def one(limit = T.unsafe(nil)); end
  def only(*args, **_arg1, &block); end
  def or(*args, **_arg1, &block); end
  def order(*args, **_arg1, &block); end
  def order_by(*args, **_arg1, &block); end
  def pick(*args, **_arg1, &block); end
  def pluck(*args, **_arg1, &block); end
  def read(*args, **_arg1, &block); end
  def reorder(*args, **_arg1, &block); end
  def second(*args, **_arg1, &block); end
  def second!(*args, **_arg1, &block); end
  def second_to_last(*args, **_arg1, &block); end
  def second_to_last!(*args, **_arg1, &block); end
  def skip(*args, **_arg1, &block); end
  def slice(*args, **_arg1, &block); end
  def snapshot(*args, **_arg1, &block); end
  def sum(*args, **_arg1, &block); end
  def take(*args, **_arg1, &block); end
  def take!(*args, **_arg1, &block); end
  def tally(*args, **_arg1, &block); end
  def text_search(*args, **_arg1, &block); end
  def third(*args, **_arg1, &block); end
  def third!(*args, **_arg1, &block); end
  def third_to_last(*args, **_arg1, &block); end
  def third_to_last!(*args, **_arg1, &block); end
  def update(*args, **_arg1, &block); end
  def update_all(*args, **_arg1, &block); end
  def where(*args, **_arg1, &block); end
  def with_size(*args, **_arg1, &block); end
  def with_type(*args, **_arg1, &block); end
  def without(*args, **_arg1, &block); end
end

module Mongoid::GlobalDiscriminatorKeyAssignment
  def discriminator_key=(value); end
end

class Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Access
  include ::ActiveModel::Model
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::Mongoid::Atomic
  include ::Mongoid::Changeable
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods
  include ::Mongoid::Clients
  include ::Mongoid::CollectionConfigurable
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly
  include ::Mongoid::Attributes::Processing
  include ::Mongoid::Attributes
  include ::Mongoid::Fields
  include ::Mongoid::Identifiable
  include ::Mongoid::Indexable
  include ::Mongoid::Matchable
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable
  include ::Mongoid::Positional
  include ::Mongoid::Persistable::Savable
  include ::Mongoid::Persistable::Updatable
  include ::Mongoid::Persistable::Upsertable
  include ::Mongoid::Persistable
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections
  include ::Mongoid::Association::Referenced::Syncable
  include ::Mongoid::Association
  include ::Mongoid::Scopable
  include ::Mongoid::SearchIndexable
  include ::Mongoid::Selectable
  include ::Mongoid::Serializable
  include ::Mongoid::Shardable
  include ::Mongoid::Cacheable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Traversable
  include ::Mongoid::Validatable
  include ::Mongoid::Validatable::Macros
  include ::Mongoid::Interceptable
  include ::ActiveModel::Validations::Callbacks
  include ::Mongoid::Copyable
  include ::Mongoid::Equality
  include ::Mongoid::Encryptable
  include ::Mongoid::Evolvable
  include ::Mongoid::Inspectable
  include ::Mongoid::Reloadable
  include ::Mongoid::Stateful
  include ::Mongoid::Composable
  include ::Mongoid::Touchable::InstanceMethods
  include ::Mongoid::Document
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::Mongoid::Changeable::ClassMethods
  extend ::Mongoid::Clients::StorageOptions::ClassMethods
  extend ::Mongoid::Clients::Options::ClassMethods
  extend ::Mongoid::Clients::Sessions::ClassMethods
  extend ::Mongoid::CollectionConfigurable::ClassMethods
  extend ::Mongoid::Attributes::Nested::ClassMethods
  extend ::Mongoid::Attributes::Readonly::ClassMethods
  extend ::Mongoid::Attributes::ClassMethods
  extend ::Mongoid::Fields::ClassMethods
  extend ::Mongoid::Identifiable::ClassMethods
  extend ::Mongoid::Indexable::ClassMethods
  extend ::Mongoid::Persistable::Creatable::ClassMethods
  extend ::Mongoid::Persistable::Deletable::ClassMethods
  extend ::Mongoid::Persistable::Destroyable::ClassMethods
  extend ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  extend ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  extend ::Mongoid::Association::Depending::ClassMethods
  extend ::Mongoid::Association::Macros::ClassMethods
  extend ::Mongoid::Association::Reflections::ClassMethods
  extend ::Mongoid::Association::Referenced::Syncable::ClassMethods
  extend ::Mongoid::Scopable::ClassMethods
  extend ::Mongoid::SearchIndexable::ClassMethods
  extend ::Mongoid::Shardable::ClassMethods
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods
  extend ::Mongoid::Traversable::ClassMethods
  extend ::Mongoid::Traversable::DiscriminatorRetrieval
  extend ::Mongoid::Validatable::ClassMethods
  extend ::Mongoid::Validatable::Macros
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::Mongoid::Equality::ClassMethods
  extend ::Mongoid::Encryptable::ClassMethods
  extend ::Mongoid::Findable
  extend ::Mongoid::Document::ClassMethods
  extend ::Mongoid::Traversable::DiscriminatorAssignment

  def ___id_default__; end
  def __callbacks; end
  def _build_callbacks; end
  def _commit_callbacks; end
  def _create_callbacks; end
  def _declared_scopes; end
  def _declared_scopes=(_arg0); end
  def _declared_scopes?; end
  def _destroy_callbacks; end
  def _find_callbacks; end
  def _index; end
  def _index=(_arg0); end
  def _initialize_callbacks; end
  def _persist_parent_callbacks; end
  def _rollback_callbacks; end
  def _run_build_callbacks; end
  def _run_build_callbacks!(&block); end
  def _run_commit_callbacks; end
  def _run_commit_callbacks!(&block); end
  def _run_create_callbacks; end
  def _run_create_callbacks!(&block); end
  def _run_destroy_callbacks; end
  def _run_destroy_callbacks!(&block); end
  def _run_find_callbacks; end
  def _run_find_callbacks!(&block); end
  def _run_initialize_callbacks; end
  def _run_initialize_callbacks!(&block); end
  def _run_persist_parent_callbacks; end
  def _run_persist_parent_callbacks!(&block); end
  def _run_rollback_callbacks; end
  def _run_rollback_callbacks!(&block); end
  def _run_save_callbacks; end
  def _run_save_callbacks!(&block); end
  def _run_touch_callbacks; end
  def _run_touch_callbacks!(&block); end
  def _run_update_callbacks; end
  def _run_update_callbacks!(&block); end
  def _run_upsert_callbacks; end
  def _run_upsert_callbacks!(&block); end
  def _run_validate_callbacks; end
  def _run_validate_callbacks!(&block); end
  def _run_validation_callbacks; end
  def _run_validation_callbacks!(&block); end
  def _save_callbacks; end
  def _touch_callbacks; end
  def _update_callbacks; end
  def _upsert_callbacks; end
  def _validate_callbacks; end
  def _validation_callbacks; end
  def _validators; end
  def _validators?; end
  def aliased_associations; end
  def aliased_associations=(_arg0); end
  def aliased_associations?; end
  def aliased_fields; end
  def aliased_fields=(_arg0); end
  def aliased_fields?; end
  def before_callback_halted; end
  def before_callback_halted=(_arg0); end
  def cache_timestamp_format; end
  def cyclic; end
  def cyclic=(_arg0); end
  def cyclic?; end
  def default_scoping; end
  def default_scoping=(_arg0); end
  def default_scoping?; end
  def dependents; end
  def dependents=(_arg0); end
  def dependents?; end
  def dependents_owner; end
  def dependents_owner=(_arg0); end
  def dependents_owner?; end
  def embedded=(_arg0); end
  def embedded_relations; end
  def embedded_relations=(_arg0); end
  def embedded_relations?; end
  def encrypt_metadata; end
  def encrypt_metadata=(_arg0); end
  def encrypt_metadata?; end
  def fields; end
  def fields=(_arg0); end
  def fields?; end
  def id; end
  def id=(value); end
  def id?; end
  def id_before_type_cast; end
  def id_change; end
  def id_changed?(**kwargs); end
  def id_was; end
  def id_will_change!; end
  def include_root_in_json; end
  def include_root_in_json?; end
  def index_specifications; end
  def index_specifications=(val); end
  def localized_fields; end
  def localized_fields=(_arg0); end
  def localized_fields?; end
  def model_name(&_arg0); end
  def nested_attributes; end
  def nested_attributes=(_arg0); end
  def nested_attributes?; end
  def param_delimiter=(_arg0); end
  def polymorphic; end
  def polymorphic=(_arg0); end
  def polymorphic?; end
  def post_processed_defaults; end
  def post_processed_defaults=(_arg0); end
  def post_processed_defaults?; end
  def pre_processed_defaults; end
  def pre_processed_defaults=(_arg0); end
  def pre_processed_defaults?; end
  def readonly_attributes; end
  def readonly_attributes=(_arg0); end
  def readonly_attributes?; end
  def relations; end
  def relations=(_arg0); end
  def relations?; end
  def reset_id!; end
  def reset_id_to_default!; end
  def search_index_specs; end
  def search_index_specs=(val); end
  def shard_config; end
  def shard_config=(val); end
  def shard_key_fields; end
  def shard_key_fields=(val); end
  def stored_as_associations; end
  def stored_as_associations=(_arg0); end
  def stored_as_associations?; end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def _build_callbacks; end
    def _build_callbacks=(value); end
    def _commit_callbacks; end
    def _commit_callbacks=(value); end
    def _create_callbacks; end
    def _create_callbacks=(value); end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _destroy_callbacks; end
    def _destroy_callbacks=(value); end
    def _find_callbacks; end
    def _find_callbacks=(value); end
    def _initialize_callbacks; end
    def _initialize_callbacks=(value); end
    def _persist_parent_callbacks; end
    def _persist_parent_callbacks=(value); end
    def _rollback_callbacks; end
    def _rollback_callbacks=(value); end
    def _save_callbacks; end
    def _save_callbacks=(value); end
    def _touch_callbacks; end
    def _touch_callbacks=(value); end
    def _update_callbacks; end
    def _update_callbacks=(value); end
    def _upsert_callbacks; end
    def _upsert_callbacks=(value); end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validation_callbacks; end
    def _validation_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def add_discriminator_mapping(value, klass = T.unsafe(nil)); end
    def after_build(*args, **options, &block); end
    def after_create(*args, **options, &block); end
    def after_destroy(*args, **options, &block); end
    def after_find(*args, **options, &block); end
    def after_initialize(*args, **options, &block); end
    def after_persist_parent(*args, **options, &block); end
    def after_save(*args, **options, &block); end
    def after_touch(*args, **options, &block); end
    def after_update(*args, **options, &block); end
    def after_upsert(*args, **options, &block); end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def around_create(*args, **options, &block); end
    def around_destroy(*args, **options, &block); end
    def around_persist_parent(*args, **options, &block); end
    def around_save(*args, **options, &block); end
    def around_update(*args, **options, &block); end
    def around_upsert(*args, **options, &block); end
    def before_create(*args, **options, &block); end
    def before_destroy(*args, **options, &block); end
    def before_persist_parent(*args, **options, &block); end
    def before_save(*args, **options, &block); end
    def before_update(*args, **options, &block); end
    def before_upsert(*args, **options, &block); end
    def cache_timestamp_format; end
    def cache_timestamp_format=(val); end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def discriminator_key(*_arg0, **_arg1, &_arg2); end
    def discriminator_key=(value); end
    def discriminator_key?; end
    def discriminator_mapping; end
    def discriminator_mapping=(_arg0); end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def get_discriminator_mapping(value); end
    def include_root_in_json; end
    def include_root_in_json=(new_value); end
    def include_root_in_json?; end
    def index_specifications; end
    def index_specifications=(val); end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter; end
    def param_delimiter=(value); end
    def param_delimiter?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def search_index_specs; end
    def search_index_specs=(val); end
    def shard_config; end
    def shard_config=(val); end
    def shard_key_fields; end
    def shard_key_fields=(val); end
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end

    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr__declared_scopes; end
    def __class_attr__declared_scopes=(new_value); end
    def __class_attr__validators; end
    def __class_attr__validators=(new_value); end
    def __class_attr_aliased_associations; end
    def __class_attr_aliased_associations=(new_value); end
    def __class_attr_aliased_fields; end
    def __class_attr_aliased_fields=(new_value); end
    def __class_attr_cyclic; end
    def __class_attr_cyclic=(new_value); end
    def __class_attr_default_scoping; end
    def __class_attr_default_scoping=(new_value); end
    def __class_attr_dependents; end
    def __class_attr_dependents=(new_value); end
    def __class_attr_dependents_owner; end
    def __class_attr_dependents_owner=(new_value); end
    def __class_attr_discriminator_key; end
    def __class_attr_discriminator_key=(new_value); end
    def __class_attr_embedded; end
    def __class_attr_embedded=(new_value); end
    def __class_attr_embedded_relations; end
    def __class_attr_embedded_relations=(new_value); end
    def __class_attr_encrypt_metadata; end
    def __class_attr_encrypt_metadata=(new_value); end
    def __class_attr_fields; end
    def __class_attr_fields=(new_value); end
    def __class_attr_include_root_in_json; end
    def __class_attr_include_root_in_json=(new_value); end
    def __class_attr_localized_fields; end
    def __class_attr_localized_fields=(new_value); end
    def __class_attr_nested_attributes; end
    def __class_attr_nested_attributes=(new_value); end
    def __class_attr_param_delimiter; end
    def __class_attr_param_delimiter=(new_value); end
    def __class_attr_polymorphic; end
    def __class_attr_polymorphic=(new_value); end
    def __class_attr_post_processed_defaults; end
    def __class_attr_post_processed_defaults=(new_value); end
    def __class_attr_pre_processed_defaults; end
    def __class_attr_pre_processed_defaults=(new_value); end
    def __class_attr_readonly_attributes; end
    def __class_attr_readonly_attributes=(new_value); end
    def __class_attr_relations; end
    def __class_attr_relations=(new_value); end
    def __class_attr_storage_options; end
    def __class_attr_storage_options=(new_value); end
    def __class_attr_stored_as_associations; end
    def __class_attr_stored_as_associations=(new_value); end
  end
end

module Mongoid::Identifiable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Identifiable::ClassMethods
end

module Mongoid::Identifiable::ClassMethods
  def identify_as(*aliases, resolver: T.unsafe(nil)); end
end

module Mongoid::Indexable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Indexable::ClassMethods
end

module Mongoid::Indexable::ClassMethods
  def add_indexes; end
  def create_indexes; end
  def index(spec, options = T.unsafe(nil)); end
  def index_specification(index_hash, index_name = T.unsafe(nil)); end
  def remove_indexes; end

  private

  def index_keys; end
  def indexed_database_names; end
end

class Mongoid::Indexable::Specification
  def initialize(klass, key, opts = T.unsafe(nil)); end

  def ==(other); end
  def fields; end
  def key; end
  def klass; end
  def name; end
  def options; end

  private

  def normalize_aliases!(spec); end
  def normalize_options!(options); end
  def recursive_normalize_conditionals!(options); end
end

Mongoid::Indexable::Specification::MAPPINGS = T.let(T.unsafe(nil), Hash)
module Mongoid::Indexable::Validators; end

module Mongoid::Indexable::Validators::Options
  extend ::Mongoid::Indexable::Validators::Options

  def validate(klass, spec, options); end

  private

  def validate_options(klass, spec, options); end
  def validate_spec(klass, spec, options); end
end

Mongoid::Indexable::Validators::Options::VALID_OPTIONS = T.let(T.unsafe(nil), Array)
Mongoid::Indexable::Validators::Options::VALID_TYPES = T.let(T.unsafe(nil), Array)

module Mongoid::Inspectable
  def inspect; end
  def pretty_print(pretty_printer); end

  private

  def inspect_dynamic_fields; end
  def inspect_fields; end
end

module Mongoid::Interceptable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods

  def _mongoid_run_child_after_callbacks(callback_list: T.unsafe(nil)); end
  def _mongoid_run_child_before_callbacks(kind, children: T.unsafe(nil), callback_list: T.unsafe(nil)); end
  def _mongoid_run_child_callbacks(kind, children: T.unsafe(nil), &block); end
  def _mongoid_run_child_callbacks_with_around(kind, children: T.unsafe(nil), &block); end
  def _mongoid_run_child_callbacks_without_around(kind, children: T.unsafe(nil), &block); end
  def callback_executable?(kind); end
  def in_callback_state?(kind); end
  def pending_callbacks; end
  def pending_callbacks=(value); end
  def run_after_callbacks(*kinds); end
  def run_before_callbacks(*kinds); end
  def run_callbacks(kind, with_children: T.unsafe(nil), skip_if: T.unsafe(nil), &block); end
  def run_pending_callbacks; end

  private

  def before_callback_halted?; end
  def cascadable_child?(kind, child, association); end
  def cascadable_children(kind, children = T.unsafe(nil)); end
  def child_callback_type(kind, child); end
  def compile_callbacks(chain, type = T.unsafe(nil)); end
  def halted_callback_hook(filter, name = T.unsafe(nil)); end
  def run_targeted_callbacks(place, kind); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
  end
end

Mongoid::Interceptable::CALLBACKS = T.let(T.unsafe(nil), Array)

module Mongoid::Loadable
  def files_under_path(path); end
  def files_under_paths(paths); end
  def ignore_patterns; end
  def ignore_patterns=(patterns); end
  def ignored?(file_path); end
  def load_model(file); end
  def load_models(paths = T.unsafe(nil)); end
  def model_paths; end
  def model_paths=(paths); end
end

Mongoid::Loadable::DEFAULT_IGNORE_PATTERNS = T.let(T.unsafe(nil), Array)
Mongoid::Loadable::DEFAULT_MODEL_PATHS = T.let(T.unsafe(nil), Array)

module Mongoid::Loggable
  def logger; end
  def logger=(logger); end

  private

  def default_logger; end
  def rails_logger; end
end

Mongoid::MONGODB_VERSION = T.let(T.unsafe(nil), String)

module Mongoid::Matchable
  extend ::ActiveSupport::Concern

  def _matches?(selector); end
end

module Mongoid::Matcher
  private

  def extract_attribute(document, key); end
  def find_exact_key(hash, key); end

  class << self
    def extract_attribute(document, key); end
    def find_exact_key(hash, key); end
  end
end

module Mongoid::Matcher::All
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::And
  private

  def matches?(document, expr); end

  class << self
    def matches?(document, expr); end
  end
end

module Mongoid::Matcher::Bits
  def matches?(exists, value, condition); end

  private

  def operator_name; end

  class << self
    def operator_name; end
  end
end

module Mongoid::Matcher::BitsAllClear
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAllClear

  def array_matches?(value, condition); end
  def int_matches?(value, condition); end
end

module Mongoid::Matcher::BitsAllSet
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAllSet

  def array_matches?(value, condition); end
  def int_matches?(value, condition); end
end

module Mongoid::Matcher::BitsAnyClear
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAnyClear

  def array_matches?(value, condition); end
  def int_matches?(value, condition); end
end

module Mongoid::Matcher::BitsAnySet
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAnySet

  def array_matches?(value, condition); end
  def int_matches?(value, condition); end
end

module Mongoid::Matcher::ElemMatch
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::ElemMatchExpression
  private

  def matches?(document, expr); end

  class << self
    def matches?(document, expr); end
  end
end

module Mongoid::Matcher::Eq
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::EqImpl
  private

  def matches?(exists, value, condition, original_operator); end
  def time_eq?(time_a, time_b); end
  def time_rounded_to_millis(time); end

  class << self
    def matches?(exists, value, condition, original_operator); end
    def time_eq?(time_a, time_b); end
    def time_rounded_to_millis(time); end
  end
end

module Mongoid::Matcher::EqImplWithRegexp
  private

  def matches?(original_operator, value, condition); end

  class << self
    def matches?(original_operator, value, condition); end
  end
end

module Mongoid::Matcher::Exists
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Expression
  private

  def matches?(document, expr); end

  class << self
    def matches?(document, expr); end
  end
end

module Mongoid::Matcher::ExpressionOperator
  private

  def get(op); end

  class << self
    def get(op); end
  end
end

Mongoid::Matcher::ExpressionOperator::MAP = T.let(T.unsafe(nil), Hash)

module Mongoid::Matcher::FieldExpression
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::FieldOperator
  private

  def apply_array_field_operator(exists, value, condition); end
  def apply_comparison_operator(operator, left, right); end
  def get(op); end

  class << self
    def apply_array_field_operator(exists, value, condition); end
    def apply_comparison_operator(operator, left, right); end
    def get(op); end
  end
end

Mongoid::Matcher::FieldOperator::MAP = T.let(T.unsafe(nil), Hash)

module Mongoid::Matcher::Gt
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Gte
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::In
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Lt
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Lte
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Mod
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Ne
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Nin
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Nor
  private

  def matches?(document, expr); end

  class << self
    def matches?(document, expr); end
  end
end

module Mongoid::Matcher::Not
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Or
  private

  def matches?(document, expr); end

  class << self
    def matches?(document, expr); end
  end
end

module Mongoid::Matcher::Regex
  private

  def matches?(exists, value, condition); end
  def matches_array_or_scalar?(value, condition); end

  class << self
    def matches?(exists, value, condition); end
    def matches_array_or_scalar?(value, condition); end
  end
end

module Mongoid::Matcher::Size
  private

  def matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
  end
end

module Mongoid::Matcher::Type
  private

  def matches?(exists, value, condition); end
  def one_matches?(exists, value, condition); end

  class << self
    def matches?(exists, value, condition); end
    def one_matches?(exists, value, condition); end
  end
end

class Mongoid::ModelResolver
  include ::Mongoid::ModelResolver::Interface

  def initialize; end

  def register(klass, *keys); end

  class << self
    def instance; end
    def register(*args, **_arg1, &block); end
    def register_resolver(resolver, name); end
    def resolver(identifier_or_object = T.unsafe(nil)); end
    def resolvers; end
  end
end

Mongoid::ModelResolver::INSTANCE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

module Mongoid::ModelResolver::Interface
  extend ::ActiveSupport::Concern

  def default_key_for(record); end
  def keys_for(record); end
  def model_for(key); end
end

Mongoid::PLATFORM_DETAILS = T.let(T.unsafe(nil), String)

module Mongoid::Persistable
  include ::Mongoid::Positional
  include ::Mongoid::Persistable::Savable
  include ::Mongoid::Persistable::Updatable
  include ::Mongoid::Persistable::Upsertable
  extend ::ActiveSupport::Concern
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable

  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods

  def atomically(join_context: T.unsafe(nil)); end
  def fail_due_to_callback!(method); end
  def fail_due_to_validation!; end

  private

  def _mongoid_atomic_context_changed_fields; end
  def _mongoid_pop_atomic_context; end
  def _mongoid_push_atomic_context; end
  def _mongoid_remove_atomic_context_changes; end
  def _mongoid_reset_atomic_context_changes!; end
  def executing_atomically?; end
  def persist_atomic_operations(operations); end
  def persist_or_delay_atomic_operation(operation); end
  def post_process_persist(result, options = T.unsafe(nil)); end
  def prepare_atomic_operation; end
  def process_atomic_operations(operations); end
end

module Mongoid::Persistable::Creatable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods

  def insert(options = T.unsafe(nil)); end

  private

  def atomic_inserts; end
  def insert_as_embedded; end
  def insert_as_root; end
  def post_process_insert; end
  def prepare_insert(options = T.unsafe(nil)); end
end

module Mongoid::Persistable::Creatable::ClassMethods
  def create(attributes = T.unsafe(nil), &block); end
  def create!(attributes = T.unsafe(nil), &block); end
end

module Mongoid::Persistable::Deletable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods

  def delete(options = T.unsafe(nil)); end
  def remove(options = T.unsafe(nil)); end

  private

  def atomic_deletes; end
  def delete_as_embedded(options = T.unsafe(nil)); end
  def delete_as_root; end
  def notifying_parent?(options = T.unsafe(nil)); end
  def prepare_delete; end
end

module Mongoid::Persistable::Deletable::ClassMethods
  def delete_all(conditions = T.unsafe(nil)); end
end

module Mongoid::Persistable::Destroyable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods

  def destroy(options = T.unsafe(nil)); end
  def destroy!(options = T.unsafe(nil)); end
end

module Mongoid::Persistable::Destroyable::ClassMethods
  def destroy_all(conditions = T.unsafe(nil)); end
end

module Mongoid::Persistable::Incrementable
  extend ::ActiveSupport::Concern

  def inc(increments); end
end

Mongoid::Persistable::LIST_OPERATIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Persistable::Logical
  extend ::ActiveSupport::Concern

  def bit(operations); end
end

module Mongoid::Persistable::Maxable
  extend ::ActiveSupport::Concern

  def clamp_lower_bound(fields); end
  def set_max(fields); end
end

module Mongoid::Persistable::Minable
  extend ::ActiveSupport::Concern

  def clamp_upper_bound(fields); end
  def set_min(fields); end
end

module Mongoid::Persistable::Multipliable
  extend ::ActiveSupport::Concern

  def mul(factors); end
end

module Mongoid::Persistable::Poppable
  extend ::ActiveSupport::Concern

  def pop(pops); end
end

module Mongoid::Persistable::Pullable
  extend ::ActiveSupport::Concern

  def pull(pulls); end
  def pull_all(pulls); end
end

module Mongoid::Persistable::Pushable
  extend ::ActiveSupport::Concern

  def add_to_set(adds); end
  def push(pushes); end
end

module Mongoid::Persistable::Renamable
  extend ::ActiveSupport::Concern

  def rename(renames); end
end

module Mongoid::Persistable::Savable
  def save(options = T.unsafe(nil)); end
  def save!(options = T.unsafe(nil)); end
end

module Mongoid::Persistable::Settable
  extend ::ActiveSupport::Concern

  def set(setters); end
end

module Mongoid::Persistable::Unsettable
  extend ::ActiveSupport::Concern

  def unset(*fields); end
end

module Mongoid::Persistable::Updatable
  def update(attributes = T.unsafe(nil)); end
  def update!(attributes = T.unsafe(nil)); end
  def update_attribute(name, value); end
  def update_attributes(attributes = T.unsafe(nil)); end
  def update_attributes!(attributes = T.unsafe(nil)); end

  private

  def enforce_immutability_of_id_field!; end
  def init_atomic_updates; end
  def prepare_update(options = T.unsafe(nil)); end
  def process_touch_option(options, children); end
  def run_all_callbacks_for_update(update_children); end
  def update_document(options = T.unsafe(nil)); end
end

module Mongoid::Persistable::Upsertable
  def upsert(options = T.unsafe(nil)); end

  private

  def prepare_upsert(options = T.unsafe(nil)); end
end

class Mongoid::PersistenceContext
  extend ::Forwardable

  def initialize(object, opts = T.unsafe(nil)); end

  def ==(other); end
  def client; end
  def client_name; end
  def cluster(*args, **_arg1, &block); end
  def collection(parent = T.unsafe(nil)); end
  def collection_name; end
  def database_name; end
  def for_child(document); end
  def options; end
  def requested_storage_options; end
  def reusable_client?; end
  def storage_options(*args, **_arg1, &block); end

  private

  def __evaluate__(name); end
  def client_options; end
  def database_name_option; end
  def set_options!(opts); end

  class << self
    def clear(object, cluster = T.unsafe(nil), original_context = T.unsafe(nil)); end
    def get(object); end
    def set(object, options_or_context); end

    private

    def context_store; end
    def get_context(object); end
    def store_context(object, context); end
  end
end

Mongoid::PersistenceContext::EXTRA_OPTIONS = T.let(T.unsafe(nil), Array)
Mongoid::PersistenceContext::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

module Mongoid::Pluckable
  extend ::ActiveSupport::Concern

  private

  def descend(part, current, method_name, field, part_count, is_translation); end
  def extract_value(attrs, field_name, document_class); end
  def fetch_and_demongoize(obj, key, field); end
  def pluck_from_documents(documents, field_names, document_class: T.unsafe(nil)); end
  def prepare_pluck(field_names, document_class: T.unsafe(nil), prepare_projection: T.unsafe(nil)); end
end

module Mongoid::Positional
  def positionally(selector, operations, processed = T.unsafe(nil)); end

  private

  def process_operations(keys, operations, processed); end
  def process_updates(keys, update, updates = T.unsafe(nil)); end
  def replace_index(keys, position); end
end

class Mongoid::RawValue
  def initialize(raw_value); end

  def inspect; end
  def raw_value; end
end

module Mongoid::Reloadable
  def reload; end

  private

  def _reload; end
  def check_for_deleted_document!(attributes); end
  def reload_embedded_document; end
  def reload_root_document; end
  def reset_object!(attributes); end
end

module Mongoid::Scopable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Scopable::ClassMethods

  private

  def apply_default_scoping; end

  module GeneratedClassMethods
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
  end

  module GeneratedInstanceMethods
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
  end
end

module Mongoid::Scopable::ClassMethods
  def criteria; end
  def default_scopable?; end
  def default_scope(value = T.unsafe(nil)); end
  def queryable; end
  def scope(name, value, &block); end
  def scoped(options = T.unsafe(nil)); end
  def scopes; end
  def unscoped; end
  def with_default_scope; end
  def with_scope(criteria); end
  def without_default_scope; end

  private

  def check_scope_name(name); end
  def check_scope_validity(value); end
  def define_scope_method(name); end
  def process_default_scope(value); end
end

module Mongoid::SearchIndexable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::SearchIndexable::ClassMethods
end

module Mongoid::SearchIndexable::ClassMethods
  def create_search_indexes; end
  def remove_search_index(name: T.unsafe(nil), id: T.unsafe(nil)); end
  def remove_search_indexes; end
  def search_index(name_or_defn, defn = T.unsafe(nil)); end
  def search_indexes(options = T.unsafe(nil)); end
  def wait_for_search_indexes(names, interval: T.unsafe(nil)); end

  private

  def get_indexes(names); end
end

class Mongoid::SearchIndexable::Status
  def initialize(indexes); end

  def indexes; end
  def pending; end
  def queryable; end
  def ready; end
  def ready?; end
end

module Mongoid::Selectable
  extend ::ActiveSupport::Concern

  def atomic_selector; end

  private

  def embedded_atomic_selector; end
  def root_atomic_selector_in_db; end
end

module Mongoid::Serializable
  extend ::ActiveSupport::Concern

  def serializable_hash(options = T.unsafe(nil)); end

  private

  def field_names(options); end
  def relation_names(inclusions); end
  def relation_options(inclusions, options, name); end
  def serialize_attribute(attrs, name, names, options); end
  def serialize_relations(attributes = T.unsafe(nil), options = T.unsafe(nil)); end
end

module Mongoid::Shardable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Shardable::ClassMethods

  def shard_key_field_value(field, prefer_persisted:); end
  def shard_key_fields; end
  def shard_key_selector(prefer_persisted: T.unsafe(nil)); end
  def shard_key_selector_in_db; end
end

module Mongoid::Shardable::ClassMethods
  def shard_key(*args); end
end

module Mongoid::Stateful
  def _destroy; end
  def destroyed=(_arg0); end
  def destroyed?; end
  def flagged_for_destroy=(_arg0); end
  def flagged_for_destroy?; end
  def marked_for_destruction?; end
  def new_record=(new_value); end
  def new_record?; end
  def persisted?; end
  def previously_new_record=(_arg0); end
  def previously_new_record?; end
  def previously_persisted?; end
  def pushable?; end
  def readonly!; end
  def readonly?; end
  def settable?; end
  def updateable?; end

  private

  def reset_readonly; end
end

class Mongoid::StringifiedSymbol
  class << self
    def demongoize(object); end
    def evolve(object); end
    def mongoize(object); end
  end
end

module Mongoid::Tasks; end

module Mongoid::Tasks::Database
  extend ::Mongoid::Tasks::Database

  def create_collections(models = T.unsafe(nil), force: T.unsafe(nil)); end
  def create_indexes(models = T.unsafe(nil)); end
  def create_search_indexes(models = T.unsafe(nil), wait: T.unsafe(nil)); end
  def remove_indexes(models = T.unsafe(nil)); end
  def remove_search_indexes(models = T.unsafe(nil)); end
  def remove_undefined_indexes(models = T.unsafe(nil)); end
  def shard_collections(models = T.unsafe(nil)); end
  def undefined_indexes(models = T.unsafe(nil)); end

  private

  def logger; end
  def wait_for_search_indexes(models); end
end

module Mongoid::Tasks::Encryption
  extend ::Mongoid::Tasks::Encryption

  def create_data_key(client_name: T.unsafe(nil), kms_provider_name: T.unsafe(nil), key_alt_name: T.unsafe(nil)); end

  private

  def get_kms_provider_name(kms_provider_name, kms_providers); end
  def prepare_arguments(kms_provider_name, client_name); end
end

module Mongoid::Threaded
  extend ::Mongoid::Threaded

  def add_modified_document(session, document); end
  def autosaved?(document); end
  def autosaves; end
  def autosaves_for(klass); end
  def begin_autosave(document); end
  def begin_execution(name); end
  def begin_validate(document); end
  def begin_without_default_scope(klass); end
  def clear_modified_documents(session); end
  def clear_session(client: T.unsafe(nil)); end
  def client_override; end
  def client_override=(name); end
  def current_scope(klass = T.unsafe(nil)); end
  def current_scope=(scope); end
  def database_override; end
  def database_override=(name); end
  def delete(key); end
  def execute_callbacks=(flag); end
  def execute_callbacks?; end
  def executing?(name); end
  def exit_autosave(document); end
  def exit_execution(name); end
  def exit_validate(document); end
  def exit_without_default_scope(klass); end
  def get(key, &default); end
  def get_session(client: T.unsafe(nil)); end
  def has?(key); end
  def modified_documents; end
  def sessions; end
  def set(key, value); end
  def set_current_scope(scope, klass); end
  def set_session(session, client: T.unsafe(nil)); end
  def stack(name); end
  def validated?(document); end
  def validations; end
  def validations_for(klass); end
  def without_default_scope?(klass); end

  private

  def unset_current_scope(klass); end
end

Mongoid::Threaded::ASSIGN = T.let(T.unsafe(nil), String)
Mongoid::Threaded::AUTOSAVES_KEY = T.let(T.unsafe(nil), String)
Mongoid::Threaded::BIND = T.let(T.unsafe(nil), String)
Mongoid::Threaded::BUILD = T.let(T.unsafe(nil), String)
Mongoid::Threaded::CLIENTS_KEY = T.let(T.unsafe(nil), String)
Mongoid::Threaded::CLIENT_OVERRIDE_KEY = T.let(T.unsafe(nil), String)
Mongoid::Threaded::CREATE = T.let(T.unsafe(nil), String)
Mongoid::Threaded::CURRENT_SCOPE_KEY = T.let(T.unsafe(nil), String)
Mongoid::Threaded::DATABASE_OVERRIDE_KEY = T.let(T.unsafe(nil), String)
Mongoid::Threaded::EXECUTE_CALLBACKS = T.let(T.unsafe(nil), String)
Mongoid::Threaded::LOAD = T.let(T.unsafe(nil), String)

module Mongoid::Threaded::Lifecycle
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Threaded::Lifecycle::ClassMethods

  private

  def _assigning; end
  def _assigning?; end
  def _binding; end
  def _binding?; end
  def _building; end
  def _building?; end
  def _creating?; end
  def _loading; end
  def _loading?; end
end

module Mongoid::Threaded::Lifecycle::ClassMethods
  def _creating; end
end

Mongoid::Threaded::MODIFIED_DOCUMENTS_KEY = T.let(T.unsafe(nil), String)
Mongoid::Threaded::SESSIONS_KEY = T.let(T.unsafe(nil), String)
Mongoid::Threaded::STACK_KEYS = T.let(T.unsafe(nil), Hash)
Mongoid::Threaded::VALIDATIONS_KEY = T.let(T.unsafe(nil), String)

module Mongoid::Timestamps
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Created
  include ::Mongoid::Timestamps::Updated

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods
end

module Mongoid::Timestamps::Created
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods

  def able_to_set_created_at?; end
  def set_created_at; end
end

module Mongoid::Timestamps::Created::Short
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Created
end

module Mongoid::Timestamps::Short
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Created
  include ::Mongoid::Timestamps::Updated

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods
end

module Mongoid::Timestamps::Timeless
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods

  def clear_timeless_option; end
  def timeless; end
  def timeless?; end

  class << self
    def [](*args, **_arg1, &block); end
    def []=(*args, **_arg1, &block); end
    def timeless_table; end
  end
end

module Mongoid::Timestamps::Timeless::ClassMethods
  def clear_timeless_option; end
  def clear_timeless_option_on_update; end
  def set_timeless_counter(counter); end
  def timeless; end
  def timeless?; end
end

module Mongoid::Timestamps::Updated
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods

  def able_to_set_updated_at?; end
  def set_updated_at; end
end

module Mongoid::Timestamps::Updated::Short
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Updated
end

module Mongoid::Touchable
  extend ::Mongoid::Touchable

  def define_touchable!(association); end
  def suppress_touch_callbacks(name); end
  def touch_callbacks_suppressed?(name); end

  private

  def define_relation_touch_method(name, association); end
  def touch_callback_statuses; end
end

module Mongoid::Touchable::InstanceMethods
  def _clear_touch_updates(field = T.unsafe(nil)); end
  def _gather_touch_updates(now, field = T.unsafe(nil)); end
  def _run_touch_callbacks_from_root; end
  def _touchable_parent?; end
  def suppress_touch_callbacks; end
  def touch(field = T.unsafe(nil)); end
  def touch_callbacks_suppressed?; end

  private

  def _extract_touches_from_atomic_sets(field = T.unsafe(nil)); end
end

Mongoid::Touchable::SUPPRESS_TOUCH_CALLBACKS_KEY = T.let(T.unsafe(nil), String)

module Mongoid::Traversable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorRetrieval
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorAssignment

  def _children(reset: T.unsafe(nil)); end
  def _descendants(reset: T.unsafe(nil)); end
  def _parent; end
  def _parent=(document); end
  def _reset_memoized_descendants!; end
  def _root; end
  def _root?; end
  def collect_children; end
  def collect_descendants; end
  def flag_descendants_persisted; end
  def hereditary?; end
  def parentize(document); end
  def remove_child(child); end
  def reset_persisted_descendants; end

  class << self
    def __redefine(owner, name, value); end
  end

  module GeneratedClassMethods
    def discriminator_key; end
    def discriminator_key=(value); end
    def discriminator_key?; end
  end

  module GeneratedInstanceMethods; end
end

module Mongoid::Traversable::ClassMethods
  def hereditary?; end
  def inherited(subclass); end
  def root_class; end
end

module Mongoid::Traversable::DiscriminatorAssignment
  def discriminator_key=(value); end
  def discriminator_value=(value); end
end

module Mongoid::Traversable::DiscriminatorRetrieval
  def discriminator_value; end
end

module Mongoid::Utils
  extend ::Mongoid::Utils

  def monotonic_time; end
  def placeholder?(value); end
  def truthy_string?(string); end
end

Mongoid::Utils::PLACEHOLDER = T.let(T.unsafe(nil), Object)
Mongoid::VERSION = T.let(T.unsafe(nil), String)

module Mongoid::Validatable
  extend ::ActiveSupport::Concern
  include ::Mongoid::Validatable::Macros

  mixes_in_class_methods ::Mongoid::Validatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Validatable::Macros

  def begin_validate; end
  def exit_validate; end
  def performing_validations?(options = T.unsafe(nil)); end
  def read_attribute_for_validation(attr); end
  def valid?(context = T.unsafe(nil)); end
  def validated?; end
  def validating; end
  def validating_with_query?; end
end

class Mongoid::Validatable::AssociatedValidator < ::ActiveModel::Validator
  def attributes; end
  def validate(document); end

  private

  def get_target_documents(target); end
  def get_target_documents_for_has_many(target); end
  def get_target_documents_for_other(target); end
  def validate_association(document, attribute); end
end

module Mongoid::Validatable::ClassMethods
  def validates_relation(association); end
  def validates_with(*args, &block); end
  def validating_with_query?; end
end

class Mongoid::Validatable::FormatValidator < ::ActiveModel::Validations::FormatValidator
  include ::Mongoid::Validatable::Localizable
end

class Mongoid::Validatable::LengthValidator < ::ActiveModel::Validations::LengthValidator
  include ::Mongoid::Validatable::Localizable
end

module Mongoid::Validatable::Localizable
  def validate_each(document, attribute, value); end
end

module Mongoid::Validatable::Macros
  extend ::ActiveSupport::Concern

  def validates_associated(*args); end
  def validates_format_of(*args); end
  def validates_length_of(*args); end
  def validates_numericality_of(*args); end
  def validates_presence_of(*args); end
  def validates_uniqueness_of(*args); end
end

class Mongoid::Validatable::NumericalityValidator < ::ActiveModel::Validations::NumericalityValidator
  private

  def prepare_value_for_validation(value, record, attr_name); end
end

class Mongoid::Validatable::PresenceValidator < ::ActiveModel::EachValidator
  def validate_each(document, attribute, value); end

  private

  def not_present?(value); end
  def relation_or_fk_missing?(doc, attr, value); end
end

module Mongoid::Validatable::Queryable
  def with_query(document); end
end

class Mongoid::Validatable::UniquenessValidator < ::ActiveModel::EachValidator
  include ::Mongoid::Validatable::Queryable

  def validate_each(document, attribute, value); end

  private

  def add_error(document, attribute, value); end
  def case_sensitive?; end
  def create_criteria(base, document, attribute, value); end
  def criterion(document, attribute, value); end
  def filter(value); end
  def localized?(document, attribute); end
  def scope(criteria, document, _attribute); end
  def scope_value_changed?(document); end
  def skip_validation?(document); end
  def to_validate(document, attribute, value); end
  def validate_embedded(document, attribute, value); end
  def validate_root(document, attribute, value); end
  def validation_required?(document, attribute); end
end

module Mongoid::Warnings
  class << self
    def warn_geo_haystack_deprecated; end
    def warn_legacy_readonly; end
    def warn_mutable_ids; end
    def warn_symbol_type_deprecated; end
    def warning(id, message); end
  end
end

class NilClass
  include ::BSON::Specialized
  include ::Mongoid::Extensions::NilClass
  include ::Mongoid::Criteria::Queryable::Extensions::NilClass
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::Mongoid::Extensions::Object
  include ::Mongoid::Criteria::Queryable::Extensions::Object
  extend ::Mongoid::Extensions::Object::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
end

class Range
  include ::Enumerable
  include ::Mongoid::Extensions::Range
  include ::Mongoid::Criteria::Queryable::Extensions::Range
  extend ::Mongoid::Extensions::Range::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Range::ClassMethods
end

class Regexp
  include ::BSON::JSON
  include ::Mongoid::Criteria::Queryable::Extensions::Regexp
  extend ::Mongoid::Extensions::Regexp::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Regexp::ClassMethods
end

class Set
  include ::Enumerable
  include ::Mongoid::Extensions::Set
  extend ::Mongoid::Extensions::Set::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
end

class String
  include ::Comparable
  include ::Mongoid::Extensions::String
  include ::Mongoid::Criteria::Queryable::Extensions::String
  extend ::Mongoid::Extensions::String::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::String::ClassMethods
end

class Symbol
  include ::Comparable
  include ::Mongoid::Extensions::Symbol
  include ::Mongoid::Criteria::Queryable::Extensions::Symbol
  extend ::Mongoid::Extensions::Symbol::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Symbol::ClassMethods
end

class Time
  include ::Comparable
  include ::Mongoid::Extensions::Time
  include ::Mongoid::Criteria::Queryable::Extensions::Time
  extend ::Mongoid::Extensions::Time::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Time::ClassMethods
end

class TrueClass
  include ::Mongoid::Extensions::TrueClass
end
