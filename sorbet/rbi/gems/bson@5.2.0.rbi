# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `bson` gem.
# Please instead update this file by running `bin/tapioca gem bson`.


class ActiveSupport::TimeWithZone
  include ::BSON::TimeWithZone
end

class Array
  include ::Enumerable
  include ::BSON::Array
  extend ::BSON::Array::ClassMethods
end

module BSON
  class << self
    def ObjectId(string); end
  end
end

module BSON::Array
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_bson_normalized_value; end
  def to_bson_object_id; end
end

BSON::Array::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Array::ClassMethods
  def from_bson(buffer, **options); end

  private

  def parse_array_elements_from_buffer(array, buffer, **options); end
  def parse_array_from_buffer(buffer, **options); end
end

BSON::BINARY = T.let(T.unsafe(nil), String)

module BSON::BigDecimal
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
end

BSON::BigDecimal::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::BigDecimal::ClassMethods
  def from_bson(buffer, **options); end
end

class BSON::Binary
  include ::BSON::JSON
  include ::Comparable

  def initialize(data = T.unsafe(nil), type = T.unsafe(nil)); end

  def <=>(other); end
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*_args); end
  def as_vector; end
  def bson_type; end
  def data; end
  def eql?(other); end
  def hash; end
  def init_with(coder); end
  def inspect; end
  def raw_type; end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_uuid(representation = T.unsafe(nil)); end
  def type; end

  private

  def from_uuid_old_to_csharp_legacy_uuid(hex); end
  def from_uuid_old_to_java_legacy_uuid(hex); end
  def from_uuid_old_to_python_legacy_uuid(hex); end
  def from_uuid_old_to_standard_uuid(_hex); end
  def from_uuid_old_to_uuid(representation); end
  def from_uuid_to_uuid(representation); end
  def initialize_instance(data, type); end
  def validate_integer_type!(type); end
  def validate_symbol_type!(type); end
  def validate_type!(type); end

  class << self
    def from_bson(buffer, **_options); end
    def from_csharp_legacy_uuid(uuid_binary); end
    def from_java_legacy_uuid(uuid_binary); end
    def from_python_legacy_uuid(uuid_binary); end
    def from_standard_uuid(uuid_binary); end
    def from_uuid(uuid, representation = T.unsafe(nil)); end
    def from_vector(vector, dtype = T.unsafe(nil), padding = T.unsafe(nil), validate_vector_data: T.unsafe(nil)); end

    private

    def extract_args_for_vector(vector, dtype, padding); end
    def validate_args_for_vector!(data, dtype, padding); end
    def validate_vector_data!(data, dtype); end
  end
end

BSON::Binary::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::Binary::SUBTYPES = T.let(T.unsafe(nil), Hash)
BSON::Binary::TYPES = T.let(T.unsafe(nil), Hash)
BSON::Binary::USER_SUBTYPE = T.let(T.unsafe(nil), Integer)
BSON::Binary::VECTOR_DATA_TYPES = T.let(T.unsafe(nil), Hash)
BSON::Binary::VECTOR_DATA_TYPES_INVERSE = T.let(T.unsafe(nil), Hash)

class BSON::Boolean
  def bson_type; end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Boolean::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::ByteBuffer
  def initialize(*_arg0); end

  def get_array(*_arg0); end
  def get_byte; end
  def get_bytes(_arg0); end
  def get_cstring; end
  def get_decimal128_bytes; end
  def get_double; end
  def get_hash(*_arg0); end
  def get_int32; end
  def get_int64; end
  def get_string; end
  def get_uint32; end
  def length; end
  def put_array(_arg0); end
  def put_byte(_arg0); end
  def put_bytes(_arg0); end
  def put_cstring(_arg0); end
  def put_decimal128(_arg0, _arg1); end
  def put_double(_arg0); end
  def put_hash(_arg0); end
  def put_int32(_arg0); end
  def put_int64(_arg0); end
  def put_string(_arg0); end
  def put_symbol(_arg0); end
  def put_uint32(_arg0); end
  def read_position; end
  def replace_int32(_arg0, _arg1); end
  def rewind!; end
  def to_s; end
  def write_position; end
end

class BSON::Code
  include ::BSON::JSON

  def initialize(javascript = T.unsafe(nil)); end

  def ==(other); end
  def as_extended_json(**_options); end
  def as_json(*_args); end
  def bson_type; end
  def javascript; end
  def to_bson(buffer = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Code::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::CodeWithScope
  include ::BSON::JSON

  def initialize(javascript = T.unsafe(nil), scope = T.unsafe(nil)); end

  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*_args); end
  def bson_type; end
  def javascript; end
  def scope; end
  def to_bson(buffer = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::CodeWithScope::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Config
  extend ::BSON::Config
end

BSON::DATE_REFERENCE = T.let(T.unsafe(nil), Integer)

class BSON::DBRef < ::BSON::Document
  include ::BSON::JSON

  def initialize(hash_or_collection, id = T.unsafe(nil), database = T.unsafe(nil)); end

  def as_json(*args); end
  def collection; end
  def database; end
  def id; end
  def to_bson(buffer = T.unsafe(nil)); end

  private

  def reorder_fields(hash); end
end

BSON::DBRef::COLLECTION = T.let(T.unsafe(nil), String)
BSON::DBRef::DATABASE = T.let(T.unsafe(nil), String)
BSON::DBRef::ID = T.let(T.unsafe(nil), String)

module BSON::Date
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
end

module BSON::DateTime
  def to_bson(buffer = T.unsafe(nil)); end
end

class BSON::DbPointer
  include ::BSON::JSON

  def initialize(ref, id); end

  def ==(other); end
  def as_extended_json(**_options); end
  def as_json(*_args); end
  def bson_type; end
  def id; end
  def ref; end
  def to_bson(buffer = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::DbPointer::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::Decimal128
  include ::BSON::JSON
  include ::Comparable

  def initialize(object); end

  def <=>(other); end
  def ==(other); end
  def as_extended_json(**_options); end
  def as_json(*args); end
  def bson_type; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_big_decimal; end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_d; end
  def to_s; end
  def to_str; end

  private

  def set_bits(low, high); end

  class << self
    def from_bits(low, high); end
    def from_bson(buffer, **options); end
    def from_string(string); end
  end
end

BSON::Decimal128::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Decimal128::Builder
  extend ::BSON::Decimal128::Builder

  def parts_to_bits(significand, exponent, is_negative); end

  private

  def valid_exponent?(exponent); end
  def valid_significand?(significand); end
  def validate_range!(exponent, significand); end
end

class BSON::Decimal128::Builder::FromBigDecimal
  def initialize(big_decimal); end

  def bits; end

  private

  def special?; end
  def to_bits; end
  def to_special_bits; end
end

class BSON::Decimal128::Builder::FromString
  def initialize(string); end

  def bits; end

  private

  def clamp(exponent, significand); end
  def round_exact(exponent, significand); end
  def special?; end
  def to_bits; end
  def to_special_bits; end
  def validate_format!; end
end

BSON::Decimal128::Builder::FromString::INFINITY_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::NAN_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::SCIENTIFIC_EXPONENT_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::SIGNIFICAND_WITH_LEADING_ZEROS_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::SIGN_AND_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::TRAILING_ZEROS_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::VALID_DECIMAL128_STRING_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::INFINITY_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::NAN_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::SIGN_BIT_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::SNAN_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::TWO_HIGHEST_BITS_SET = T.let(T.unsafe(nil), Integer)

class BSON::Decimal128::Builder::ToString
  def initialize(decimal128); end

  def string; end

  private

  def bits_to_significand; end
  def create_string; end
  def exponent; end
  def high_bits; end
  def infinity?; end
  def low_bits; end
  def nan?; end
  def negative?; end
  def scientific_exponent; end
  def significand; end
  def two_highest_bits_set?; end
  def use_scientific_notation?; end
end

BSON::Decimal128::Builder::ToString::INFINITY_STRING = T.let(T.unsafe(nil), String)
BSON::Decimal128::Builder::ToString::NAN_STRING = T.let(T.unsafe(nil), String)
BSON::Decimal128::EXPONENT_OFFSET = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::EXTENDED_JSON_KEY = T.let(T.unsafe(nil), String)
BSON::Decimal128::MAX_DIGITS_OF_PRECISION = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::MAX_EXPONENT = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::MIN_EXPONENT = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::NATIVE_TYPE = BigDecimal

class BSON::Document < ::Hash
  def initialize(elements = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def deep_symbolize_keys!; end
  def delete(key, &block); end
  def dig(*keys); end
  def except(*keys); end
  def fetch(key, *args, &block); end
  def has_key?(key); end
  def has_value?(value); end
  def include?(key); end
  def key?(key); end
  def member?(key); end
  def merge(other, &block); end
  def merge!(other); end
  def slice(*keys); end
  def symbolize_keys!; end
  def to_bson_normalized_value; end
  def update(other); end
  def value(value); end

  private

  def convert_key(key); end
  def convert_value(value); end
end

module BSON::Environment
  extend ::BSON::Environment

  def jruby?; end
  def ruby_1_9?; end
end

class BSON::Error < ::StandardError; end
class BSON::Error::BSONDecodeError < ::BSON::Error; end
class BSON::Error::ExtJSONParseError < ::BSON::Error; end

class BSON::Error::InvalidBinaryType < ::BSON::Error
  def initialize(type); end

  def message; end
  def type; end
end

class BSON::Error::InvalidDBRefArgument < ::BSON::Error; end

class BSON::Error::InvalidDecimal128Argument < ::BSON::Error
  def message; end
end

BSON::Error::InvalidDecimal128Argument::MESSAGE = T.let(T.unsafe(nil), String)

class BSON::Error::InvalidDecimal128Range < ::BSON::Error
  def message; end
end

BSON::Error::InvalidDecimal128Range::MESSAGE = T.let(T.unsafe(nil), String)

class BSON::Error::InvalidDecimal128String < ::BSON::Error
  def message; end
end

BSON::Error::InvalidDecimal128String::MESSAGE = T.let(T.unsafe(nil), String)

class BSON::Error::InvalidKey < ::BSON::Error
  def initialize(object); end
end

class BSON::Error::InvalidObjectId < ::BSON::Error; end
class BSON::Error::InvalidRegexpPattern < ::BSON::Error; end

class BSON::Error::UnrepresentablePrecision < ::BSON::Error
  def message; end
end

class BSON::Error::UnserializableClass < ::BSON::Error; end
class BSON::Error::UnsupportedBinarySubtype < ::BSON::Error; end
class BSON::Error::UnsupportedType < ::BSON::Error; end

module BSON::ExtJSON
  private

  def create_binary(encoded_value, encoded_subtype); end
  def create_regexp(pattern, options); end
  def dbref?(hash); end
  def map_hash(hash, **options); end
  def parse(str, **options); end
  def parse_hash(hash, **options); end
  def parse_obj(value, **options); end
  def verify_no_reserved_keys(hash, **options); end

  class << self
    def create_binary(encoded_value, encoded_subtype); end
    def create_regexp(pattern, options); end
    def dbref?(hash); end
    def map_hash(hash, **options); end
    def parse(str, **options); end
    def parse_hash(hash, **options); end
    def parse_obj(value, **options); end
    def verify_no_reserved_keys(hash, **options); end
  end
end

BSON::ExtJSON::RESERVED_KEYS = T.let(T.unsafe(nil), Array)
BSON::ExtJSON::RESERVED_KEYS_HASH = T.let(T.unsafe(nil), Hash)

module BSON::FalseClass
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
end

BSON::FalseClass::FALSE_BYTE = T.let(T.unsafe(nil), String)

module BSON::Float
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil)); end
end

BSON::Float::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Float::ClassMethods
  def from_bson(buffer, **options); end
end

BSON::Float::PACK = T.let(T.unsafe(nil), String)

module BSON::Hash
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_bson_normalized_value; end

  private

  def serialize_key(buffer, key); end
  def serialize_key_value_pairs(buffer); end
  def serialize_to_buffer(buffer); end
end

BSON::Hash::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Hash::ClassMethods
  def from_bson(buffer, **options); end

  private

  def maybe_dbref(hash); end
  def parse_hash_contents(hash, buffer, **options); end
  def parse_hash_from_buffer(buffer, **options); end
end

class BSON::Int32
  include ::BSON::JSON

  def initialize(value); end

  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def as_json(**options); end
  def bson_type; end
  def eql?(other); end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_bson_key; end
  def value; end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Int32::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::Int32::BYTES_LENGTH = T.let(T.unsafe(nil), Integer)
BSON::Int32::PACK = T.let(T.unsafe(nil), String)

class BSON::Int64
  include ::BSON::JSON

  def initialize(value); end

  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def as_json(**options); end
  def bson_type; end
  def eql?(other); end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_bson_key; end
  def value; end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Int64::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::Int64::PACK = T.let(T.unsafe(nil), String)

module BSON::Integer
  def as_extended_json(**options); end
  def bson_int32?; end
  def bson_int64?; end
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_bson_int32(encoded); end
  def to_bson_int64(encoded); end
  def to_bson_key; end

  private

  def append_bson_int32(encoded); end
  def out_of_range!; end
end

BSON::Integer::BSON_ARRAY_INDEXES = T.let(T.unsafe(nil), Array)
BSON::Integer::BSON_INDEX_SIZE = T.let(T.unsafe(nil), Integer)
BSON::Integer::MAX_32BIT = T.let(T.unsafe(nil), Integer)
BSON::Integer::MAX_64BIT = T.let(T.unsafe(nil), Integer)
BSON::Integer::MIN_32BIT = T.let(T.unsafe(nil), Integer)
BSON::Integer::MIN_64BIT = T.let(T.unsafe(nil), Integer)

module BSON::JSON
  def to_json(*args); end
end

BSON::MILLISECONDS_IN_DAY = T.let(T.unsafe(nil), Integer)

class BSON::MaxKey
  include ::Comparable
  include ::BSON::JSON
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods

  def <=>(other); end
  def as_extended_json(**options); end
  def as_json(*_args); end
  def bson_type; end
end

BSON::MaxKey::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::MaxKey::GREATER = T.let(T.unsafe(nil), Integer)

class BSON::MinKey
  include ::Comparable
  include ::BSON::JSON
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods

  def <=>(other); end
  def as_extended_json(**options); end
  def as_json(*_args); end
  def bson_type; end
end

BSON::MinKey::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::MinKey::LESSER = T.let(T.unsafe(nil), Integer)
BSON::NO_VALUE = T.let(T.unsafe(nil), String)
BSON::NULL_BYTE = T.let(T.unsafe(nil), String)

module BSON::NilClass
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods
end

BSON::NilClass::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::NilClass::ClassMethods
  def from_bson(buffer, **options); end
end

module BSON::Object
  def as_extended_json(**_options); end
  def to_bson_key; end
  def to_bson_normalized_key; end
  def to_bson_normalized_value; end
  def to_extended_json(**options); end
end

class BSON::ObjectId
  include ::Comparable
  include ::BSON::JSON

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def _counter_part; end
  def _process_part; end
  def as_extended_json(**_); end
  def as_json(*_); end
  def bson_type; end
  def eql?(other); end
  def generation_time; end
  def hash; end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data); end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_s; end
  def to_str; end
  def to_time; end

  private

  def generate_data; end
  def initialize_copy(other); end
  def repair; end

  class << self
    def _generator; end
    def from_bson(buffer, **_); end
    def from_data(data); end
    def from_string(string); end
    def from_time(time, options = T.unsafe(nil)); end
    def legal?(string); end
    def repair(object); end
    def timestamp; end
  end
end

BSON::ObjectId::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::ObjectId::Generator
  def next_object_id(*_arg0); end
  def reset_counter(*_arg0); end
end

module BSON::OpenStruct
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
end

module BSON::Regexp
  include ::BSON::JSON

  def as_json(*_arg0); end
  def to_bson(buffer = T.unsafe(nil)); end

  private

  def bson_dotall; end
  def bson_extended; end
  def bson_ignorecase; end
  def bson_options; end
end

BSON::Regexp::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Regexp::ClassMethods
  def from_bson(buffer, **_); end
end

BSON::Regexp::EXTENDED_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::IGNORECASE_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::MULTILINE_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::NEWLINE_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::RUBY_MULTILINE_VALUE = T.let(T.unsafe(nil), String)

class BSON::Regexp::Raw
  include ::BSON::JSON

  def initialize(pattern, options = T.unsafe(nil)); end

  def ==(other); end
  def as_extended_json(**opts); end
  def as_json(*_arg0); end
  def compile; end
  def eql?(other); end
  def options; end
  def pattern; end
  def to_bson(buffer = T.unsafe(nil)); end

  private

  def method_missing(method, *arguments); end
  def options_to_int; end
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

module BSON::Registry
  extend ::BSON::Registry

  def get(byte, field = T.unsafe(nil)); end
  def register(byte, type); end

  private

  def define_type_reader(type); end
  def handle_unsupported_type!(byte, field); end
end

BSON::Registry::MAPPINGS = T.let(T.unsafe(nil), Hash)

module BSON::Specialized
  mixes_in_class_methods ::BSON::Specialized::ClassMethods

  def ==(other); end
  def to_bson(buffer = T.unsafe(nil)); end

  class << self
    def included(klass); end
  end
end

module BSON::Specialized::ClassMethods
  def from_bson(buffer, **options); end
end

module BSON::String
  def to_bson(buffer = T.unsafe(nil)); end
  def to_bson_key; end
  def to_bson_object_id; end
  def to_hex_string; end
end

BSON::String::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::String::ClassMethods
  def from_bson(buffer, **options); end
end

BSON::String::ILLEGAL_KEY = T.let(T.unsafe(nil), Regexp)

module BSON::Symbol
  def as_extended_json(**_options); end
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_bson_key; end
  def to_bson_normalized_key; end
end

BSON::Symbol::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Symbol::ClassMethods
  def from_bson(buffer, **options); end
end

class BSON::Symbol::Raw
  include ::BSON::JSON

  def initialize(str_or_sym); end

  def ==(other); end
  def as_extended_json(**_options); end
  def as_json(*args); end
  def bson_type; end
  def eql?(other); end
  def to_bson(buffer = T.unsafe(nil)); end
  def to_s; end
  def to_sym; end
end

module BSON::Time
  def _bson_to_i; end
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil)); end
end

BSON::Time::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Time::ClassMethods
  def from_bson(buffer, **options); end
end

module BSON::TimeWithZone
  def _bson_to_i; end
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
end

class BSON::Timestamp
  include ::BSON::JSON
  include ::Comparable

  def initialize(seconds, increment); end

  def <=>(other); end
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def increment; end
  def seconds; end
  def to_bson(buffer = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Timestamp::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::Timestamp::COMPARISON_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

module BSON::TrueClass
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil)); end
end

BSON::TrueClass::TRUE_BYTE = T.let(T.unsafe(nil), String)
BSON::UTF8 = T.let(T.unsafe(nil), String)

class BSON::Undefined
  include ::BSON::JSON
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods

  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
end

BSON::Undefined::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::VERSION = T.let(T.unsafe(nil), String)

class BSON::Vector < ::Array
  def initialize(data, dtype, padding = T.unsafe(nil)); end

  def data; end
  def dtype; end
  def padding; end
end

class BigDecimal < ::Numeric
  include ::BSON::BigDecimal
  extend ::BSON::BigDecimal::ClassMethods
end

class Date
  include ::Comparable
  include ::BSON::Date
end

class DateTime < ::Date
  include ::BSON::DateTime
end

class FalseClass
  include ::BSON::FalseClass
end

class Float < ::Numeric
  include ::BSON::Float
  extend ::BSON::Float::ClassMethods
end

class Hash
  include ::Enumerable
  include ::BSON::Hash
  extend ::BSON::Hash::ClassMethods
end

class Integer < ::Numeric
  include ::BSON::Integer
end

class NilClass
  include ::BSON::Specialized
  include ::BSON::NilClass
  extend ::BSON::NilClass::ClassMethods
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::BSON::Object
end

class OpenStruct
  include ::BSON::OpenStruct
end

class Regexp
  include ::BSON::JSON
  include ::BSON::Regexp
  extend ::BSON::Regexp::ClassMethods
end

class String
  include ::Comparable
  include ::BSON::String
  extend ::BSON::String::ClassMethods
end

class Symbol
  include ::Comparable
  include ::BSON::Symbol
  extend ::BSON::Symbol::ClassMethods
end

class Time
  include ::Comparable
  include ::BSON::Time
  extend ::BSON::Time::ClassMethods
end

class TrueClass
  include ::BSON::TrueClass
end
