# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rbs` gem.
# Please instead update this file by running `bin/tapioca gem rbs`.

module Kernel
  def Namespace(name); end
  def TypeName(string); end
end

module RBS
  class << self
    def logger; end
    def logger_level; end
    def logger_level=(level); end
    def logger_output; end
    def logger_output=(val); end
    def print_warning; end
  end
end

module RBS::AST; end

class RBS::AST::Annotation
  def initialize(string:, location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def string; end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Comment
  def initialize(string:, location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def string; end
  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Declarations; end

class RBS::AST::Declarations::AliasDecl < ::RBS::AST::Declarations::Base
  def initialize(new_name:, old_name:, location:, comment:); end

  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def new_name; end
  def old_name; end
end

class RBS::AST::Declarations::Base; end

class RBS::AST::Declarations::Class < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper

  def initialize(name:, type_params:, super_class:, members:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def members; end
  def name; end
  def super_class; end
  def to_json(state = T.unsafe(nil)); end
  def type_params; end
end

class RBS::AST::Declarations::Class::Super
  def initialize(name:, args:, location:); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Declarations::ClassAlias < ::RBS::AST::Declarations::AliasDecl
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Declarations::Constant < ::RBS::AST::Declarations::Base
  def initialize(name:, type:, location:, comment:); end

  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type; end
end

class RBS::AST::Declarations::Global < ::RBS::AST::Declarations::Base
  def initialize(name:, type:, location:, comment:); end

  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type; end
end

class RBS::AST::Declarations::Interface < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::MixinHelper

  def initialize(name:, type_params:, members:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def members; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type_params; end
end

module RBS::AST::Declarations::MixinHelper
  def each_mixin(&block); end
end

class RBS::AST::Declarations::Module < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper

  def initialize(name:, type_params:, members:, self_types:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def members; end
  def name; end
  def self_types; end
  def to_json(state = T.unsafe(nil)); end
  def type_params; end
end

class RBS::AST::Declarations::Module::Self
  def initialize(name:, args:, location:); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
end

class RBS::AST::Declarations::ModuleAlias < ::RBS::AST::Declarations::AliasDecl
  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Declarations::NestedDeclarationHelper
  def each_decl; end
  def each_member; end
end

class RBS::AST::Declarations::TypeAlias < ::RBS::AST::Declarations::Base
  def initialize(name:, type_params:, type:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type; end
  def type_params; end
end

module RBS::AST::Directives; end
class RBS::AST::Directives::Base; end

class RBS::AST::Directives::Use < ::RBS::AST::Directives::Base
  def initialize(clauses:, location:); end

  def clauses; end
  def location; end
end

class RBS::AST::Directives::Use::SingleClause
  def initialize(type_name:, new_name:, location:); end

  def location; end
  def new_name; end
  def type_name; end
end

class RBS::AST::Directives::Use::WildcardClause
  def initialize(namespace:, location:); end

  def location; end
  def namespace; end
end

module RBS::AST::Members; end

class RBS::AST::Members::Alias < ::RBS::AST::Members::Base
  def initialize(new_name:, old_name:, kind:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def instance?; end
  def kind; end
  def location; end
  def new_name; end
  def old_name; end
  def singleton?; end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::AttrAccessor < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::AttrReader < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::AttrWriter < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute

  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Members::Attribute
  def initialize(name:, type:, ivar_name:, kind:, annotations:, location:, comment:, visibility: T.unsafe(nil)); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def ivar_name; end
  def kind; end
  def location; end
  def name; end
  def type; end
  def update(name: T.unsafe(nil), type: T.unsafe(nil), ivar_name: T.unsafe(nil), kind: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), visibility: T.unsafe(nil)); end
  def visibility; end
end

class RBS::AST::Members::Base; end

class RBS::AST::Members::ClassInstanceVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::ClassVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Extend < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Include < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::InstanceVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var

  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Members::LocationOnly
  def initialize(location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
end

class RBS::AST::Members::MethodDefinition < ::RBS::AST::Members::Base
  def initialize(name:, kind:, overloads:, annotations:, location:, comment:, overloading:, visibility:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def instance?; end
  def kind; end
  def location; end
  def name; end
  def overloading; end
  def overloading?; end
  def overloads; end
  def singleton?; end
  def to_json(state = T.unsafe(nil)); end
  def update(name: T.unsafe(nil), kind: T.unsafe(nil), overloads: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), overloading: T.unsafe(nil), visibility: T.unsafe(nil)); end
  def visibility; end
end

class RBS::AST::Members::MethodDefinition::Overload
  def initialize(method_type:, annotations:); end

  def ==(other); end
  def annotations; end
  def eql?(other); end
  def hash; end
  def method_type; end
  def sub(subst); end
  def to_json(state = T.unsafe(nil)); end
  def update(annotations: T.unsafe(nil), method_type: T.unsafe(nil)); end
end

module RBS::AST::Members::Mixin
  def initialize(name:, args:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def args; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
end

class RBS::AST::Members::Prepend < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Private < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::LocationOnly

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Public < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::LocationOnly

  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Members::Var
  def initialize(name:, type:, location:, comment:); end

  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def type; end
end

class RBS::AST::TypeParam
  def initialize(name:, variance:, upper_bound:, location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def map_type(&block); end
  def name; end
  def rename(name); end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
  def unchecked!(value = T.unsafe(nil)); end
  def unchecked?; end
  def upper_bound; end
  def variance; end

  class << self
    def rename(params, new_names:); end
    def resolve_variables(params); end
    def subst_var(vars, type); end
  end
end

class RBS::AncestorGraph
  def initialize(env:, ancestor_builder: T.unsafe(nil)); end

  def ancestor_builder; end
  def build; end
  def build_ancestors(node, ancestors); end
  def children; end
  def each_ancestor(node, yielded: T.unsafe(nil), &block); end
  def each_child(node, &block); end
  def each_descendant(node, yielded: T.unsafe(nil), &block); end
  def each_parent(node, &block); end
  def env; end
  def parents; end
  def register(parent:, child:); end
end

class RBS::AncestorGraph::InstanceNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::AncestorGraph::SingletonNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::BaseError < ::StandardError; end

class RBS::Buffer
  def initialize(name:, content:); end

  def content; end
  def inspect; end
  def last_position; end
  def lines; end
  def loc_to_pos(loc); end
  def name; end
  def pos_to_loc(pos); end
  def ranges; end
end

module RBS::BuiltinNames; end
RBS::BuiltinNames::Array = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::BasicObject = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Class = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Comparable = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Enumerable = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Enumerator = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::FalseClass = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Float = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Hash = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Integer = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Kernel = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Module = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

class RBS::BuiltinNames::Name
  def initialize(name:); end

  def instance_type(*args); end
  def instance_type?(type); end
  def name; end
  def singleton_type; end
  def singleton_type?(type); end
  def to_s; end

  class << self
    def define(name, namespace: T.unsafe(nil)); end
  end
end

RBS::BuiltinNames::Numeric = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Object = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Range = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Regexp = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Set = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::String = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Symbol = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::TrueClass = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
module RBS::Collection; end

class RBS::Collection::Cleaner
  def initialize(lockfile_path:); end

  def clean; end
  def lock; end
  def needed?(gem_name, version); end
end

class RBS::Collection::Config
  def initialize(data, config_path:); end

  def config_path; end
  def data; end
  def gem(gem_name); end
  def gems; end
  def repo_path; end
  def repo_path_data; end
  def sources; end

  class << self
    def find_config_path; end
    def from_path(path); end
    def generate_lockfile(config_path:, definition:, with_lockfile: T.unsafe(nil)); end
    def to_lockfile_path(config_path); end
  end
end

class RBS::Collection::Config::CollectionNotAvailable < ::StandardError
  def initialize; end
end

class RBS::Collection::Config::Lockfile
  def initialize(lockfile_path:, path:, gemfile_lock_path:); end

  def check_rbs_availability!; end
  def each_source(&block); end
  def fullpath; end
  def gemfile_lock_fullpath; end
  def gemfile_lock_path; end
  def gems; end
  def library_data(lib); end
  def lockfile_dir; end
  def lockfile_path; end
  def path; end
  def sources; end
  def to_lockfile; end

  class << self
    def from_lockfile(lockfile_path:, data:); end
  end
end

class RBS::Collection::Config::LockfileGenerator
  def initialize(config:, definition:, with_lockfile:); end

  def config; end
  def definition; end
  def existing_lockfile; end
  def gem_entries; end
  def gem_hash; end
  def generate; end
  def lockfile; end

  private

  def assign_gem(name:, version:, skip: T.unsafe(nil)); end
  def assign_stdlib(name:, from_gem:); end
  def find_best_version(version:, versions:); end
  def find_source(name:); end
  def validate_gemfile_lock_path!(lock:, gemfile_lock_path:); end

  class << self
    def generate(config:, definition:, with_lockfile: T.unsafe(nil)); end
  end
end

class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError < ::StandardError
  def initialize(expected:, actual:); end

  def message; end
end

RBS::Collection::Config::PATH = T.let(T.unsafe(nil), Pathname)

class RBS::Collection::Installer
  def initialize(lockfile_path:, stdout: T.unsafe(nil)); end

  def install_from_lockfile; end
  def lockfile; end
  def stdout; end
end

module RBS::Collection::Sources
  class << self
    def from_config_entry(source_entry, base_directory:); end
  end
end

module RBS::Collection::Sources::Base
  def dependencies_of(name, version); end
end

class RBS::Collection::Sources::Git
  include ::RBS::Collection::Sources::Base

  def initialize(name:, revision:, remote:, repo_dir:); end

  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def load_metadata(dir:); end
  def manifest_of(name, version); end
  def metadata_content(name:, version:); end
  def name; end
  def remote; end
  def repo_dir; end
  def resolved_revision; end
  def revision; end
  def to_lockfile; end
  def versions(name); end
  def write_metadata(dir:, name:, version:); end

  private

  def _install(dest:, name:, version:); end
  def commit_hash?; end
  def cp_r(src, dest); end
  def format_config_entry(name, version); end
  def gem_repo_dir; end
  def gems_versions; end
  def git(*cmd, **opt); end
  def git?(*cmd, **opt); end
  def git_dir; end
  def need_to_fetch?(revision); end
  def setup!; end
  def sh!(*cmd, **opt); end
end

class RBS::Collection::Sources::Git::CommandError < ::StandardError; end
RBS::Collection::Sources::Git::METADATA_FILENAME = T.let(T.unsafe(nil), String)

class RBS::Collection::Sources::Local
  include ::RBS::Collection::Sources::Base

  def initialize(path:, base_directory:); end

  def full_path; end
  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def manifest_of(name, version); end
  def path; end
  def to_lockfile; end
  def versions(name); end

  private

  def _install(src, dst); end
end

class RBS::Collection::Sources::Rubygems
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def manifest_of(name, version); end
  def to_lockfile; end
  def versions(name); end

  private

  def gem_sig_path(name, version); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

class RBS::Collection::Sources::Stdlib
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def manifest_of(name, version); end
  def to_lockfile; end
  def versions(name); end

  private

  def lookup(name, version); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

RBS::Collection::Sources::Stdlib::REPO = T.let(T.unsafe(nil), RBS::Repository)

class RBS::Constant
  def initialize(name:, type:, entry:); end

  def ==(other); end
  def entry; end
  def eql?(other); end
  def hash; end
  def name; end
  def type; end
end

class RBS::CyclicClassAliasDefinitionError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(entry); end

  def alias_entry; end
  def location; end
end

class RBS::CyclicTypeParameterBound < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, method_name:, params:, location:); end

  def location; end
  def method_name; end
  def params; end
  def type_name; end
end

class RBS::Definition
  def initialize(type_name:, entry:, self_type:, ancestors:); end

  def ancestors; end
  def class?; end
  def class_type?; end
  def class_variables; end
  def each_type(&block); end
  def entry; end
  def instance_type?; end
  def instance_variables; end
  def interface?; end
  def interface_type?; end
  def map_method_type(&block); end
  def methods; end
  def module?; end
  def self_type; end
  def sub(s); end
  def type_name; end
  def type_params; end
  def type_params_decl; end
end

module RBS::Definition::Ancestor; end

class RBS::Definition::Ancestor::Instance
  def initialize(name:, args:, source:); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def name; end
  def source; end
end

class RBS::Definition::Ancestor::Singleton
  def initialize(name:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def name; end
end

class RBS::Definition::InstanceAncestors
  def initialize(type_name:, params:, ancestors:); end

  def ancestors; end
  def apply(args, location:); end
  def params; end
  def type_name; end
end

class RBS::Definition::Method
  def initialize(super_method:, defs:, accessibility:, alias_of:, annotations: T.unsafe(nil)); end

  def ==(other); end
  def accessibility; end
  def alias_of; end
  def annotations; end
  def comments; end
  def defined_in; end
  def defs; end
  def eql?(other); end
  def extra_annotations; end
  def hash; end
  def implemented_in; end
  def map_method_type(&block); end
  def map_type(&block); end
  def map_type_bound(&block); end
  def members; end
  def method_types; end
  def private?; end
  def public?; end
  def sub(s); end
  def super_method; end
  def update(super_method: T.unsafe(nil), defs: T.unsafe(nil), accessibility: T.unsafe(nil), alias_of: T.unsafe(nil), annotations: T.unsafe(nil)); end
end

class RBS::Definition::Method::TypeDef
  def initialize(type:, member:, defined_in:, implemented_in:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def defined_in; end
  def eql?(other); end
  def hash; end
  def implemented_in; end
  def member; end
  def overload?; end
  def type; end
  def update(type: T.unsafe(nil), member: T.unsafe(nil), defined_in: T.unsafe(nil), implemented_in: T.unsafe(nil)); end
end

class RBS::Definition::SingletonAncestors
  def initialize(type_name:, ancestors:); end

  def ancestors; end
  def type_name; end
end

class RBS::Definition::Variable
  def initialize(parent_variable:, type:, declared_in:); end

  def declared_in; end
  def parent_variable; end
  def sub(s); end
  def type; end
end

class RBS::DefinitionBuilder
  def initialize(env:, ancestor_builder: T.unsafe(nil), method_builder: T.unsafe(nil)); end

  def ancestor_builder; end
  def build_instance(type_name); end
  def build_interface(type_name); end
  def build_singleton(type_name); end
  def build_singleton0(type_name); end
  def define_instance(definition, type_name, subst); end
  def define_interface(definition, type_name, subst); end
  def define_method(methods, definition, method, subst, defined_in:, implemented_in: T.unsafe(nil)); end
  def ensure_namespace!(namespace, location:); end
  def env; end
  def expand_alias(type_name); end
  def expand_alias1(type_name); end
  def expand_alias2(type_name, args); end
  def import_methods(definition, module_name, module_methods, interfaces_methods, subst); end
  def insert_variable(type_name, variables, name:, type:); end
  def instance_cache; end
  def interface_cache; end
  def interface_methods(interface_ancestors); end
  def method_builder; end
  def singleton0_cache; end
  def singleton_cache; end
  def source_location(source, decl); end
  def tapp_subst(name, args); end
  def try_cache(type_name, cache:); end
  def update(env:, except:, ancestor_builder:); end
  def validate_params_with(type_params, result:); end
  def validate_type_name(name, location); end
  def validate_type_params(definition, ancestors:, methods:); end
  def validate_type_presence(type); end
end

class RBS::DefinitionBuilder::AncestorBuilder
  def initialize(env:); end

  def env; end
  def fill_ancestor_source(ancestor, name:, source:, &block); end
  def instance_ancestors(type_name, building_ancestors: T.unsafe(nil)); end
  def instance_ancestors_cache; end
  def interface_ancestors(type_name, building_ancestors: T.unsafe(nil)); end
  def interface_ancestors_cache; end
  def mixin_ancestors(entry, type_name, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end
  def mixin_ancestors0(decl, type_name, align_params:, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end
  def one_instance_ancestors(type_name); end
  def one_instance_ancestors_cache; end
  def one_interface_ancestors(type_name); end
  def one_interface_ancestors_cache; end
  def one_singleton_ancestors(type_name); end
  def one_singleton_ancestors_cache; end
  def singleton_ancestors(type_name, building_ancestors: T.unsafe(nil)); end
  def singleton_ancestors_cache; end
  def validate_super_class!(type_name, entry); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def initialize(type_name:, params:, super_class:, self_types:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  def each_ancestor(&block); end
  def each_extended_interface(&block); end
  def each_extended_module(&block); end
  def each_included_interface(&block); end
  def each_included_module(&block); end
  def each_prepended_module(&block); end
  def each_self_type(&block); end
  def extended_interfaces; end
  def extended_modules; end
  def included_interfaces; end
  def included_modules; end
  def params; end
  def prepended_modules; end
  def self_types; end
  def super_class; end
  def type_name; end

  class << self
    def class_instance(type_name:, params:, super_class:); end
    def interface(type_name:, params:); end
    def module_instance(type_name:, params:); end
    def singleton(type_name:, super_class:); end
  end
end

class RBS::DefinitionBuilder::MethodBuilder
  def initialize(env:); end

  def build_alias(methods, type, member:); end
  def build_attribute(methods, type, member:, accessibility:); end
  def build_instance(type_name); end
  def build_interface(type_name); end
  def build_method(methods, type, member:, accessibility:); end
  def build_singleton(type_name); end
  def each_member_with_accessibility(members, accessibility: T.unsafe(nil)); end
  def env; end
  def instance_methods; end
  def interface_methods; end
  def singleton_methods; end
  def update(env:, except:); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods
  def initialize(type:); end

  def each; end
  def methods; end
  def type; end
  def validate!; end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition < ::Struct
  def accessibilities; end
  def accessibilities=(_); end
  def accessibility; end
  def name; end
  def name=(_); end
  def original; end
  def originals; end
  def originals=(_); end
  def overloads; end
  def overloads=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def empty(name:, type:); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
  include ::TSort

  def initialize(methods); end

  def methods; end
  def tsort_each_child(defn); end
  def tsort_each_node(&block); end
end

class RBS::DefinitionError < ::RBS::BaseError; end

module RBS::DetailedMessageable
  def detailed_message(highlight: T.unsafe(nil), **_arg1); end
end

class RBS::DuplicatedDeclarationError < ::RBS::LoadingError
  def initialize(name, *decls); end

  def decls; end
  def name; end
end

class RBS::DuplicatedInterfaceMethodDefinitionError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type:, method_name:, member:); end

  def location; end
  def member; end
  def method_name; end
  def qualified_method_name; end
  def type; end
  def type_name; end
end

class RBS::DuplicatedMethodDefinitionError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type:, method_name:, members:); end

  def location; end
  def members; end
  def method_name; end
  def other_locations; end
  def qualified_method_name; end
  def type; end
  def type_name; end
end

class RBS::Environment
  def initialize; end

  def <<(decl); end
  def absolute_type(resolver, map, type, context:); end
  def absolute_type_name(resolver, map, type_name, context:); end
  def add_signature(buffer:, directives:, decls:); end
  def append_context(context, decl); end
  def buffers; end
  def class_alias?(name); end
  def class_alias_decls; end
  def class_decl?(name); end
  def class_decls; end
  def class_entry(type_name); end
  def constant_decl?(name); end
  def constant_decls; end
  def constant_entry(type_name); end
  def constant_name?(name); end
  def declarations; end
  def global_decls; end
  def insert_decl(decl, outer:, namespace:); end
  def inspect; end
  def interface_decls; end
  def interface_name?(name); end
  def module_alias?(name); end
  def module_class_entry(type_name); end
  def module_decl?(name); end
  def module_entry(type_name); end
  def module_name?(name); end
  def normalize_module_name(name); end
  def normalize_module_name?(name); end
  def normalize_type_name(name); end
  def normalize_type_name!(name); end
  def normalize_type_name?(name); end
  def normalized_class_entry(type_name); end
  def normalized_module_class_entry(type_name); end
  def normalized_module_entry(type_name); end
  def normalized_type_name!(name); end
  def normalized_type_name?(type_name); end
  def resolve_declaration(resolver, map, decl, outer:, prefix:); end
  def resolve_member(resolver, map, member, context:); end
  def resolve_method_type(resolver, map, type, context:); end
  def resolve_type_names(only: T.unsafe(nil)); end
  def resolve_type_params(resolver, map, params, context:); end
  def resolver_context(*nesting); end
  def signatures; end
  def type_alias_decls; end
  def type_alias_name?(name); end
  def type_name?(name); end
  def unload(buffers); end
  def validate_type_params; end

  private

  def initialize_copy(other); end

  class << self
    def from_loader(loader); end
  end
end

class RBS::Environment::ClassAliasEntry < ::RBS::Environment::SingleEntry; end

class RBS::Environment::ClassEntry < ::RBS::Environment::MultiEntry
  def primary; end
end

class RBS::Environment::ConstantEntry < ::RBS::Environment::SingleEntry; end

module RBS::Environment::ContextUtil
  def calculate_context(decls); end
end

class RBS::Environment::GlobalEntry < ::RBS::Environment::SingleEntry; end
class RBS::Environment::InterfaceEntry < ::RBS::Environment::SingleEntry; end
class RBS::Environment::ModuleAliasEntry < ::RBS::Environment::SingleEntry; end

class RBS::Environment::ModuleEntry < ::RBS::Environment::MultiEntry
  def primary; end
  def self_types; end
end

class RBS::Environment::MultiEntry
  def initialize(name:); end

  def compatible_params?(ps1, ps2); end
  def decls; end
  def insert(decl:, outer:); end
  def name; end
  def primary; end
  def type_params; end
  def validate_type_params; end
end

class RBS::Environment::MultiEntry::D < ::Struct
  include ::RBS::Environment::ContextUtil

  def context; end
  def decl; end
  def decl=(_); end
  def outer; end
  def outer=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::Environment::SingleEntry
  include ::RBS::Environment::ContextUtil

  def initialize(name:, decl:, outer:); end

  def context; end
  def decl; end
  def name; end
  def outer; end
end

class RBS::Environment::TypeAliasEntry < ::RBS::Environment::SingleEntry; end

class RBS::Environment::UseMap
  def initialize(table:); end

  def build_map(clause); end
  def resolve(type_name); end
  def resolve?(type_name); end
  def use_dirs; end
end

class RBS::Environment::UseMap::Table
  def initialize; end

  def children; end
  def compute_children; end
  def known_types; end
end

class RBS::EnvironmentLoader
  include ::RBS::FileFinder

  def initialize(core_root: T.unsafe(nil), repository: T.unsafe(nil)); end

  def add(path: T.unsafe(nil), library: T.unsafe(nil), version: T.unsafe(nil), resolve_dependencies: T.unsafe(nil)); end
  def add_collection(lockfile); end
  def core_root; end
  def dirs; end
  def each_dir; end
  def each_signature; end
  def has_library?(library:, version:); end
  def libs; end
  def load(env:); end
  def repository; end
  def resolve_dependencies(library:, version:); end

  class << self
    def gem_sig_path(name, version); end
  end
end

RBS::EnvironmentLoader::DEFAULT_CORE_ROOT = T.let(T.unsafe(nil), Pathname)

class RBS::EnvironmentLoader::Library < ::Struct
  def name; end
  def name=(_); end
  def version; end
  def version=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::EnvironmentLoader::UnknownLibraryError < ::StandardError
  def initialize(lib:); end

  def library; end
end

class RBS::EnvironmentWalker
  include ::TSort

  def initialize(env:); end

  def builder; end
  def each_type_name(type, &block); end
  def each_type_node(type, &block); end
  def env; end
  def only_ancestors!(only = T.unsafe(nil)); end
  def only_ancestors?; end
  def tsort_each_child(node, &block); end
  def tsort_each_node(&block); end
end

class RBS::EnvironmentWalker::InstanceNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::EnvironmentWalker::SingletonNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::EnvironmentWalker::TypeNameNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::Factory
  def type_name(string); end
end

module RBS::FileFinder
  class << self
    def each_file(path, immediate:, skip_hidden:, &block); end
  end
end

class RBS::GenericParameterMismatchError < ::RBS::LoadingError
  def initialize(name:, decl:); end

  def decl; end
  def name; end
end

class RBS::InconsistentClassModuleAliasError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(entry); end

  def alias_entry; end
  def location; end
end

class RBS::InheritModuleError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(super_decl); end

  def location; end
  def super_decl; end

  class << self
    def check!(super_decl, env:); end
  end
end

class RBS::InvalidOverloadMethodError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, method_name:, kind:, members:); end

  def kind; end
  def location; end
  def members; end
  def method_name; end
  def type_name; end
end

class RBS::InvalidTypeApplicationError < ::RBS::DefinitionError
  def initialize(type_name:, args:, params:, location:); end

  def args; end
  def location; end
  def params; end
  def type_name; end

  class << self
    def check!(type_name:, args:, params:, location:); end
  end
end

class RBS::InvalidVarianceAnnotationError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, param:, location:); end

  def location; end
  def param; end
  def type_name; end
end

class RBS::LoadingError < ::RBS::BaseError; end

class RBS::Location
  def initialize(_arg0, _arg1, _arg2); end

  def ==(other); end
  def [](_arg0); end
  def _add_optional_child(_arg0, _arg1, _arg2); end
  def _add_optional_no_child(_arg0); end
  def _add_required_child(_arg0, _arg1, _arg2); end
  def _optional_keys; end
  def _required_keys; end
  def add_optional_child(name, range); end
  def add_required_child(name, range); end
  def aref(_arg0); end
  def buffer; end
  def each_optional_key(&block); end
  def each_required_key(&block); end
  def end_column; end
  def end_line; end
  def end_loc; end
  def end_pos; end
  def inspect; end
  def key?(name); end
  def name; end
  def optional_key?(name); end
  def range; end
  def required_key?(name); end
  def source; end
  def start_column; end
  def start_line; end
  def start_loc; end
  def start_pos; end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end

  private

  def _end_loc; end
  def _start_loc; end
  def initialize_copy(_arg0); end

  class << self
    def new(buffer_ = T.unsafe(nil), start_pos_ = T.unsafe(nil), end_pos_ = T.unsafe(nil), buffer: T.unsafe(nil), start_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
    def to_string(location, default: T.unsafe(nil)); end
  end
end

RBS::Location::WithChildren = RBS::Location

class RBS::Locator
  def initialize(buffer:, dirs:, decls:); end

  def buffer; end
  def decls; end
  def dirs; end
  def find(line:, column:); end
  def find2(line:, column:); end
  def find_in_decl(pos, decl:, array:); end
  def find_in_directive(pos, dir, array); end
  def find_in_loc(pos, location:, array:); end
  def find_in_member(pos, member:, array:); end
  def find_in_method_type(pos, method_type:, array:); end
  def find_in_type(pos, type:, array:); end
  def find_in_type_param(pos, type_param:, array:); end
  def test_loc(pos, location:); end
end

module RBS::MethodNameHelper
  def method_name_string; end
end

class RBS::MethodType
  def initialize(type_params:, type:, block:, location:); end

  def ==(other); end
  def block; end
  def each_type(&block); end
  def free_variables(set = T.unsafe(nil)); end
  def location; end
  def map_type(&block); end
  def map_type_bound(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
  def type; end
  def type_param_names; end
  def type_params; end
  def update(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end
end

class RBS::MixinClassError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, member:); end

  def location; end
  def member; end
  def type_name; end

  private

  def mixin_name; end

  class << self
    def check!(type_name:, env:, member:); end
  end
end

class RBS::Namespace
  def initialize(path:, absolute:); end

  def +(other); end
  def ==(other); end
  def absolute!; end
  def absolute?; end
  def append(component); end
  def ascend; end
  def empty?; end
  def eql?(other); end
  def hash; end
  def parent; end
  def path; end
  def relative!; end
  def relative?; end
  def split; end
  def to_s; end
  def to_type_name; end

  class << self
    def empty; end
    def parse(string); end
    def root; end
  end
end

class RBS::NoMixinFoundError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, member:); end

  def location; end
  def member; end
  def type_name; end

  class << self
    def check!(type_name, env:, member:); end
  end
end

class RBS::NoSelfTypeFoundError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, location:); end

  def location; end
  def type_name; end

  class << self
    def check!(self_type, env:); end
  end
end

class RBS::NoSuperclassFoundError < ::RBS::DefinitionError
  def initialize(type_name:, location:); end

  def location; end
  def type_name; end

  class << self
    def check!(type_name, env:, location:); end
  end
end

class RBS::NoTypeFoundError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, location:); end

  def location; end
  def type_name; end

  class << self
    def check!(type_name, env:, location:); end
  end
end

class RBS::NonregularTypeAliasError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(diagnostic:, location:); end

  def diagnostic; end
  def location; end
end

class RBS::Parser
  class << self
    def _parse_method_type(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def _parse_signature(_arg0, _arg1); end
    def _parse_type(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def buffer(source); end
    def parse_method_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil)); end
    def parse_signature(source); end
    def parse_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil)); end
  end
end

RBS::Parser::KEYWORDS = T.let(T.unsafe(nil), Hash)
RBS::Parser::LexerError = RBS::ParsingError
class RBS::Parser::LocatedValue; end
RBS::Parser::SemanticsError = RBS::ParsingError
RBS::Parser::SyntaxError = RBS::ParsingError

class RBS::ParsingError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(location, error_message, token_type); end

  def error_message; end
  def error_value; end
  def location; end
  def token_str; end
  def token_type; end
end

module RBS::Prototype; end

module RBS::Prototype::Helpers
  private

  def any_node?(node, nodes: T.unsafe(nil), &block); end
  def args_from_node(args_node); end
  def block_from_body(node); end
  def each_child(node, &block); end
  def each_node(nodes); end
  def keyword_hash?(node); end
  def untyped; end
end

class RBS::Prototype::NodeUsage
  include ::RBS::Prototype::Helpers

  def initialize(node); end

  def calculate(node, conditional:); end
  def conditional_nodes; end
  def each_conditional_node(&block); end
end

class RBS::Prototype::RB
  include ::RBS::Prototype::Helpers

  def initialize; end

  def block_type(node); end
  def body_type(node); end
  def const_to_name(node, context:); end
  def const_to_name!(node); end
  def current_accessibility(decls, index = T.unsafe(nil)); end
  def decls; end
  def find_def_index_by_name(decls, name); end
  def function_return_type_from_body(node); end
  def function_type_from_body(node, def_name); end
  def if_unless_type(node); end
  def is_accessibility?(decl); end
  def literal_to_symbol(node); end
  def literal_to_type(node); end
  def node_type(node, default: T.unsafe(nil)); end
  def param_type(node, default: T.unsafe(nil)); end
  def parse(string); end
  def private; end
  def process(node, decls:, comments:, context:); end
  def process_children(node, decls:, comments:, context:); end
  def public; end
  def range_element_type(types); end
  def remove_unnecessary_accessibility_methods!(decls); end
  def sort_members!(decls); end
  def source_decls; end
  def toplevel_members; end
  def types_to_union_type(types); end
end

class RBS::Prototype::RB::Context < ::Struct
  def attribute_kind; end
  def enter_namespace(namespace); end
  def in_def; end
  def in_def=(_); end
  def method_kind; end
  def module_function; end
  def module_function=(_); end
  def namespace; end
  def namespace=(_); end
  def singleton; end
  def singleton=(_); end
  def update(module_function: T.unsafe(nil), singleton: T.unsafe(nil), in_def: T.unsafe(nil)); end

  class << self
    def [](*_arg0); end
    def initial(namespace: T.unsafe(nil)); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::Prototype::RBI
  def initialize; end

  def call_node?(node, name:, receiver: T.unsafe(nil), args: T.unsafe(nil)); end
  def const_to_name(node); end
  def current_module; end
  def current_module!; end
  def current_namespace; end
  def decls; end
  def each_arg(array, &block); end
  def each_child(node); end
  def join_comments(nodes, comments); end
  def last_sig; end
  def method_type(args_node, type_node, variables:, overloads:); end
  def modules; end
  def nested_name(name); end
  def node_to_hash(node); end
  def parse(string); end
  def parse_params(args_node, args, method_type, variables:, overloads:); end
  def pop_sig; end
  def proc_type?(type_node); end
  def process(node, comments:, outer: T.unsafe(nil)); end
  def push_class(name, super_class, comment:); end
  def push_module(name, comment:); end
  def push_sig(node); end
  def type_of(type_node, variables:); end
  def type_of0(type_node, variables:); end
end

class RBS::Prototype::Runtime
  include ::RBS::Prototype::Helpers

  def initialize(patterns:, env:, merge:, owners_included: T.unsafe(nil)); end

  def block_from_ast_of(method); end
  def builder; end
  def const_name(const); end
  def decls; end
  def each_included_module(type_name, mod); end
  def ensure_outer_module_declarations(mod); end
  def env; end
  def generate_class(mod); end
  def generate_constants(mod, decls); end
  def generate_methods(mod, module_name, members); end
  def generate_module(mod); end
  def generate_super_class(mod); end
  def merge; end
  def merge_rbs(module_name, members, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end
  def method_type(method); end
  def only_name(mod); end
  def outline; end
  def outline=(_arg0); end
  def owners_included; end
  def parse(file); end
  def patterns; end
  def target?(const); end
  def target_method?(mod, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end
  def to_type_name(name, full_name: T.unsafe(nil)); end
  def type_args(type_name); end
  def type_params(mod); end
end

module RBS::RDocPlugin; end

class RBS::RDocPlugin::Parser
  def initialize(top_level, content); end

  def content; end
  def content=(_arg0); end
  def parse_attr_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_class_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_constant_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_extend_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_include_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_member(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_method_alias_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_method_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_module_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def scan; end
  def top_level; end
  def top_level=(_arg0); end

  private

  def comment_string(with_comment); end
  def construct_comment(context:, comment:); end
  def fully_qualified_name(outer_name:, decl:); end
end

class RBS::RecursiveAliasDefinitionError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type:, defs:); end

  def defs; end
  def location; end
  def type; end
end

class RBS::RecursiveAncestorError < ::RBS::DefinitionError
  def initialize(ancestors:, location:); end

  def ancestors; end
  def location; end

  class << self
    def check!(self_ancestor, ancestors:, location:); end
  end
end

class RBS::RecursiveTypeAliasError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(alias_names:, location:); end

  def alias_names; end
  def location; end
  def name; end
end

class RBS::Repository
  def initialize(no_stdlib: T.unsafe(nil)); end

  def add(dir); end
  def dirs; end
  def gems; end
  def lookup(gem, version); end
  def lookup_path(gem, version); end

  class << self
    def default; end
    def find_best_version(version, candidates); end
  end
end

RBS::Repository::DEFAULT_STDLIB_ROOT = T.let(T.unsafe(nil), Pathname)

class RBS::Repository::GemRBS
  def initialize(name:); end

  def empty?; end
  def find_best_version(version); end
  def latest_version; end
  def load!; end
  def name; end
  def oldest_version; end
  def paths; end
  def version_names; end
  def versions; end
end

class RBS::Repository::VersionPath < ::Struct
  def gem; end
  def gem=(_); end
  def path; end
  def path=(_); end
  def version; end
  def version=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RBS::Resolver; end

class RBS::Resolver::ConstantResolver
  def initialize(builder:); end

  def builder; end
  def child_constants_cache; end
  def children(module_name); end
  def constants(context); end
  def constants_from_ancestors(module_name, constants:); end
  def constants_from_context(context, constants:); end
  def constants_itself(context, constants:); end
  def context_constants_cache; end
  def load_child_constants(name); end
  def load_context_constants(context); end
  def resolve(name, context:); end
  def resolve_child(module_name, name); end
  def table; end
end

class RBS::Resolver::ConstantResolver::Table
  def initialize(environment); end

  def children(name); end
  def children_table; end
  def constant(name); end
  def constant_of_constant(name, entry); end
  def constant_of_module(name, entry); end
  def constants_table; end
  def toplevel; end
end

class RBS::Resolver::TypeNameResolver
  def initialize(env); end

  def all_names; end
  def cache; end
  def env; end
  def has_name?(full_name); end
  def partition(type_name); end
  def resolve(type_name, context:); end
  def resolve_in(head, context); end
  def try_cache(query); end
end

class RBS::Substitution
  def initialize; end

  def +(other); end
  def [](ty); end
  def add(from:, to:); end
  def apply(ty); end
  def empty?; end
  def instance_type; end
  def instance_type=(_arg0); end
  def mapping; end
  def without(*vars); end

  class << self
    def build(variables, types, instance_type: T.unsafe(nil), &block); end
  end
end

class RBS::Subtractor
  def initialize(minuend, subtrahend); end

  def call(minuend = T.unsafe(nil), context: T.unsafe(nil)); end

  private

  def absolute_typename(name, context:); end
  def access_modifier?(decl); end
  def cvar_exist?(owner, name); end
  def each_member(owner, &block); end
  def filter_members(decl, context:); end
  def filter_redundunt_access_modifiers(decls); end
  def ivar_exist?(owner, name, kind); end
  def member_exist?(owner, member, context:); end
  def method_exist?(owner, method_name, kind); end
  def mixin_exist?(owner, mixin, context:); end
  def typename_candidates(name, context:); end
  def update_decl(decl, members:); end
end

class RBS::SuperclassMismatchError < ::RBS::DefinitionError
  def initialize(name:, entry:); end

  def entry; end
  def name; end
end

class RBS::TypeAliasDependency
  def initialize(env:); end

  def build_dependencies; end
  def circular_definition?(alias_name); end
  def dependencies; end
  def dependencies_of(name); end
  def direct_dependencies; end
  def direct_dependencies_of(name); end
  def env; end
  def transitive_closure; end

  private

  def dependency(start, vertex, nested = T.unsafe(nil)); end
  def direct_dependency(type, result = T.unsafe(nil)); end
end

class RBS::TypeAliasRegularity
  def initialize(env:); end

  def build_alias_type(name); end
  def builder; end
  def compatible_args?(args1, args2); end
  def diagnostics; end
  def each_alias_type(type, &block); end
  def each_mutual_alias_defs(&block); end
  def env; end
  def nonregular?(type_name); end
  def validate; end
  def validate_alias_type(alias_type, names, types); end

  class << self
    def validate(env:); end
  end
end

class RBS::TypeAliasRegularity::Diagnostic
  def initialize(type_name:, nonregular_type:); end

  def nonregular_type; end
  def type_name; end
end

class RBS::TypeName
  def initialize(namespace:, name:); end

  def +(other); end
  def ==(other); end
  def absolute!; end
  def absolute?; end
  def alias?; end
  def class?; end
  def eql?(other); end
  def hash; end
  def interface?; end
  def kind; end
  def name; end
  def namespace; end
  def relative!; end
  def split; end
  def to_json(state = T.unsafe(nil)); end
  def to_namespace; end
  def to_s; end
  def with_prefix(namespace); end
end

module RBS::Types; end

class RBS::Types::Alias
  include ::RBS::Types::Application

  def initialize(name:, args:, location:); end

  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
end

module RBS::Types::Application
  def ==(other); end
  def args; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def name; end
  def to_s(level = T.unsafe(nil)); end
end

module RBS::Types::Bases; end
class RBS::Types::Bases::Any < ::RBS::Types::Bases::Base; end

class RBS::Types::Bases::Base
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName

  def initialize(location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
end

class RBS::Types::Bases::Bool < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Bottom < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Class < ::RBS::Types::Bases::Base; end

class RBS::Types::Bases::Instance < ::RBS::Types::Bases::Base
  def sub(s); end
end

class RBS::Types::Bases::Nil < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Self < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Top < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Void < ::RBS::Types::Bases::Base; end

class RBS::Types::Block
  def initialize(type:, required:, self_type: T.unsafe(nil)); end

  def ==(other); end
  def map_type(&block); end
  def required; end
  def self_type; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def type; end
end

class RBS::Types::ClassInstance
  include ::RBS::Types::Application

  def initialize(name:, args:, location:); end

  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::Types::ClassSingleton
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType

  def initialize(name:, location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def map_type_name; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
end

module RBS::Types::EmptyEachType
  def each_type; end
  def map_type(&block); end
end

class RBS::Types::Function
  def initialize(required_positionals:, optional_positionals:, rest_positionals:, trailing_positionals:, required_keywords:, optional_keywords:, rest_keywords:, return_type:); end

  def ==(other); end
  def amap(array, &block); end
  def drop_head; end
  def drop_tail; end
  def each_param(&block); end
  def each_type; end
  def empty?; end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_keyword?; end
  def hash; end
  def hmapv(hash, &block); end
  def map_type(&block); end
  def map_type_name(&block); end
  def optional_keywords; end
  def optional_positionals; end
  def param_to_s; end
  def required_keywords; end
  def required_positionals; end
  def rest_keywords; end
  def rest_positionals; end
  def return_to_s; end
  def return_type; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def trailing_positionals; end
  def update(required_positionals: T.unsafe(nil), optional_positionals: T.unsafe(nil), rest_positionals: T.unsafe(nil), trailing_positionals: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil), return_type: T.unsafe(nil)); end
  def with_return_type(type); end

  class << self
    def empty(return_type); end
  end
end

class RBS::Types::Function::Param
  def initialize(type:, name:, location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def map_type(&block); end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
  def type; end
end

class RBS::Types::Interface
  include ::RBS::Types::Application

  def initialize(name:, args:, location:); end

  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::Types::Intersection
  def initialize(types:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def types; end
end

class RBS::Types::Literal
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName

  def initialize(literal:, location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def literal; end
  def location; end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
end

module RBS::Types::NoFreeVariables
  def free_variables(set = T.unsafe(nil)); end
end

module RBS::Types::NoSubst
  def sub(s); end
end

module RBS::Types::NoTypeName
  def map_type_name; end
end

class RBS::Types::Optional
  def initialize(type:, location:); end

  def ==(other); end
  def each_type; end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def type; end
end

class RBS::Types::Proc
  def initialize(location:, type:, block:, self_type: T.unsafe(nil)); end

  def ==(other); end
  def block; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def self_type; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def type; end
end

class RBS::Types::Record
  def initialize(fields:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def fields; end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
end

module RBS::Types::SelfTypeBindingHelper
  private

  def self_type_binding_to_s(t); end

  class << self
    def self_type_binding_to_s(t); end
  end
end

class RBS::Types::Tuple
  def initialize(types:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def types; end
end

class RBS::Types::Union
  def initialize(types:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def types; end
end

class RBS::Types::Variable
  include ::RBS::Types::NoTypeName
  include ::RBS::Types::EmptyEachType

  def initialize(name:, location:); end

  def ==(other); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def hash; end
  def location; end
  def name; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end

  class << self
    def build(v); end
    def fresh(v = T.unsafe(nil)); end
  end
end

class RBS::UnknownMethodAliasError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, original_name:, aliased_name:, location:); end

  def aliased_name; end
  def location; end
  def original_name; end
  def type_name; end
end

RBS::VERSION = T.let(T.unsafe(nil), String)

class RBS::Validator
  def initialize(env:, resolver:); end

  def absolute_type(type, context:, &block); end
  def definition_builder; end
  def env; end
  def resolver; end
  def type_alias_dependency; end
  def type_alias_regularity; end
  def validate_class_alias(entry:); end
  def validate_method_definition(method_def, type_name:); end
  def validate_type(type, context:); end
  def validate_type_alias(entry:); end
  def validate_type_params(params, type_name:, location:, method_name: T.unsafe(nil)); end
end

class RBS::VarianceCalculator
  def initialize(builder:); end

  def builder; end
  def env; end
  def function(type, result:, context:); end
  def in_inherit(name:, args:, variables:); end
  def in_method_type(method_type:, variables:); end
  def in_type_alias(name:); end
  def negate(variance); end
  def type(type, result:, context:); end
end

class RBS::VarianceCalculator::Result
  def initialize(variables:); end

  def compatible?(var, with_annotation:); end
  def contravariant(x); end
  def covariant(x); end
  def each(&block); end
  def include?(name); end
  def incompatible?(params); end
  def invariant(x); end
  def result; end
end

class RBS::Vendorer
  def initialize(vendor_dir:, loader:); end

  def clean!; end
  def copy!; end
  def ensure_dir; end
  def loader; end
  def vendor_dir; end
end

class RBS::Writer
  def initialize(out:); end

  def attribute(kind, attr); end
  def format_annotation(annotation); end
  def indent(size = T.unsafe(nil)); end
  def indentation; end
  def method_name(name); end
  def name_and_args(name, args); end
  def name_and_params(name, params); end
  def out; end
  def prefix; end
  def preserve!(preserve: T.unsafe(nil)); end
  def preserve?; end
  def preserve_empty_line(prev, decl); end
  def put_lines(lines, leading_spaces:); end
  def puts(string = T.unsafe(nil)); end
  def write(contents); end
  def write_annotation(annotations); end
  def write_comment(comment); end
  def write_decl(decl); end
  def write_def(member); end
  def write_directive(dir); end
  def write_loc_source(located); end
  def write_member(member); end
end

class RDoc::Parser::RBS < ::RDoc::Parser
  def scan; end
end
