# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `psych` gem.
# Please instead update this file by running `bin/tapioca gem psych`.

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  def to_yaml(options = T.unsafe(nil)); end

  class << self
    def yaml_tag(url); end
  end
end

module Psych
  class << self
    def add_builtin_type(type_tag, &block); end
    def add_domain_type(domain, type_tag, &block); end
    def add_tag(tag, klass); end
    def config; end
    def domain_types; end
    def domain_types=(value); end
    def dump(o, io = T.unsafe(nil), options = T.unsafe(nil)); end
    def dump_stream(*objects); end
    def dump_tags; end
    def dump_tags=(value); end
    def load(yaml, permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end
    def load_file(filename, **kwargs); end
    def load_stream(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), **kwargs); end
    def load_tags; end
    def load_tags=(value); end
    def parse(yaml, filename: T.unsafe(nil)); end
    def parse_file(filename, fallback: T.unsafe(nil)); end
    def parse_stream(yaml, filename: T.unsafe(nil), &block); end
    def parser; end
    def remove_type(type_tag); end
    def safe_dump(o, io = T.unsafe(nil), options = T.unsafe(nil)); end
    def safe_load(yaml, permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end
    def safe_load_file(filename, **kwargs); end
    def to_json(object); end
    def unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end
    def unsafe_load_file(filename, **kwargs); end
  end
end

class Psych::AliasesNotEnabled < ::Psych::BadAlias
  def initialize; end
end

class Psych::AnchorNotDefined < ::Psych::BadAlias
  def initialize(anchor_name); end
end

class Psych::ClassLoader
  def initialize; end

  def big_decimal; end
  def complex; end
  def date; end
  def date_time; end
  def exception; end
  def load(klassname); end
  def object; end
  def psych_omap; end
  def psych_set; end
  def range; end
  def rational; end
  def regexp; end
  def struct; end
  def symbol; end
  def symbolize(sym); end

  private

  def find(klassname); end
  def resolve(klassname); end
end

class Psych::ClassLoader::Restricted < ::Psych::ClassLoader
  def initialize(classes, symbols); end

  def symbolize(sym); end

  private

  def find(klassname); end
end

class Psych::Coder
  def initialize(tag); end

  def [](k); end
  def []=(k, v); end
  def add(k, v); end
  def implicit; end
  def implicit=(_arg0); end
  def map(tag = T.unsafe(nil), style = T.unsafe(nil)); end
  def map=(map); end
  def object; end
  def object=(_arg0); end
  def represent_map(tag, map); end
  def represent_object(tag, obj); end
  def represent_scalar(tag, value); end
  def represent_seq(tag, list); end
  def scalar(*args); end
  def scalar=(value); end
  def seq; end
  def seq=(list); end
  def style; end
  def style=(_arg0); end
  def tag; end
  def tag=(_arg0); end
  def type; end
end

class Psych::DisallowedClass < ::Psych::Exception
  def initialize(action, klass_name); end
end

class Psych::Handler
  def alias(anchor); end
  def empty; end
  def end_document(implicit); end
  def end_mapping; end
  def end_sequence; end
  def end_stream; end
  def event_location(start_line, start_column, end_line, end_column); end
  def scalar(value, anchor, tag, plain, quoted, style); end
  def start_document(version, tag_directives, implicit); end
  def start_mapping(anchor, tag, implicit, style); end
  def start_sequence(anchor, tag, implicit, style); end
  def start_stream(encoding); end
  def streaming?; end
end

class Psych::Handler::DumperOptions
  def initialize; end

  def canonical; end
  def canonical=(_arg0); end
  def indentation; end
  def indentation=(_arg0); end
  def line_width; end
  def line_width=(_arg0); end
end

class Psych::JSON::Stream < ::Psych::Visitors::JSONTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

class Psych::Parser
  def initialize(handler = T.unsafe(nil)); end

  def external_encoding=(_arg0); end
  def handler; end
  def handler=(_arg0); end
  def parse(yaml, path = T.unsafe(nil)); end
end

class Psych::ScalarScanner
  def initialize(class_loader, strict_integer: T.unsafe(nil)); end

  def class_loader; end
  def parse_int(string); end
  def parse_time(string); end
  def tokenize(string); end
end

Psych::ScalarScanner::INTEGER_LEGACY = T.let(T.unsafe(nil), Regexp)
Psych::ScalarScanner::INTEGER_STRICT = T.let(T.unsafe(nil), Regexp)

class Psych::Stream < ::Psych::Visitors::YAMLTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

class Psych::Stream::Emitter < ::Psych::Emitter
  def end_document(implicit_end = T.unsafe(nil)); end
  def streaming?; end
end

module Psych::Streaming
  def start(encoding = T.unsafe(nil)); end

  private

  def register(target, obj); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

class Psych::SyntaxError < ::Psych::Exception
  def initialize(file, line, col, offset, problem, context); end

  def column; end
  def context; end
  def file; end
  def line; end
  def offset; end
  def problem; end
end

class Psych::TreeBuilder < ::Psych::Handler
  def initialize; end

  def alias(anchor); end
  def end_document(implicit_end = T.unsafe(nil)); end
  def end_mapping; end
  def end_sequence; end
  def end_stream; end
  def event_location(start_line, start_column, end_line, end_column); end
  def root; end
  def scalar(value, anchor, tag, plain, quoted, style); end
  def start_document(version, tag_directives, implicit); end
  def start_mapping(anchor, tag, implicit, style); end
  def start_sequence(anchor, tag, implicit, style); end
  def start_stream(encoding); end

  private

  def pop; end
  def push(value); end
  def set_end_location(node); end
  def set_location(node); end
  def set_start_location(node); end
end

Psych::VERSION = T.let(T.unsafe(nil), String)

class Psych::Visitors::DepthFirst < ::Psych::Visitors::Visitor
  def initialize(block); end

  private

  def nary(o); end
  def terminal(o); end
  def visit_Psych_Nodes_Alias(o); end
  def visit_Psych_Nodes_Document(o); end
  def visit_Psych_Nodes_Mapping(o); end
  def visit_Psych_Nodes_Scalar(o); end
  def visit_Psych_Nodes_Sequence(o); end
  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::RestrictedYAMLTree < ::Psych::Visitors::YAMLTree
  def initialize(emitter, ss, options); end

  def accept(target); end
  def visit_Symbol(sym); end
end

Psych::Visitors::RestrictedYAMLTree::DEFAULT_PERMITTED_CLASSES = T.let(T.unsafe(nil), Hash)

class Psych::Visitors::ToRuby < ::Psych::Visitors::Visitor
  def initialize(ss, class_loader, symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end

  def accept(target); end
  def class_loader; end
  def visit_Psych_Nodes_Alias(o); end
  def visit_Psych_Nodes_Document(o); end
  def visit_Psych_Nodes_Mapping(o); end
  def visit_Psych_Nodes_Scalar(o); end
  def visit_Psych_Nodes_Sequence(o); end
  def visit_Psych_Nodes_Stream(o); end

  private

  def deduplicate(key); end
  def deserialize(o); end
  def init_with(o, h, node); end
  def merge_key(hash, key, val); end
  def register(node, object); end
  def register_empty(object); end
  def resolve_class(klassname); end
  def revive(klass, node); end
  def revive_hash(hash, o, tagged = T.unsafe(nil)); end

  class << self
    def create(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end
  end
end

class Psych::Visitors::Visitor
  def accept(target); end

  private

  def dispatch; end
  def visit(target); end

  class << self
    def dispatch_cache; end
  end
end

class Psych::Visitors::YAMLTree < ::Psych::Visitors::Visitor
  def initialize(emitter, ss, options); end

  def <<(object); end
  def accept(target); end
  def finish; end
  def finished; end
  def finished?; end
  def push(object); end
  def start(encoding = T.unsafe(nil)); end
  def started; end
  def started?; end
  def tree; end
  def visit_Array(o); end
  def visit_BasicObject(o); end
  def visit_BigDecimal(o); end
  def visit_Class(o); end
  def visit_Complex(o); end
  def visit_Date(o); end
  def visit_DateTime(o); end
  def visit_Delegator(o); end
  def visit_Encoding(o); end
  def visit_Enumerator(o); end
  def visit_Exception(o); end
  def visit_FalseClass(o); end
  def visit_Float(o); end
  def visit_Hash(o); end
  def visit_Integer(o); end
  def visit_Module(o); end
  def visit_NameError(o); end
  def visit_NilClass(o); end
  def visit_Object(o); end
  def visit_Psych_Omap(o); end
  def visit_Psych_Set(o); end
  def visit_Range(o); end
  def visit_Rational(o); end
  def visit_Regexp(o); end
  def visit_String(o); end
  def visit_Struct(o); end
  def visit_Symbol(o); end
  def visit_Time(o); end
  def visit_TrueClass(o); end

  private

  def binary?(string); end
  def dump_coder(o); end
  def dump_exception(o, msg); end
  def dump_ivars(target); end
  def dump_list(o); end
  def emit_coder(c, o); end
  def format_time(time, utc = T.unsafe(nil)); end
  def register(target, yaml_obj); end
  def visit_array_subclass(o); end
  def visit_hash_subclass(o); end

  class << self
    def create(options = T.unsafe(nil), emitter = T.unsafe(nil)); end
  end
end

class Psych::Visitors::YAMLTree::Registrar
  def initialize; end

  def id_for(target); end
  def key?(target); end
  def node_for(target); end
  def register(target, node); end
end
