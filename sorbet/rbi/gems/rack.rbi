# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rack/all/rack.rbi
#
# rack-2.2.3

module Rack
  def self.release; end
  def self.version; end
end
module Rack::Auth
end
module Rack::Auth::Digest
end
module Rack::Session
end
class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end
  def key_space_limit; end
  def make_params; end
  def new_depth_limit(param_depth_limit); end
  def new_space_limit(key_space_limit); end
  def normalize_params(params, name, v, depth); end
  def param_depth_limit; end
  def params_hash_has_key?(hash, key); end
  def params_hash_type?(obj); end
  def parse_nested_query(qs, d = nil); end
  def parse_query(qs, d = nil, &unescaper); end
  def self.make_default(key_space_limit, param_depth_limit); end
  def unescape(s); end
end
class Rack::QueryParser::ParameterTypeError < TypeError
end
class Rack::QueryParser::InvalidParameterError < ArgumentError
end
class Rack::QueryParser::Params
  def [](key); end
  def []=(key, value); end
  def initialize(limit); end
  def key?(key); end
  def to_h; end
  def to_params_hash; end
end
module Rack::Utils
  def add_cookie_to_header(header, key, value); end
  def add_remove_cookie_to_header(header, key, value = nil); end
  def best_q_match(q_value_header, available_mimes); end
  def build_nested_query(value, prefix = nil); end
  def build_query(params); end
  def byte_ranges(env, size); end
  def clean_path_info(path_info); end
  def clock_time; end
  def delete_cookie_header!(header, key, value = nil); end
  def escape(s); end
  def escape_html(string); end
  def escape_path(s); end
  def get_byte_ranges(http_range, size); end
  def make_delete_cookie_header(header, key, value); end
  def parse_cookies(env); end
  def parse_cookies_header(header); end
  def parse_nested_query(qs, d = nil); end
  def parse_query(qs, d = nil, &unescaper); end
  def q_values(q_value_header); end
  def rfc2109(time); end
  def rfc2822(time); end
  def secure_compare(a, b); end
  def select_best_encoding(available_encodings, accept_encoding); end
  def self.add_cookie_to_header(header, key, value); end
  def self.add_remove_cookie_to_header(header, key, value = nil); end
  def self.best_q_match(q_value_header, available_mimes); end
  def self.build_nested_query(value, prefix = nil); end
  def self.build_query(params); end
  def self.byte_ranges(env, size); end
  def self.clean_path_info(path_info); end
  def self.clock_time; end
  def self.default_query_parser; end
  def self.default_query_parser=(arg0); end
  def self.delete_cookie_header!(header, key, value = nil); end
  def self.escape(s); end
  def self.escape_html(string); end
  def self.escape_path(s); end
  def self.get_byte_ranges(http_range, size); end
  def self.key_space_limit; end
  def self.key_space_limit=(v); end
  def self.make_delete_cookie_header(header, key, value); end
  def self.multipart_part_limit; end
  def self.multipart_part_limit=(arg0); end
  def self.param_depth_limit; end
  def self.param_depth_limit=(v); end
  def self.parse_cookies(env); end
  def self.parse_cookies_header(header); end
  def self.parse_nested_query(qs, d = nil); end
  def self.parse_query(qs, d = nil, &unescaper); end
  def self.q_values(q_value_header); end
  def self.rfc2109(time); end
  def self.rfc2822(time); end
  def self.secure_compare(a, b); end
  def self.select_best_encoding(available_encodings, accept_encoding); end
  def self.set_cookie_header!(header, key, value); end
  def self.status_code(status); end
  def self.unescape(s, encoding = nil); end
  def self.unescape_path(s); end
  def self.valid_path?(path); end
  def set_cookie_header!(header, key, value); end
  def status_code(status); end
  def unescape(s, encoding = nil); end
  def unescape_path(s); end
  def valid_path?(path); end
end
class Rack::Utils::Context
  def app; end
  def call(env); end
  def context(env, app = nil); end
  def for; end
  def initialize(app_f, app_r); end
  def recontext(app); end
end
class Rack::Utils::HeaderHash < Hash
  def [](k); end
  def []=(k, v); end
  def clear; end
  def delete(k); end
  def each; end
  def has_key?(k); end
  def include?(k); end
  def initialize(hash = nil); end
  def initialize_copy(other); end
  def key?(k); end
  def member?(k); end
  def merge!(other); end
  def merge(other); end
  def names; end
  def replace(other); end
  def self.[](headers); end
  def to_hash; end
end
class Rack::Session::SessionId
  def cookie_value; end
  def empty?; end
  def hash_sid(sid); end
  def initialize(public_id); end
  def inspect; end
  def private_id; end
  def public_id; end
  def to_s; end
end
module Rack::Session::Abstract
end
class Rack::Session::Abstract::SessionHash
  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def destroy; end
  def dig(key, *keys); end
  def each(&block); end
  def empty?; end
  def exists?; end
  def fetch(key, default = nil, &block); end
  def has_key?(key); end
  def id; end
  def id=(arg0); end
  def include?(key); end
  def initialize(store, req); end
  def inspect; end
  def key?(key); end
  def keys; end
  def load!; end
  def load_for_read!; end
  def load_for_write!; end
  def loaded?; end
  def merge!(hash); end
  def options; end
  def replace(hash); end
  def self.find(req); end
  def self.set(req, session); end
  def self.set_options(req, options); end
  def store(key, value); end
  def stringify_keys(other); end
  def to_hash; end
  def update(hash); end
  def values; end
  include Enumerable
end
class Rack::Session::Abstract::Persisted
  def call(env); end
  def commit_session(req, res); end
  def commit_session?(req, session, options); end
  def context(env, app = nil); end
  def cookie_value(data); end
  def current_session_id(req); end
  def default_options; end
  def delete_session(req, sid, options); end
  def extract_session_id(request); end
  def find_session(env, sid); end
  def force_options?(options); end
  def forced_session_update?(session, options); end
  def generate_sid(secure = nil); end
  def initialize(app, options = nil); end
  def initialize_sid; end
  def key; end
  def load_session(req); end
  def loaded_session?(session); end
  def make_request(env); end
  def prepare_session(req); end
  def security_matches?(request, options); end
  def session_class; end
  def session_exists?(req); end
  def set_cookie(request, res, cookie); end
  def sid_secure; end
  def write_session(req, sid, session, options); end
end
class Rack::Session::Abstract::PersistedSecure < Rack::Session::Abstract::Persisted
  def cookie_value(data); end
  def extract_session_id(*arg0); end
  def generate_sid(*arg0); end
  def session_class; end
end
class Rack::Session::Abstract::PersistedSecure::SecureSessionHash < Rack::Session::Abstract::SessionHash
  def [](key); end
end
class Rack::Session::Abstract::ID < Rack::Session::Abstract::Persisted
  def delete_session(req, sid, options); end
  def find_session(req, sid); end
  def self.inherited(klass); end
  def write_session(req, sid, session, options); end
end
class Rack::Chunked
  def call(env); end
  def chunkable_version?(ver); end
  def initialize(app); end
  include Rack::Utils
end
class Rack::Chunked::Body
  def close; end
  def each(&block); end
  def initialize(body); end
  def yield_trailers; end
end
class Rack::Chunked::TrailerBody < Rack::Chunked::Body
  def yield_trailers; end
end
class Rack::BodyProxy
  def close; end
  def closed?; end
  def initialize(body, &block); end
  def method_missing(method_name, *args, &block); end
  def respond_to_missing?(method_name, include_all = nil); end
end
