# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rbi` gem.
# Please instead update this file by running `bin/tapioca gem rbi`.


module RBI; end

class RBI::Arg < ::RBI::Node
  sig { params(value: ::String, loc: T.nilable(::RBI::Loc)).void }
  def initialize(value, loc: T.unsafe(nil)); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::String) }
  def to_s; end

  sig { returns(::String) }
  def value; end
end

class RBI::Attr < ::RBI::NodeWithComments
  include ::RBI::Indexable

  abstract!

  sig do
    params(
      name: ::Symbol,
      names: T::Array[::Symbol],
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).void
  end
  def initialize(name, names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { abstract.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  sig { abstract.returns(T::Array[::String]) }
  def fully_qualified_names; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.params(other: ::RBI::Node).void }
  def merge_with(other); end

  sig { returns(T::Array[::Symbol]) }
  def names; end

  sig { returns(T::Array[::RBI::Sig]) }
  def sigs; end

  sig { returns(::RBI::Visibility) }
  def visibility; end

  def visibility=(_arg0); end

  private

  sig do
    params(
      name: ::String,
      sig: T.nilable(::RBI::Sig),
      visibility: ::RBI::Visibility,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).returns(::RBI::Method)
  end
  def create_getter_method(name, sig, visibility, loc, comments); end

  sig do
    params(
      name: ::String,
      sig: T.nilable(::RBI::Sig),
      attribute_type: T.nilable(T.any(::RBI::Type, ::String)),
      visibility: ::RBI::Visibility,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).returns(::RBI::Method)
  end
  def create_setter_method(name, sig, attribute_type, visibility, loc, comments); end

  sig(:final) { returns([T.nilable(::RBI::Sig), T.nilable(T.any(::RBI::Type, ::String))]) }
  def parse_sig; end
end

class RBI::AttrAccessor < ::RBI::Attr
  sig do
    params(
      name: ::Symbol,
      names: ::Symbol,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::AttrAccessor).void)
    ).void
  end
  def initialize(name, *names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::AttrReader < ::RBI::Attr
  sig do
    params(
      name: ::Symbol,
      names: ::Symbol,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::AttrReader).void)
    ).void
  end
  def initialize(name, *names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::AttrWriter < ::RBI::Attr
  sig do
    params(
      name: ::Symbol,
      names: ::Symbol,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::AttrWriter).void)
    ).void
  end
  def initialize(name, *names, visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::RBI::Method]) }
  def convert_to_methods; end

  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::BlankLine < ::RBI::Comment
  sig { params(loc: T.nilable(::RBI::Loc)).void }
  def initialize(loc: T.unsafe(nil)); end
end

class RBI::BlockParam < ::RBI::Param
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::BlockParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::Class < ::RBI::Scope
  sig do
    params(
      name: ::String,
      superclass_name: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Class).void)
    ).void
  end
  def initialize(name, superclass_name: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(::String) }
  def fully_qualified_name; end

  sig { returns(::String) }
  def name; end

  def name=(_arg0); end

  sig { returns(T.nilable(::String)) }
  def superclass_name; end

  def superclass_name=(_arg0); end
end

class RBI::Comment < ::RBI::Node
  sig { params(text: ::String, loc: T.nilable(::RBI::Loc)).void }
  def initialize(text, loc: T.unsafe(nil)); end

  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::String) }
  def text; end

  def text=(_arg0); end
end

class RBI::ConflictTree < ::RBI::Tree
  sig { params(left_name: ::String, right_name: ::String).void }
  def initialize(left_name: T.unsafe(nil), right_name: T.unsafe(nil)); end

  sig { returns(::RBI::Tree) }
  def left; end

  sig { returns(::String) }
  def left_name; end

  def right; end
  def right_name; end
end

class RBI::Const < ::RBI::NodeWithComments
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Const).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { returns(::String) }
  def fully_qualified_name; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { returns(::String) }
  def name; end

  sig { override.returns(::String) }
  def to_s; end

  def value; end
end

class RBI::DuplicateNodeError < ::RBI::Error; end
class RBI::Error < ::StandardError; end

class RBI::Extend < ::RBI::Mixin
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      names: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Extend).void)
    ).void
  end
  def initialize(name, *names, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::File
  sig do
    params(
      strictness: T.nilable(::String),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(file: ::RBI::File).void)
    ).void
  end
  def initialize(strictness: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(node: ::RBI::Node).void }
  def <<(node); end

  sig { returns(T::Array[::RBI::Comment]) }
  def comments; end

  def comments=(_arg0); end

  sig { returns(T::Boolean) }
  def empty?; end

  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      max_line_length: T.nilable(::Integer)
    ).void
  end
  def print(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end

  sig { returns(::RBI::Tree) }
  def root; end

  def root=(_arg0); end

  sig { returns(T.nilable(::String)) }
  def strictness; end

  def strictness=(_arg0); end

  sig { params(indent: ::Integer, print_locs: T::Boolean, max_line_length: T.nilable(::Integer)).returns(::String) }
  def string(indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end
end

class RBI::Formatter
  sig do
    params(
      add_sig_templates: T::Boolean,
      group_nodes: T::Boolean,
      max_line_length: T.nilable(::Integer),
      nest_singleton_methods: T::Boolean,
      nest_non_public_members: T::Boolean,
      sort_nodes: T::Boolean
    ).void
  end
  def initialize(add_sig_templates: T.unsafe(nil), group_nodes: T.unsafe(nil), max_line_length: T.unsafe(nil), nest_singleton_methods: T.unsafe(nil), nest_non_public_members: T.unsafe(nil), sort_nodes: T.unsafe(nil)); end

  sig { params(file: ::RBI::File).void }
  def format_file(file); end

  sig { params(tree: ::RBI::Tree).void }
  def format_tree(tree); end

  sig { returns(T.nilable(::Integer)) }
  def max_line_length; end

  def max_line_length=(_arg0); end

  sig { params(file: ::RBI::File).returns(::String) }
  def print_file(file); end

  sig { params(sort_nodes: T::Boolean).returns(T::Boolean) }
  def sort_nodes=(sort_nodes); end
end

class RBI::Group < ::RBI::Tree
  sig { params(kind: ::RBI::Group::Kind).void }
  def initialize(kind); end

  sig { returns(::RBI::Group::Kind) }
  def kind; end
end

class RBI::Group::Kind < ::T::Enum
  enums do
    Attrs = new
    Consts = new
    Helpers = new
    Inits = new
    Methods = new
    MixesInClassMethods = new
    Mixins = new
    RequiredAncestors = new
    Sends = new
    SingletonClasses = new
    TEnums = new
    TStructFields = new
    TypeMembers = new
  end
end

class RBI::GroupNodesError < ::RBI::Error; end

class RBI::Helper < ::RBI::NodeWithComments
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Helper).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { returns(::String) }
  def name; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::Include < ::RBI::Mixin
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      names: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Include).void)
    ).void
  end
  def initialize(name, *names, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::Index < ::RBI::Visitor
  sig { void }
  def initialize; end

  sig { params(id: ::String).returns(T::Array[::RBI::Node]) }
  def [](id); end

  sig { params(nodes: ::RBI::Node).void }
  def index(*nodes); end

  sig { returns(T::Array[::String]) }
  def keys; end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { params(node: T.all(::RBI::Indexable, ::RBI::Node)).void }
  def index_node(node); end

  class << self
    sig { params(node: ::RBI::Node).returns(::RBI::Index) }
    def index(*node); end
  end
end

module RBI::Indexable
  interface!

  sig { abstract.returns(T::Array[::String]) }
  def index_ids; end
end

class RBI::KwArg < ::RBI::Arg
  sig { params(keyword: ::String, value: ::String, loc: T.nilable(::RBI::Loc)).void }
  def initialize(keyword, value, loc: T.unsafe(nil)); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::String) }
  def keyword; end

  sig { returns(::String) }
  def to_s; end
end

class RBI::KwOptParam < ::RBI::Param
  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::KwOptParam).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_s; end

  sig { returns(::String) }
  def value; end
end

class RBI::KwParam < ::RBI::Param
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::KwParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::KwRestParam < ::RBI::Param
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::KwRestParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::Loc
  sig do
    params(
      file: T.nilable(::String),
      begin_line: T.nilable(::Integer),
      end_line: T.nilable(::Integer),
      begin_column: T.nilable(::Integer),
      end_column: T.nilable(::Integer)
    ).void
  end
  def initialize(file: T.unsafe(nil), begin_line: T.unsafe(nil), end_line: T.unsafe(nil), begin_column: T.unsafe(nil), end_column: T.unsafe(nil)); end

  def begin_column; end

  sig { returns(T.nilable(::Integer)) }
  def begin_line; end

  def end_column; end
  def end_line; end

  sig { returns(T.nilable(::String)) }
  def file; end

  sig { returns(T.nilable(::String)) }
  def source; end

  sig { returns(::String) }
  def to_s; end

  class << self
    sig { params(file: ::String, prism_location: ::Prism::Location).returns(::RBI::Loc) }
    def from_prism(file, prism_location); end
  end
end

class RBI::MergeTree < ::RBI::Tree
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      conflicts: T::Array[::RBI::Rewriters::Merge::Conflict],
      block: T.nilable(T.proc.params(node: ::RBI::Tree).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), conflicts: T.unsafe(nil), &block); end

  sig { returns(T::Array[::RBI::Rewriters::Merge::Conflict]) }
  def conflicts; end
end

class RBI::Method < ::RBI::NodeWithComments
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      params: T::Array[::RBI::Param],
      is_singleton: T::Boolean,
      visibility: ::RBI::Visibility,
      sigs: T::Array[::RBI::Sig],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Method).void)
    ).void
  end
  def initialize(name, params: T.unsafe(nil), is_singleton: T.unsafe(nil), visibility: T.unsafe(nil), sigs: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(param: ::RBI::Param).void }
  def <<(param); end

  sig { params(name: ::String).void }
  def add_block_param(name); end

  sig { params(name: ::String, default_value: ::String).void }
  def add_kw_opt_param(name, default_value); end

  sig { params(name: ::String).void }
  def add_kw_param(name); end

  sig { params(name: ::String).void }
  def add_kw_rest_param(name); end

  sig { params(name: ::String, default_value: ::String).void }
  def add_opt_param(name, default_value); end

  sig { params(name: ::String).void }
  def add_param(name); end

  sig { params(name: ::String).void }
  def add_rest_param(name); end

  sig do
    params(
      params: T::Array[::RBI::SigParam],
      return_type: T.any(::RBI::Type, ::String),
      is_abstract: T::Boolean,
      is_override: T::Boolean,
      is_overridable: T::Boolean,
      is_final: T::Boolean,
      type_params: T::Array[::String],
      checked: T.nilable(::Symbol),
      block: T.proc.params(node: ::RBI::Sig).void
    ).void
  end
  def add_sig(params: T.unsafe(nil), return_type: T.unsafe(nil), is_abstract: T.unsafe(nil), is_override: T.unsafe(nil), is_overridable: T.unsafe(nil), is_final: T.unsafe(nil), type_params: T.unsafe(nil), checked: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { returns(::String) }
  def fully_qualified_name; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { returns(T::Boolean) }
  def is_singleton; end

  def is_singleton=(_arg0); end

  sig { override.params(other: ::RBI::Node).void }
  def merge_with(other); end

  sig { returns(::String) }
  def name; end

  def name=(_arg0); end

  sig { returns(T::Array[::RBI::Param]) }
  def params; end

  sig { returns(T::Array[::RBI::Sig]) }
  def sigs; end

  def sigs=(_arg0); end

  sig { override.returns(::String) }
  def to_s; end

  sig { returns(::RBI::Visibility) }
  def visibility; end

  def visibility=(_arg0); end
end

class RBI::MixesInClassMethods < ::RBI::Mixin
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      names: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::MixesInClassMethods).void)
    ).void
  end
  def initialize(name, *names, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::Mixin < ::RBI::NodeWithComments
  abstract!

  sig do
    params(
      name: ::String,
      names: T::Array[::String],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).void
  end
  def initialize(name, names, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { returns(T::Array[::String]) }
  def names; end
end

class RBI::Module < ::RBI::Scope
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Module).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(::String) }
  def fully_qualified_name; end

  sig { returns(::String) }
  def name; end

  def name=(_arg0); end
end

class RBI::Node
  abstract!

  sig { params(loc: T.nilable(::RBI::Loc)).void }
  def initialize(loc: T.unsafe(nil)); end

  sig { params(_other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(_other); end

  sig { void }
  def detach; end

  sig { returns(T.nilable(::RBI::Loc)) }
  def loc; end

  def loc=(_arg0); end

  sig { params(other: ::RBI::Node).void }
  def merge_with(other); end

  sig { returns(T.nilable(::RBI::ConflictTree)) }
  def parent_conflict_tree; end

  sig { returns(T.nilable(::RBI::Scope)) }
  def parent_scope; end

  sig { returns(T.nilable(::RBI::Tree)) }
  def parent_tree; end

  def parent_tree=(_arg0); end

  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      max_line_length: T.nilable(::Integer)
    ).void
  end
  def print(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end

  sig { params(node: ::RBI::Node).void }
  def replace(node); end

  sig { params(version: ::Gem::Version).returns(T::Boolean) }
  def satisfies_version?(version); end

  sig { params(indent: ::Integer, print_locs: T::Boolean, max_line_length: T.nilable(::Integer)).returns(::String) }
  def string(indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end
end

class RBI::NodeWithComments < ::RBI::Node
  abstract!

  sig { params(loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  sig { returns(T::Array[::String]) }
  def annotations; end

  sig { returns(T::Array[::RBI::Comment]) }
  def comments; end

  def comments=(_arg0); end

  sig { override.params(other: ::RBI::Node).void }
  def merge_with(other); end

  sig { returns(T::Array[::Gem::Requirement]) }
  def version_requirements; end
end

class RBI::OptParam < ::RBI::Param
  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::OptParam).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::String) }
  def value; end
end

class RBI::Param < ::RBI::NodeWithComments
  abstract!

  sig { params(name: ::String, loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  sig { returns(::String) }
  def name; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::ParseError < ::RBI::Error
  sig { params(message: ::String, location: ::RBI::Loc).void }
  def initialize(message, location); end

  sig { returns(::RBI::Loc) }
  def location; end
end

class RBI::Parser
  sig { params(path: ::String).returns(::RBI::Tree) }
  def parse_file(path); end

  sig { params(string: ::String).returns(::RBI::Tree) }
  def parse_string(string); end

  private

  sig { params(source: ::String, file: ::String).returns(::RBI::Tree) }
  def parse(source, file:); end

  class << self
    sig { params(path: ::String).returns(::RBI::Tree) }
    def parse_file(path); end

    sig { params(paths: T::Array[::String]).returns(T::Array[::RBI::Tree]) }
    def parse_files(paths); end

    sig { params(string: ::String).returns(::RBI::Tree) }
    def parse_string(string); end

    sig { params(strings: T::Array[::String]).returns(T::Array[::RBI::Tree]) }
    def parse_strings(strings); end
  end
end

class RBI::Parser::SigBuilder < ::RBI::Parser::Visitor
  sig { params(content: ::String, file: ::String).void }
  def initialize(content, file:); end

  sig { returns(::RBI::Sig) }
  def current; end

  sig { override.params(node: ::Prism::AssocNode).void }
  def visit_assoc_node(node); end

  sig { override.params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end
end

class RBI::Parser::TreeBuilder < ::RBI::Parser::Visitor
  sig { params(source: ::String, comments: T::Array[::Prism::Comment], file: ::String).void }
  def initialize(source, comments:, file:); end

  sig { returns(T.nilable(::Prism::Node)) }
  def last_node; end

  sig { returns(::RBI::Tree) }
  def tree; end

  sig { params(node: ::Prism::CallNode).void }
  def visit_call_node(node); end

  sig { override.params(node: ::Prism::ClassNode).void }
  def visit_class_node(node); end

  sig { params(node: T.any(::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode)).void }
  def visit_constant_assign(node); end

  sig { override.params(node: ::Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  sig { override.params(node: ::Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  sig { override.params(node: ::Prism::DefNode).void }
  def visit_def_node(node); end

  sig { override.params(node: ::Prism::ModuleNode).void }
  def visit_module_node(node); end

  sig { override.params(node: ::Prism::ProgramNode).void }
  def visit_program_node(node); end

  sig { override.params(node: ::Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  private

  sig { params(node: ::Prism::Node).void }
  def collect_dangling_comments(node); end

  sig { void }
  def collect_orphan_comments; end

  sig { returns(::RBI::Tree) }
  def current_scope; end

  sig { returns(T::Array[::RBI::Sig]) }
  def current_sigs; end

  sig { params(sigs: T::Array[::RBI::Sig]).returns(T::Array[::RBI::Comment]) }
  def detach_comments_from_sigs(sigs); end

  sig { params(node: ::Prism::Node).returns(T::Array[::RBI::Comment]) }
  def node_comments(node); end

  sig { params(node: ::Prism::Comment).returns(::RBI::Comment) }
  def parse_comment(node); end

  sig { params(node: T.nilable(::Prism::Node)).returns(T::Array[::RBI::Param]) }
  def parse_params(node); end

  sig { params(node: T.nilable(::Prism::Node)).returns(T::Array[::RBI::Arg]) }
  def parse_send_args(node); end

  sig { params(node: ::Prism::CallNode).returns(::RBI::Sig) }
  def parse_sig(node); end

  sig do
    params(
      node: T.any(::Prism::ConstantPathWriteNode, ::Prism::ConstantWriteNode)
    ).returns(T.nilable(::RBI::Struct))
  end
  def parse_struct(node); end

  sig { params(send: ::Prism::CallNode).void }
  def parse_tstruct_field(send); end

  sig { params(name: ::String, node: ::Prism::Node).returns(::RBI::Visibility) }
  def parse_visibility(name, node); end

  sig { void }
  def separate_header_comments; end

  sig { void }
  def set_root_tree_loc; end

  sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
  def type_variable_definition?(node); end
end

class RBI::Parser::Visitor < ::Prism::Visitor
  sig { params(source: ::String, file: ::String).void }
  def initialize(source, file:); end

  private

  sig { params(node: ::Prism::Node).returns(::RBI::Loc) }
  def node_loc(node); end

  sig { params(node: T.nilable(::Prism::Node)).returns(T.nilable(::String)) }
  def node_string(node); end

  sig { params(node: ::Prism::Node).returns(::String) }
  def node_string!(node); end
end

class RBI::Printer < ::RBI::Visitor
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      indent: ::Integer,
      print_locs: T::Boolean,
      max_line_length: T.nilable(::Integer)
    ).void
  end
  def initialize(out: T.unsafe(nil), indent: T.unsafe(nil), print_locs: T.unsafe(nil), max_line_length: T.unsafe(nil)); end

  sig { returns(::Integer) }
  def current_indent; end

  sig { void }
  def dedent; end

  def in_visibility_group; end
  def in_visibility_group=(_arg0); end

  sig { void }
  def indent; end

  sig { returns(T.nilable(::Integer)) }
  def max_line_length; end

  sig { returns(T.nilable(::RBI::Node)) }
  def previous_node; end

  sig { params(string: ::String).void }
  def print(string); end

  sig { returns(T::Boolean) }
  def print_locs; end

  def print_locs=(_arg0); end

  sig { params(string: ::String).void }
  def printl(string); end

  sig { params(string: T.nilable(::String)).void }
  def printn(string = T.unsafe(nil)); end

  sig { params(string: T.nilable(::String)).void }
  def printt(string = T.unsafe(nil)); end

  sig { override.params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  sig { override.params(file: ::RBI::File).void }
  def visit_file(file); end

  private

  sig { params(node: ::RBI::Node).returns(T::Boolean) }
  def oneline?(node); end

  sig { params(node: ::RBI::Node).void }
  def print_blank_line_before(node); end

  sig { params(node: ::RBI::Node).void }
  def print_loc(node); end

  sig { params(node: ::RBI::Param, last: T::Boolean).void }
  def print_param_comment_leading_space(node, last:); end

  sig { params(node: ::RBI::Sig).void }
  def print_sig_as_block(node); end

  sig { params(node: ::RBI::Sig).void }
  def print_sig_as_line(node); end

  sig { params(node: ::RBI::SigParam, last: T::Boolean).void }
  def print_sig_param_comment_leading_space(node, last:); end

  sig { params(node: ::RBI::Sig).returns(T::Array[::String]) }
  def sig_modifiers(node); end

  sig { override.params(node: ::RBI::Arg).void }
  def visit_arg(node); end

  sig { params(node: ::RBI::Attr).void }
  def visit_attr(node); end

  sig { override.params(node: ::RBI::AttrAccessor).void }
  def visit_attr_accessor(node); end

  sig { override.params(node: ::RBI::AttrReader).void }
  def visit_attr_reader(node); end

  sig { override.params(node: ::RBI::AttrWriter).void }
  def visit_attr_writer(node); end

  sig { override.params(node: ::RBI::BlankLine).void }
  def visit_blank_line(node); end

  sig { override.params(node: ::RBI::BlockParam).void }
  def visit_block_param(node); end

  sig { override.params(node: ::RBI::Class).void }
  def visit_class(node); end

  sig { override.params(node: ::RBI::Comment).void }
  def visit_comment(node); end

  sig { override.params(node: ::RBI::ConflictTree).void }
  def visit_conflict_tree(node); end

  sig { override.params(node: ::RBI::Const).void }
  def visit_const(node); end

  sig { override.params(node: ::RBI::Extend).void }
  def visit_extend(node); end

  sig { override.params(node: ::RBI::Group).void }
  def visit_group(node); end

  sig { override.params(node: ::RBI::Helper).void }
  def visit_helper(node); end

  sig { override.params(node: ::RBI::Include).void }
  def visit_include(node); end

  sig { override.params(node: ::RBI::KwArg).void }
  def visit_kw_arg(node); end

  sig { override.params(node: ::RBI::KwOptParam).void }
  def visit_kw_opt_param(node); end

  sig { override.params(node: ::RBI::KwParam).void }
  def visit_kw_param(node); end

  sig { override.params(node: ::RBI::KwRestParam).void }
  def visit_kw_rest_param(node); end

  sig { override.params(node: ::RBI::Method).void }
  def visit_method(node); end

  sig { override.params(node: ::RBI::MixesInClassMethods).void }
  def visit_mixes_in_class_methods(node); end

  sig { params(node: ::RBI::Mixin).void }
  def visit_mixin(node); end

  sig { override.params(node: ::RBI::Module).void }
  def visit_module(node); end

  sig { override.params(node: ::RBI::OptParam).void }
  def visit_opt_param(node); end

  sig { override.params(node: ::RBI::Private).void }
  def visit_private(node); end

  sig { override.params(node: ::RBI::Protected).void }
  def visit_protected(node); end

  sig { override.params(node: ::RBI::Public).void }
  def visit_public(node); end

  sig { override.params(node: ::RBI::ReqParam).void }
  def visit_req_param(node); end

  sig { override.params(node: ::RBI::RequiresAncestor).void }
  def visit_requires_ancestor(node); end

  sig { override.params(node: ::RBI::RestParam).void }
  def visit_rest_param(node); end

  sig { params(node: ::RBI::Scope).void }
  def visit_scope(node); end

  sig { params(node: ::RBI::Scope).void }
  def visit_scope_body(node); end

  sig { override.params(node: ::RBI::ScopeConflict).void }
  def visit_scope_conflict(node); end

  sig { params(node: ::RBI::Scope).void }
  def visit_scope_header(node); end

  sig { override.params(node: ::RBI::Send).void }
  def visit_send(node); end

  sig { override.params(node: ::RBI::Sig).void }
  def visit_sig(node); end

  sig { override.params(node: ::RBI::SigParam).void }
  def visit_sig_param(node); end

  sig { override.params(node: ::RBI::SingletonClass).void }
  def visit_singleton_class(node); end

  sig { override.params(node: ::RBI::Struct).void }
  def visit_struct(node); end

  sig { params(node: ::RBI::TStructField).void }
  def visit_t_struct_field(node); end

  sig { override.params(node: ::RBI::TEnum).void }
  def visit_tenum(node); end

  sig { override.params(node: ::RBI::TEnumBlock).void }
  def visit_tenum_block(node); end

  sig { override.params(node: ::RBI::Tree).void }
  def visit_tree(node); end

  sig { override.params(node: ::RBI::TStruct).void }
  def visit_tstruct(node); end

  sig { override.params(node: ::RBI::TStructConst).void }
  def visit_tstruct_const(node); end

  sig { override.params(node: ::RBI::TStructProp).void }
  def visit_tstruct_prop(node); end

  sig { override.params(node: ::RBI::TypeMember).void }
  def visit_type_member(node); end

  sig { params(node: ::RBI::Visibility).void }
  def visit_visibility(node); end

  sig { override.params(node: ::RBI::VisibilityGroup).void }
  def visit_visibility_group(node); end
end

class RBI::PrinterError < ::RBI::Error; end

class RBI::Private < ::RBI::Visibility
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Private).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

class RBI::Protected < ::RBI::Visibility
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Protected).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

class RBI::Public < ::RBI::Visibility
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Public).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

class RBI::ReplaceNodeError < ::RBI::Error; end

class RBI::ReqParam < ::RBI::Param
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::ReqParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end
end

class RBI::RequiresAncestor < ::RBI::NodeWithComments
  include ::RBI::Indexable

  sig { params(name: ::String, loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { returns(::String) }
  def name; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::RestParam < ::RBI::Param
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::RestParam).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_s; end
end

module RBI::Rewriters; end

class RBI::Rewriters::AddSigTemplates < ::RBI::Visitor
  sig { params(with_todo_comment: T::Boolean).void }
  def initialize(with_todo_comment: T.unsafe(nil)); end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { params(attr: ::RBI::Attr).void }
  def add_attr_sig(attr); end

  sig { params(method: ::RBI::Method).void }
  def add_method_sig(method); end

  sig { params(node: ::RBI::NodeWithComments).void }
  def add_todo_comment(node); end
end

class RBI::Rewriters::Annotate < ::RBI::Visitor
  sig { params(annotation: ::String, annotate_scopes: T::Boolean, annotate_properties: T::Boolean).void }
  def initialize(annotation, annotate_scopes: T.unsafe(nil), annotate_properties: T.unsafe(nil)); end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { params(node: ::RBI::NodeWithComments).void }
  def annotate_node(node); end

  sig { params(node: ::RBI::Node).returns(T::Boolean) }
  def root?(node); end
end

class RBI::Rewriters::AttrToMethods < ::RBI::Visitor
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { params(node: ::RBI::Node, with: T::Array[::RBI::Node]).void }
  def replace(node, with:); end
end

class RBI::Rewriters::Deannotate < ::RBI::Visitor
  sig { params(annotation: ::String).void }
  def initialize(annotation); end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { params(node: ::RBI::NodeWithComments).void }
  def deannotate_node(node); end
end

class RBI::Rewriters::FilterVersions < ::RBI::Visitor
  sig { params(version: ::Gem::Version).void }
  def initialize(version); end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  class << self
    sig { params(tree: ::RBI::Tree, version: ::Gem::Version).void }
    def filter(tree, version); end
  end
end

RBI::Rewriters::FilterVersions::VERSION_PREFIX = T.let(T.unsafe(nil), String)

class RBI::Rewriters::FlattenSingletonMethods < ::RBI::Visitor
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

class RBI::Rewriters::FlattenVisibilities < ::RBI::Visitor
  sig { void }
  def initialize; end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

class RBI::Rewriters::GroupNodes < ::RBI::Visitor
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { params(node: ::RBI::Node).returns(::RBI::Group::Kind) }
  def group_kind(node); end
end

class RBI::Rewriters::Merge
  sig { params(left_name: ::String, right_name: ::String, keep: ::RBI::Rewriters::Merge::Keep).void }
  def initialize(left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end

  sig { params(tree: ::RBI::Tree).void }
  def merge(tree); end

  sig { returns(::RBI::MergeTree) }
  def tree; end

  class << self
    sig do
      params(
        left: ::RBI::Tree,
        right: ::RBI::Tree,
        left_name: ::String,
        right_name: ::String,
        keep: ::RBI::Rewriters::Merge::Keep
      ).returns(::RBI::MergeTree)
    end
    def merge_trees(left, right, left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end
  end
end

class RBI::Rewriters::Merge::Conflict < ::T::Struct
  const :left, ::RBI::Node
  const :right, ::RBI::Node
  const :left_name, ::String
  const :right_name, ::String

  sig { returns(::String) }
  def to_s; end

  class << self
    def inherited(s); end
  end
end

class RBI::Rewriters::Merge::ConflictTreeMerger < ::RBI::Visitor
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  sig { override.params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  private

  sig { params(left: ::RBI::Tree, right: ::RBI::Tree).void }
  def merge_conflict_trees(left, right); end
end

class RBI::Rewriters::Merge::Keep < ::T::Enum
  enums do
    LEFT = new
    NONE = new
    RIGHT = new
  end
end

class RBI::Rewriters::Merge::TreeMerger < ::RBI::Visitor
  sig do
    params(
      output: ::RBI::Tree,
      left_name: ::String,
      right_name: ::String,
      keep: ::RBI::Rewriters::Merge::Keep
    ).void
  end
  def initialize(output, left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end

  sig { returns(T::Array[::RBI::Rewriters::Merge::Conflict]) }
  def conflicts; end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { returns(::RBI::Tree) }
  def current_scope; end

  sig { params(left: ::RBI::Scope, right: ::RBI::Scope).void }
  def make_conflict_scope(left, right); end

  sig { params(left: ::RBI::Node, right: ::RBI::Node).void }
  def make_conflict_tree(left, right); end

  sig { params(node: ::RBI::Node).returns(T.nilable(::RBI::Node)) }
  def previous_definition(node); end

  sig { params(left: ::RBI::Scope, right: ::RBI::Scope).returns(::RBI::Scope) }
  def replace_scope_header(left, right); end
end

class RBI::Rewriters::NestNonPublicMembers < ::RBI::Visitor
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

class RBI::Rewriters::NestSingletonMethods < ::RBI::Visitor
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

class RBI::Rewriters::NestTopLevelMembers < ::RBI::Visitor
  sig { void }
  def initialize; end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end
end

class RBI::Rewriters::RemoveKnownDefinitions < ::RBI::Visitor
  sig { params(index: ::RBI::Index).void }
  def initialize(index); end

  sig { returns(T::Array[::RBI::Rewriters::RemoveKnownDefinitions::Operation]) }
  def operations; end

  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  sig { params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  private

  sig { params(node: ::RBI::Node, previous: ::RBI::Node).returns(T::Boolean) }
  def can_delete_node?(node, previous); end

  sig { params(node: ::RBI::Node, previous: ::RBI::Node).void }
  def delete_node(node, previous); end

  sig { params(node: ::RBI::Indexable).returns(T.nilable(::RBI::Node)) }
  def previous_definition_for(node); end

  class << self
    sig do
      params(
        tree: ::RBI::Tree,
        index: ::RBI::Index
      ).returns([::RBI::Tree, T::Array[::RBI::Rewriters::RemoveKnownDefinitions::Operation]])
    end
    def remove(tree, index); end
  end
end

class RBI::Rewriters::RemoveKnownDefinitions::Operation < ::T::Struct
  const :deleted_node, ::RBI::Node
  const :duplicate_of, ::RBI::Node

  sig { returns(::String) }
  def to_s; end

  class << self
    def inherited(s); end
  end
end

class RBI::Rewriters::SortNodes < ::RBI::Visitor
  sig { override.params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  private

  sig { params(kind: ::RBI::Group::Kind).returns(::Integer) }
  def group_rank(kind); end

  sig { params(node: ::RBI::Node).returns(T.nilable(::String)) }
  def node_name(node); end

  sig { params(node: ::RBI::Node).returns(::Integer) }
  def node_rank(node); end

  sig { params(node: ::RBI::Node).void }
  def sort_node_names!(node); end
end

class RBI::Scope < ::RBI::Tree
  include ::RBI::Indexable

  abstract!

  sig { returns(T.self_type) }
  def dup_empty; end

  sig { abstract.returns(::String) }
  def fully_qualified_name; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::ScopeConflict < ::RBI::Tree
  sig { params(left: ::RBI::Scope, right: ::RBI::Scope, left_name: ::String, right_name: ::String).void }
  def initialize(left:, right:, left_name: T.unsafe(nil), right_name: T.unsafe(nil)); end

  sig { returns(::RBI::Scope) }
  def left; end

  sig { returns(::String) }
  def left_name; end

  def right; end
  def right_name; end
end

class RBI::Send < ::RBI::NodeWithComments
  include ::RBI::Indexable

  sig do
    params(
      method: ::String,
      args: T::Array[::RBI::Arg],
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Send).void)
    ).void
  end
  def initialize(method, args = T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(arg: ::RBI::Arg).void }
  def <<(arg); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T::Array[::RBI::Arg]) }
  def args; end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { returns(::String) }
  def method; end

  sig { returns(::String) }
  def to_s; end
end

class RBI::Sig < ::RBI::NodeWithComments
  sig do
    params(
      params: T::Array[::RBI::SigParam],
      return_type: T.any(::RBI::Type, ::String),
      is_abstract: T::Boolean,
      is_override: T::Boolean,
      is_overridable: T::Boolean,
      is_final: T::Boolean,
      type_params: T::Array[::String],
      checked: T.nilable(::Symbol),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Sig).void)
    ).void
  end
  def initialize(params: T.unsafe(nil), return_type: T.unsafe(nil), is_abstract: T.unsafe(nil), is_override: T.unsafe(nil), is_overridable: T.unsafe(nil), is_final: T.unsafe(nil), type_params: T.unsafe(nil), checked: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(param: ::RBI::SigParam).void }
  def <<(param); end

  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  sig { params(name: ::String, type: T.any(::RBI::Type, ::String)).void }
  def add_param(name, type); end

  sig { returns(T.nilable(::Symbol)) }
  def checked; end

  def checked=(_arg0); end

  sig { returns(T::Boolean) }
  def is_abstract; end

  def is_abstract=(_arg0); end
  def is_final; end
  def is_final=(_arg0); end
  def is_overridable; end
  def is_overridable=(_arg0); end
  def is_override; end
  def is_override=(_arg0); end

  sig { returns(T::Array[::RBI::SigParam]) }
  def params; end

  sig { returns(T.any(::RBI::Type, ::String)) }
  def return_type; end

  def return_type=(_arg0); end

  sig { returns(T::Array[::String]) }
  def type_params; end
end

class RBI::SigParam < ::RBI::NodeWithComments
  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::SigParam).void)
    ).void
  end
  def initialize(name, type, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::String) }
  def name; end

  sig { returns(T.any(::RBI::Type, ::String)) }
  def type; end
end

class RBI::SingletonClass < ::RBI::Scope
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::SingletonClass).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.returns(::String) }
  def fully_qualified_name; end
end

class RBI::Struct < ::RBI::Scope
  sig do
    params(
      name: ::String,
      members: T::Array[::Symbol],
      keyword_init: T::Boolean,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(struct: ::RBI::Struct).void)
    ).void
  end
  def initialize(name, members: T.unsafe(nil), keyword_init: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(::String) }
  def fully_qualified_name; end

  sig { returns(T::Boolean) }
  def keyword_init; end

  def keyword_init=(_arg0); end

  sig { returns(T::Array[::Symbol]) }
  def members; end

  def members=(_arg0); end

  sig { returns(::String) }
  def name; end

  def name=(_arg0); end
end

class RBI::TEnum < ::RBI::Class
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(klass: ::RBI::TEnum).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

class RBI::TEnumBlock < ::RBI::Scope
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TEnumBlock).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.returns(::String) }
  def fully_qualified_name; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::TStruct < ::RBI::Class
  sig do
    params(
      name: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(klass: ::RBI::TStruct).void)
    ).void
  end
  def initialize(name, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end
end

class RBI::TStructConst < ::RBI::TStructField
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      default: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TStructConst).void)
    ).void
  end
  def initialize(name, type, default: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::TStructField < ::RBI::NodeWithComments
  abstract!

  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      default: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment]
    ).void
  end
  def initialize(name, type, default: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { returns(T.nilable(::String)) }
  def default; end

  def default=(_arg0); end

  sig { abstract.returns(T::Array[::String]) }
  def fully_qualified_names; end

  sig { returns(::String) }
  def name; end

  def name=(_arg0); end

  sig { returns(T.any(::RBI::Type, ::String)) }
  def type; end

  def type=(_arg0); end
end

class RBI::TStructProp < ::RBI::TStructField
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      type: T.any(::RBI::Type, ::String),
      default: T.nilable(::String),
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TStructProp).void)
    ).void
  end
  def initialize(name, type, default: T.unsafe(nil), loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { override.params(other: ::RBI::Node).returns(T::Boolean) }
  def compatible_with?(other); end

  sig { override.returns(T::Array[::String]) }
  def fully_qualified_names; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { override.returns(::String) }
  def to_s; end
end

class RBI::Tree < ::RBI::NodeWithComments
  sig do
    params(
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Tree).void)
    ).void
  end
  def initialize(loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(node: ::RBI::Node).void }
  def <<(node); end

  sig { params(with_todo_comment: T::Boolean).void }
  def add_sig_templates!(with_todo_comment: T.unsafe(nil)); end

  sig { params(annotation: ::String, annotate_scopes: T::Boolean, annotate_properties: T::Boolean).void }
  def annotate!(annotation, annotate_scopes: T.unsafe(nil), annotate_properties: T.unsafe(nil)); end

  sig do
    params(
      name: ::String,
      superclass_name: T.nilable(::String),
      block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)
    ).returns(::RBI::Scope)
  end
  def create_class(name, superclass_name: T.unsafe(nil), &block); end

  sig { params(name: ::String, value: ::String).void }
  def create_constant(name, value:); end

  sig { params(name: ::String).void }
  def create_extend(name); end

  sig { params(name: ::String).void }
  def create_include(name); end

  sig do
    params(
      name: ::String,
      parameters: T::Array[::RBI::TypedParam],
      return_type: T.nilable(::String),
      class_method: T::Boolean,
      visibility: ::RBI::Visibility,
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::Method).void)
    ).void
  end
  def create_method(name, parameters: T.unsafe(nil), return_type: T.unsafe(nil), class_method: T.unsafe(nil), visibility: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { params(name: ::String).void }
  def create_mixes_in_class_methods(name); end

  sig { params(name: ::String, block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)).returns(::RBI::Scope) }
  def create_module(name, &block); end

  sig { params(constant: ::Module, block: T.nilable(T.proc.params(scope: ::RBI::Scope).void)).returns(::RBI::Scope) }
  def create_path(constant, &block); end

  sig do
    params(
      name: ::String,
      type: ::String,
      variance: ::Symbol,
      fixed: T.nilable(::String),
      upper: T.nilable(::String),
      lower: T.nilable(::String)
    ).void
  end
  def create_type_variable(name, type:, variance: T.unsafe(nil), fixed: T.unsafe(nil), upper: T.unsafe(nil), lower: T.unsafe(nil)); end

  sig { params(annotation: ::String).void }
  def deannotate!(annotation); end

  sig { returns(T::Boolean) }
  def empty?; end

  sig { params(version: ::Gem::Version).void }
  def filter_versions!(version); end

  sig { void }
  def flatten_singleton_methods!; end

  sig { void }
  def flatten_visibilities!; end

  sig { void }
  def group_nodes!; end

  sig { returns(::RBI::Index) }
  def index; end

  sig do
    params(
      other: ::RBI::Tree,
      left_name: ::String,
      right_name: ::String,
      keep: ::RBI::Rewriters::Merge::Keep
    ).returns(::RBI::MergeTree)
  end
  def merge(other, left_name: T.unsafe(nil), right_name: T.unsafe(nil), keep: T.unsafe(nil)); end

  sig { void }
  def nest_non_public_members!; end

  sig { void }
  def nest_singleton_methods!; end

  sig { void }
  def nest_top_level_members!; end

  sig { returns(T::Array[::RBI::Node]) }
  def nodes; end

  sig { void }
  def replace_attributes_with_methods!; end

  sig { void }
  def sort_nodes!; end

  private

  sig { params(node: ::RBI::Node).returns(::RBI::Node) }
  def create_node(node); end

  sig { returns(T::Hash[::String, ::RBI::Node]) }
  def nodes_cache; end
end

class RBI::Type
  abstract!

  sig { void }
  def initialize; end

  sig { abstract.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { params(other: ::BasicObject).returns(T::Boolean) }
  def eql?(other); end

  sig { override.returns(::Integer) }
  def hash; end

  sig { returns(::RBI::Type) }
  def nilable; end

  sig { returns(T::Boolean) }
  def nilable?; end

  sig { returns(::RBI::Type) }
  def non_nilable; end

  sig { abstract.returns(::String) }
  def to_rbi; end

  sig { override.returns(::String) }
  def to_s; end

  class << self
    sig { params(type1: ::RBI::Type, type2: ::RBI::Type, types: ::RBI::Type).returns(::RBI::Type) }
    def all(type1, type2, *types); end

    sig { params(type1: ::RBI::Type, type2: ::RBI::Type, types: ::RBI::Type).returns(::RBI::Type) }
    def any(type1, type2, *types); end

    sig { returns(::RBI::Type::Anything) }
    def anything; end

    sig { returns(::RBI::Type::AttachedClass) }
    def attached_class; end

    sig { returns(::RBI::Type::Boolean) }
    def boolean; end

    sig { params(type: ::RBI::Type::Simple, type_parameter: T.nilable(::RBI::Type)).returns(::RBI::Type::ClassOf) }
    def class_of(type, type_parameter = T.unsafe(nil)); end

    sig { params(name: ::String, params: T.any(::RBI::Type, T::Array[::RBI::Type])).returns(::RBI::Type::Generic) }
    def generic(name, *params); end

    sig { params(type: ::RBI::Type).returns(::RBI::Type) }
    def nilable(type); end

    sig { returns(::RBI::Type::NoReturn) }
    def noreturn; end

    sig { params(node: ::Prism::Node).returns(::RBI::Type) }
    def parse_node(node); end

    sig { params(string: ::String).returns(::RBI::Type) }
    def parse_string(string); end

    sig { returns(::RBI::Type::Proc) }
    def proc; end

    sig { returns(::RBI::Type::SelfType) }
    def self_type; end

    sig { params(types: T::Hash[T.any(::String, ::Symbol), ::RBI::Type]).returns(::RBI::Type::Shape) }
    def shape(types = T.unsafe(nil)); end

    sig { params(name: ::String).returns(::RBI::Type::Simple) }
    def simple(name); end

    sig { params(type: ::RBI::Type).returns(::RBI::Type::Class) }
    def t_class(type); end

    sig { params(types: T.any(::RBI::Type, T::Array[::RBI::Type])).returns(::RBI::Type::Tuple) }
    def tuple(*types); end

    sig { params(name: ::Symbol).returns(::RBI::Type::TypeParameter) }
    def type_parameter(name); end

    sig { returns(::RBI::Type::Untyped) }
    def untyped; end

    sig { returns(::RBI::Type::Void) }
    def void; end

    private

    sig { params(node: ::Prism::CallNode).returns(T::Array[::Prism::Node]) }
    def call_chain(node); end

    sig { params(node: ::Prism::CallNode, count: ::Integer).returns(T::Array[::Prism::Node]) }
    def check_arguments_at_least!(node, count); end

    sig { params(node: ::Prism::CallNode, count: ::Integer).returns(T::Array[::Prism::Node]) }
    def check_arguments_exactly!(node, count); end

    sig { params(node: ::Prism::CallNode).returns(::RBI::Type) }
    def parse_call(node); end

    sig { params(node: T.any(::Prism::ConstantPathNode, ::Prism::ConstantReadNode)).returns(::RBI::Type) }
    def parse_constant(node); end

    sig { params(node: ::Prism::CallNode).returns(::RBI::Type) }
    def parse_proc(node); end

    sig { params(node: T.any(::Prism::HashNode, ::Prism::KeywordHashNode)).returns(::RBI::Type) }
    def parse_shape(node); end

    sig { params(node: ::Prism::ArrayNode).returns(::RBI::Type) }
    def parse_tuple(node); end

    sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
    def t?(node); end

    sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
    def t_boolean?(node); end

    sig { params(node: ::Prism::ConstantPathNode).returns(T::Boolean) }
    def t_class?(node); end

    sig { params(node: T.nilable(::Prism::Node)).returns(T::Boolean) }
    def t_class_of?(node); end

    sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
    def t_proc?(node); end

    sig { params(name: ::String).returns(T::Boolean) }
    def valid_identifier?(name); end
  end
end

class RBI::Type::All < ::RBI::Type::Composite
  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Any < ::RBI::Type::Composite
  sig { returns(T::Boolean) }
  def nilable?; end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Anything < ::RBI::Type
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::AttachedClass < ::RBI::Type
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Boolean < ::RBI::Type
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Class < ::RBI::Type
  sig { params(type: ::RBI::Type).void }
  def initialize(type); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end

  sig { returns(::RBI::Type) }
  def type; end
end

class RBI::Type::ClassOf < ::RBI::Type
  sig { params(type: ::RBI::Type::Simple, type_parameter: T.nilable(::RBI::Type)).void }
  def initialize(type, type_parameter = T.unsafe(nil)); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end

  sig { returns(::RBI::Type::Simple) }
  def type; end

  sig { returns(T.nilable(::RBI::Type)) }
  def type_parameter; end
end

class RBI::Type::Composite < ::RBI::Type
  abstract!

  sig { params(types: T::Array[::RBI::Type]).void }
  def initialize(types); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T::Array[::RBI::Type]) }
  def types; end
end

class RBI::Type::Error < ::RBI::Error; end

class RBI::Type::Generic < ::RBI::Type
  sig { params(name: ::String, params: ::RBI::Type).void }
  def initialize(name, *params); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::String) }
  def name; end

  sig { returns(T::Array[::RBI::Type]) }
  def params; end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Nilable < ::RBI::Type
  sig { params(type: ::RBI::Type).void }
  def initialize(type); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end

  sig { returns(::RBI::Type) }
  def type; end
end

class RBI::Type::NoReturn < ::RBI::Type
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Proc < ::RBI::Type
  sig { void }
  def initialize; end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { params(type: T.untyped).returns(T.self_type) }
  def bind(type); end

  sig { params(params: ::RBI::Type).returns(T.self_type) }
  def params(**params); end

  sig { returns(T.nilable(::RBI::Type)) }
  def proc_bind; end

  sig { returns(T::Hash[::Symbol, ::RBI::Type]) }
  def proc_params; end

  sig { returns(::RBI::Type) }
  def proc_returns; end

  sig { params(type: T.untyped).returns(T.self_type) }
  def returns(type); end

  sig { override.returns(::String) }
  def to_rbi; end

  sig { returns(T.self_type) }
  def void; end
end

class RBI::Type::SelfType < ::RBI::Type
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Shape < ::RBI::Type
  sig { params(types: T::Hash[T.any(::String, ::Symbol), ::RBI::Type]).void }
  def initialize(types); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end

  sig { returns(T::Hash[T.any(::String, ::Symbol), ::RBI::Type]) }
  def types; end
end

class RBI::Type::Simple < ::RBI::Type
  sig { params(name: ::String).void }
  def initialize(name); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::String) }
  def name; end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Tuple < ::RBI::Type
  sig { params(types: T::Array[::RBI::Type]).void }
  def initialize(types); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end

  sig { returns(T::Array[::RBI::Type]) }
  def types; end
end

class RBI::Type::TypeParameter < ::RBI::Type
  sig { params(name: ::Symbol).void }
  def initialize(name); end

  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::Symbol) }
  def name; end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Untyped < ::RBI::Type
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::Type::Visitor
  sig { params(node: ::RBI::Type).void }
  def visit(node); end

  private

  sig { params(type: ::RBI::Type::All).void }
  def visit_all(type); end

  sig { params(type: ::RBI::Type::Any).void }
  def visit_any(type); end

  sig { params(type: ::RBI::Type::Anything).void }
  def visit_anything(type); end

  sig { params(type: ::RBI::Type::AttachedClass).void }
  def visit_attached_class(type); end

  sig { params(type: ::RBI::Type::Boolean).void }
  def visit_boolean(type); end

  sig { params(type: ::RBI::Type::Class).void }
  def visit_class(type); end

  sig { params(type: ::RBI::Type::ClassOf).void }
  def visit_class_of(type); end

  sig { params(type: ::RBI::Type::Generic).void }
  def visit_generic(type); end

  sig { params(type: ::RBI::Type::Nilable).void }
  def visit_nilable(type); end

  sig { params(type: ::RBI::Type::NoReturn).void }
  def visit_no_return(type); end

  sig { params(type: ::RBI::Type::Proc).void }
  def visit_proc(type); end

  sig { params(type: ::RBI::Type::SelfType).void }
  def visit_self_type(type); end

  sig { params(type: ::RBI::Type::Shape).void }
  def visit_shape(type); end

  sig { params(type: ::RBI::Type::Simple).void }
  def visit_simple(type); end

  sig { params(type: ::RBI::Type::Tuple).void }
  def visit_tuple(type); end

  sig { params(type: ::RBI::Type::TypeParameter).void }
  def visit_type_parameter(type); end

  sig { params(type: ::RBI::Type::Untyped).void }
  def visit_untyped(type); end

  sig { params(type: ::RBI::Type::Void).void }
  def visit_void(type); end
end

class RBI::Type::Visitor::Error < ::RBI::Error; end

class RBI::Type::Void < ::RBI::Type
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(::String) }
  def to_rbi; end
end

class RBI::TypeMember < ::RBI::NodeWithComments
  include ::RBI::Indexable

  sig do
    params(
      name: ::String,
      value: ::String,
      loc: T.nilable(::RBI::Loc),
      comments: T::Array[::RBI::Comment],
      block: T.nilable(T.proc.params(node: ::RBI::TypeMember).void)
    ).void
  end
  def initialize(name, value, loc: T.unsafe(nil), comments: T.unsafe(nil), &block); end

  sig { returns(::String) }
  def fully_qualified_name; end

  sig { override.returns(T::Array[::String]) }
  def index_ids; end

  sig { returns(::String) }
  def name; end

  sig { override.returns(::String) }
  def to_s; end

  def value; end
end

class RBI::UnexpectedMultipleSigsError < ::RBI::Error
  sig { params(node: ::RBI::Node).void }
  def initialize(node); end

  sig { returns(::RBI::Node) }
  def node; end
end

class RBI::UnexpectedParserError < ::RBI::Error
  sig { params(parent_exception: ::Exception, last_location: ::RBI::Loc).void }
  def initialize(parent_exception, last_location); end

  sig { returns(::RBI::Loc) }
  def last_location; end

  sig { params(io: T.any(::IO, ::StringIO)).void }
  def print_debug(io: T.unsafe(nil)); end
end

RBI::VERSION = T.let(T.unsafe(nil), String)

class RBI::Visibility < ::RBI::NodeWithComments
  abstract!

  sig { params(visibility: ::Symbol, loc: T.nilable(::RBI::Loc), comments: T::Array[::RBI::Comment]).void }
  def initialize(visibility, loc: T.unsafe(nil), comments: T.unsafe(nil)); end

  sig { params(other: T.nilable(::Object)).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T::Boolean) }
  def private?; end

  sig { returns(T::Boolean) }
  def protected?; end

  sig { returns(T::Boolean) }
  def public?; end

  sig { returns(::Symbol) }
  def visibility; end
end

class RBI::VisibilityGroup < ::RBI::Tree
  sig { params(visibility: ::RBI::Visibility).void }
  def initialize(visibility); end

  sig { returns(::RBI::Visibility) }
  def visibility; end
end

class RBI::Visitor
  abstract!

  sig { params(node: T.nilable(::RBI::Node)).void }
  def visit(node); end

  sig { params(nodes: T::Array[::RBI::Node]).void }
  def visit_all(nodes); end

  sig { params(file: ::RBI::File).void }
  def visit_file(file); end

  private

  sig { params(node: ::RBI::Arg).void }
  def visit_arg(node); end

  sig { params(node: ::RBI::AttrAccessor).void }
  def visit_attr_accessor(node); end

  sig { params(node: ::RBI::AttrReader).void }
  def visit_attr_reader(node); end

  sig { params(node: ::RBI::AttrWriter).void }
  def visit_attr_writer(node); end

  sig { params(node: ::RBI::BlankLine).void }
  def visit_blank_line(node); end

  sig { params(node: ::RBI::BlockParam).void }
  def visit_block_param(node); end

  sig { params(node: ::RBI::Class).void }
  def visit_class(node); end

  sig { params(node: ::RBI::Comment).void }
  def visit_comment(node); end

  sig { params(node: ::RBI::ConflictTree).void }
  def visit_conflict_tree(node); end

  sig { params(node: ::RBI::Const).void }
  def visit_const(node); end

  sig { params(node: ::RBI::Extend).void }
  def visit_extend(node); end

  sig { params(node: ::RBI::Group).void }
  def visit_group(node); end

  sig { params(node: ::RBI::Helper).void }
  def visit_helper(node); end

  sig { params(node: ::RBI::Include).void }
  def visit_include(node); end

  sig { params(node: ::RBI::KwArg).void }
  def visit_kw_arg(node); end

  sig { params(node: ::RBI::KwOptParam).void }
  def visit_kw_opt_param(node); end

  sig { params(node: ::RBI::KwParam).void }
  def visit_kw_param(node); end

  sig { params(node: ::RBI::KwRestParam).void }
  def visit_kw_rest_param(node); end

  sig { params(node: ::RBI::Method).void }
  def visit_method(node); end

  sig { params(node: ::RBI::MixesInClassMethods).void }
  def visit_mixes_in_class_methods(node); end

  sig { params(node: ::RBI::Module).void }
  def visit_module(node); end

  sig { params(node: ::RBI::OptParam).void }
  def visit_opt_param(node); end

  sig { params(node: ::RBI::Private).void }
  def visit_private(node); end

  sig { params(node: ::RBI::Protected).void }
  def visit_protected(node); end

  sig { params(node: ::RBI::Public).void }
  def visit_public(node); end

  sig { params(node: ::RBI::ReqParam).void }
  def visit_req_param(node); end

  sig { params(node: ::RBI::RequiresAncestor).void }
  def visit_requires_ancestor(node); end

  sig { params(node: ::RBI::RestParam).void }
  def visit_rest_param(node); end

  sig { params(node: ::RBI::ScopeConflict).void }
  def visit_scope_conflict(node); end

  sig { params(node: ::RBI::Send).void }
  def visit_send(node); end

  sig { params(node: ::RBI::Sig).void }
  def visit_sig(node); end

  sig { params(node: ::RBI::SigParam).void }
  def visit_sig_param(node); end

  sig { params(node: ::RBI::SingletonClass).void }
  def visit_singleton_class(node); end

  sig { params(node: ::RBI::Struct).void }
  def visit_struct(node); end

  sig { params(node: ::RBI::TEnum).void }
  def visit_tenum(node); end

  sig { params(node: ::RBI::TEnumBlock).void }
  def visit_tenum_block(node); end

  sig { params(node: ::RBI::Tree).void }
  def visit_tree(node); end

  sig { params(node: ::RBI::TStruct).void }
  def visit_tstruct(node); end

  sig { params(node: ::RBI::TStructConst).void }
  def visit_tstruct_const(node); end

  sig { params(node: ::RBI::TStructProp).void }
  def visit_tstruct_prop(node); end

  sig { params(node: ::RBI::TypeMember).void }
  def visit_type_member(node); end

  sig { params(node: ::RBI::VisibilityGroup).void }
  def visit_visibility_group(node); end
end

class RBI::VisitorError < ::RBI::Error; end
