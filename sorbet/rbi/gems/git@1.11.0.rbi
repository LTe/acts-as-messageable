# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `git` gem.
# Please instead update this file by running `bin/tapioca gem git`.

# The Git module provides the basic functions to open a git
# reference to work with. You can open a working directory,
# open a bare repository, initialize a new repo or clone an
# existing remote repository.
#
# @author Scott Chacon (mailto:schacon@gmail.com)
#
# source://git//lib/git/author.rb#1
module Git
  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  #
  # source://git//lib/git.rb#46
  def config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  # source://git//lib/git.rb#68
  def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    #
    # source://git//lib/git.rb#100
    def bare(git_dir, options = T.unsafe(nil)); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository [URI, Pathname] The (possibly remote) repository to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param name [Pathname] The directory to clone into.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    #
    # source://git//lib/git.rb#160
    def clone(repository, name, options = T.unsafe(nil)); end

    # source://git//lib/git.rb#64
    def config; end

    # @yield [Base.config]
    #
    # source://git//lib/git.rb#60
    def configure; end

    # Export the current HEAD (or a branch, if <tt>options[:branch]</tt>
    # is specified) into the +name+ directory, then remove all traces of git from the
    # directory.
    #
    # See +clone+ for options.  Does not obey the <tt>:remote</tt> option,
    # since the .git info will be deleted anyway; always uses the default
    # remote, 'origin.'
    #
    # source://git//lib/git.rb#171
    def export(repository, name, options = T.unsafe(nil)); end

    # Same as g.config, but forces it to be at the global level
    #
    # g.config('user.name', 'Scott Chacon') # sets value
    # g.config('user.email', 'email@email.com')  # sets value
    # g.config('user.name')  # returns 'Scott Chacon'
    # g.config # returns whole config hash
    #
    # source://git//lib/git.rb#184
    def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    #
    # source://git//lib/git.rb#248
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # returns a Hash containing information about the references
    # of the target repository
    #
    # options
    #   :refs
    #
    # @param location [String|NilClass] the target repository location or nil for '.'
    # @return [{String=>Hash}] the available references of the target repo.
    #
    # source://git//lib/git.rb#260
    def ls_remote(location = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    #
    # source://git//lib/git.rb#308
    def open(working_dir, options = T.unsafe(nil)); end
  end
end

# source://git//lib/git/author.rb#2
class Git::Author
  # @return [Author] a new instance of Author
  #
  # source://git//lib/git/author.rb#5
  def initialize(author_string); end

  # Returns the value of attribute date.
  #
  # source://git//lib/git/author.rb#3
  def date; end

  # Sets the attribute date
  #
  # @param value the value to set the attribute date to.
  #
  # source://git//lib/git/author.rb#3
  def date=(_arg0); end

  # Returns the value of attribute email.
  #
  # source://git//lib/git/author.rb#3
  def email; end

  # Sets the attribute email
  #
  # @param value the value to set the attribute email to.
  #
  # source://git//lib/git/author.rb#3
  def email=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/author.rb#3
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/author.rb#3
  def name=(_arg0); end
end

# Git::Base is the main public interface for interacting with Git commands.
#
# Instead of creating a Git::Base directly, obtain a Git::Base instance by
# calling one of the follow {Git} class methods: {Git.open}, {Git.init},
# {Git.clone}, or {Git.bare}.
#
# source://git//lib/git/base/factory.rb#3
class Git::Base
  include ::Git::Base::Factory

  # Create an object that executes Git commands in the context of a working
  # copy or a bare repository.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The options for this command (see list of valid
  #   options below)
  # @return [Git::Base] an object that can execute git commands in the context
  #   of the opened working copy or bare repository
  #
  # source://git//lib/git/base.rb#88
  def initialize(options = T.unsafe(nil)); end

  # updates the repository index using the working directory content
  #
  # options:
  #   :all => true
  #
  # @example
  #   git.add
  #   git.add('path/to/file')
  #   git.add(['path/to/file1','path/to/file2'])
  #   git.add(:all => true)
  # @option options
  # @param paths [String, Array] files paths to be added (optional, default='.')
  # @param options [Hash]
  #
  # source://git//lib/git/base.rb#247
  def add(paths = T.unsafe(nil), **options); end

  # adds a new remote to this repository
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.add_remote('scotts_git', 'git://repo.or.cz/rubygit.git')
  #  @git.fetch('scotts_git')
  #  @git.merge('scotts_git/master')
  #
  # Options:
  #   :fetch => true
  #   :track => <branch_name>
  #
  # source://git//lib/git/base.rb#392
  def add_remote(name, url, opts = T.unsafe(nil)); end

  # Creates a new git tag (Git::Tag)
  #
  # @example
  #   repo.add_tag('tag_name', object_reference)
  #   repo.add_tag('tag_name', object_reference, {:options => 'here'})
  #   repo.add_tag('tag_name', {:options => 'here'})
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param name [String] The name of the tag to add
  # @param options [Hash] Opstions to pass to `git tag`.
  #   See [git-tag](https://git-scm.com/docs/git-tag) for more details.
  #
  # source://git//lib/git/base.rb#439
  def add_tag(name, *options); end

  # source://git//lib/git/base.rb#463
  def apply(file); end

  # source://git//lib/git/base.rb#469
  def apply_mail(file); end

  # creates an archive file of the given tree-ish
  #
  # source://git//lib/git/base.rb#450
  def archive(treeish, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/base.rb#568
  def cat_file(objectish); end

  # changes current working directory for a block
  # to the git working directory
  #
  # example
  #  @git.chdir do
  #    # write files
  #    @git.add
  #    @git.commit('message')
  #  end
  #
  # source://git//lib/git/base.rb#114
  def chdir; end

  # checks out a branch as the new git working directory
  #
  # source://git//lib/git/base.rb#328
  def checkout(branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # checks out an old version of a file
  #
  # source://git//lib/git/base.rb#333
  def checkout_file(version, file); end

  # source://git//lib/git/base.rb#507
  def checkout_index(opts = T.unsafe(nil)); end

  # cleans the working directory
  #
  # options:
  #  :force
  #  :d
  #  :ff
  #
  # source://git//lib/git/base.rb#274
  def clean(opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository
  #
  # options:
  #   :all
  #   :allow_empty
  #   :amend
  #   :author
  #
  # source://git//lib/git/base.rb#315
  def commit(message, opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository,
  # but automatically adds all modified files without having to explicitly
  # calling @git.add() on them.
  #
  # source://git//lib/git/base.rb#322
  def commit_all(message, opts = T.unsafe(nil)); end

  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.email', 'email@email.com', file: 'path/to/custom/config)  # sets value in file
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  #
  # source://git//lib/git/base.rb#125
  def config(name = T.unsafe(nil), value = T.unsafe(nil), options = T.unsafe(nil)); end

  # returns the name of the branch the working directory is currently on
  #
  # source://git//lib/git/base.rb#573
  def current_branch; end

  # deletes a tag
  #
  # source://git//lib/git/base.rb#445
  def delete_tag(name); end

  # returns the most recent tag that is reachable from a commit
  #
  # options:
  #  :all
  #  :tags
  #  :contains
  #  :debug
  #  :exact_match
  #  :dirty
  #  :abbrev
  #  :candidates
  #  :long
  #  :always
  #  :match
  #
  # source://git//lib/git/base.rb#293
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # returns a reference to the working directory
  #  @git.dir.path
  #  @git.dir.writeable?
  #
  # source://git//lib/git/base.rb#141
  def dir; end

  # iterates over the files which are unmerged
  #
  # source://git//lib/git/base.rb#363
  def each_conflict(&block); end

  # fetches changes from a remote branch - this does not modify the working directory,
  # it just gets the changes from the remote if there are any
  #
  # source://git//lib/git/base.rb#339
  def fetch(remote = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/base.rb#459
  def gc; end

  # Run a grep for 'string' on the HEAD of the git repository
  #
  # @example Limit grep's scope by calling grep() from a specific object:
  #   git.object("v2.3").grep('TODO')
  # @example Using grep results:
  #   git.grep("TODO").each do |sha, arr|
  #   puts "in blob #{sha}:"
  #   arr.each do |line_no, match_string|
  #   puts "\t line #{line_no}: '#{match_string}'"
  #   end
  #   end
  # @return [Hash<String, Array>] a hash of arrays
  #   ```Ruby
  #   {
  #   'tree-ish1' => [[line_no1, match_string1], ...],
  #   'tree-ish2' => [[line_no1, match_string1], ...],
  #   ...
  #   }
  #   ```
  #
  # source://git//lib/git/base.rb#224
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end

  # returns reference to the git index file
  #
  # source://git//lib/git/base.rb#146
  def index; end

  # returns +true+ if the branch exists
  #
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#190
  def is_branch?(branch); end

  # returns +true+ if the branch exists locally
  #
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#178
  def is_local_branch?(branch); end

  # returns +true+ if the branch exists remotely
  #
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#184
  def is_remote_branch?(branch); end

  # this is a convenience method for accessing the class that wraps all the
  # actual 'git' forked system calls.  At some point I hope to replace the Git::Lib
  # class with one that uses native methods or libgit C bindings
  #
  # source://git//lib/git/base.rb#198
  def lib; end

  # source://git//lib/git/base.rb#529
  def ls_files(location = T.unsafe(nil)); end

  # source://git//lib/git/base.rb#564
  def ls_tree(objectish); end

  # merges one or more branches into the current working branch
  #
  # you can specify more than one branch to merge by passing an array of branches
  #
  # source://git//lib/git/base.rb#358
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # pulls the given branch from the given remote into the current branch
  #
  #  @git.pull                          # pulls from origin/master
  #  @git.pull('upstream')              # pulls from upstream/master
  #  @git.pull('upstream', 'develope')  # pulls from upstream/develop
  #
  # source://git//lib/git/base.rb#373
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil)); end

  # pushes changes to a remote repository - easiest if this is a cloned repository,
  # otherwise you may have to run something like this first to setup the push parameters:
  #
  #  @git.config('remote.remote-name.push', 'refs/heads/master:refs/heads/master')
  #
  # source://git//lib/git/base.rb#348
  def push(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/base.rb#511
  def read_tree(treeish, opts = T.unsafe(nil)); end

  # returns an array of Git:Remote objects
  #
  # source://git//lib/git/base.rb#378
  def remotes; end

  # removes file(s) from the git repository
  #
  # source://git//lib/git/base.rb#252
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # removes a remote from this repository
  #
  # @git.remove_remote('scott_git')
  #
  # source://git//lib/git/base.rb#412
  def remove_remote(name); end

  # repacks the repository
  #
  # source://git//lib/git/base.rb#455
  def repack; end

  # returns reference to the git repository directory
  #  @git.dir.path
  #
  # source://git//lib/git/base.rb#152
  def repo; end

  # returns the repository size in bytes
  #
  # source://git//lib/git/base.rb#157
  def repo_size; end

  # resets the working directory to the provided commitish
  #
  # source://git//lib/git/base.rb#257
  def reset(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # resets the working directory to the commitish with '--hard'
  #
  # source://git//lib/git/base.rb#262
  def reset_hard(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # reverts the working directory to the provided commitish.
  # Accepts a range, such as comittish..HEAD
  #
  # options:
  #   :no_edit
  #
  # source://git//lib/git/base.rb#303
  def revert(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # runs git rev-parse to convert the objectish to a full sha
  #
  # @example
  #   git.revparse("HEAD^^")
  #   git.revparse('v2.4^{tree}')
  #   git.revparse('v2.4:/doc/index.html')
  #
  # source://git//lib/git/base.rb#560
  def revparse(objectish); end

  # source://git//lib/git/base.rb#167
  def set_index(index_file, check = T.unsafe(nil)); end

  # sets the url for a remote
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.set_remote_url('scotts_git', 'git://repo.or.cz/rubygit.git')
  #
  # source://git//lib/git/base.rb#403
  def set_remote_url(name, url); end

  # source://git//lib/git/base.rb#172
  def set_working(work_dir, check = T.unsafe(nil)); end

  # Shows objects
  #
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  #
  # source://git//lib/git/base.rb#478
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  # returns an array of all Git::Tag objects for this repository
  #
  # source://git//lib/git/base.rb#417
  def tags; end

  # source://git//lib/git/base.rb#524
  def update_ref(branch, commit); end

  # LOWER LEVEL INDEX OPERATIONS ##
  #
  # source://git//lib/git/base.rb#484
  def with_index(new_index); end

  # source://git//lib/git/base.rb#492
  def with_temp_index(&blk); end

  # source://git//lib/git/base.rb#544
  def with_temp_working(&blk); end

  # :yields: the Git::WorkingDirectory
  #
  # source://git//lib/git/base.rb#533
  def with_working(work_dir); end

  # source://git//lib/git/base.rb#519
  def write_and_commit_tree(opts = T.unsafe(nil)); end

  # source://git//lib/git/base.rb#515
  def write_tree; end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    #
    # source://git//lib/git/base.rb#14
    def bare(git_dir, options = T.unsafe(nil)); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository [URI, Pathname] The (possibly remote) repository to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param name [Pathname] The directory to clone into.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    #
    # source://git//lib/git/base.rb#20
    def clone(repository, name, options = T.unsafe(nil)); end

    # Returns (and initialize if needed) a Git::Config instance
    #
    # @return [Git::Config] the current config instance.
    #
    # source://git//lib/git/base.rb#29
    def config; end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    #
    # source://git//lib/git/base.rb#34
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    #
    # source://git//lib/git/base.rb#61
    def open(working_dir, options = T.unsafe(nil)); end

    private

    # Normalize options[:index]
    #
    # If options[:index] is a relative directory, convert it to an absolute
    # directory relative to the repository directory
    #
    # source://git//lib/git/base.rb#661
    def normalize_index(options); end

    # Normalize options before they are sent to Git::Base.new
    #
    # Updates the options parameter by setting appropriate values for the following keys:
    #   * options[:working_directory]
    #   * options[:repository]
    #   * options[:index]
    #
    # All three values will be set to absolute paths. An exception is that
    # :working_directory will be set to nil if bare is true.
    #
    # source://git//lib/git/base.rb#589
    def normalize_paths(options, default_working_directory: T.unsafe(nil), default_repository: T.unsafe(nil), bare: T.unsafe(nil)); end

    # Normalize options[:repository]
    #
    # If working with a bare repository, set to the first non-nil value out of:
    #   1. `options[:repository]`
    #   2. the `default` parameter
    #   3. the current working directory
    #
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:repository]`
    #   2. `.git`
    #
    # Next, if options[:repository] refers to a *file* and not a *directory*, set
    # options[:repository] to the contents of that file.  This is the case when
    # working with a submodule or a secondary working tree (created with git worktree
    # add). In these cases the repository is actually contained/nested within the
    # parent's repository directory.
    #
    # Finally, if options[:repository] is a relative path, convert it to an absolute
    # path relative to:
    #   1. the current directory if working with a bare repository or
    #   2. the working directory if NOT working with a bare repository
    #
    # source://git//lib/git/base.rb#641
    def normalize_repository(options, default:, bare: T.unsafe(nil)); end

    # Normalize options[:working_directory]
    #
    # If working with a bare repository, set to `nil`.
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:working_directory]`,
    #   2. the `default` parameter, or
    #   3. the current working directory
    #
    # Finally, if options[:working_directory] is a relative path, convert it to an absoluite
    # path relative to the current directory.
    #
    # source://git//lib/git/base.rb#608
    def normalize_working_directory(options, default:, bare: T.unsafe(nil)); end
  end
end

# source://git//lib/git/base/factory.rb#5
module Git::Base::Factory
  # @return [Git::Branch] an object for branch_name
  #
  # source://git//lib/git/base/factory.rb#8
  def branch(branch_name = T.unsafe(nil)); end

  # @return [Git::Branches] a collection of all the branches in the repository.
  #   Each branch is represented as a {Git::Branch}.
  #
  # source://git//lib/git/base/factory.rb#14
  def branches; end

  # @return [Git::Object::Commit] a commit object
  #
  # source://git//lib/git/base/factory.rb#30
  def commit_tree(tree = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Git::Diff] a Git::Diff object
  #
  # source://git//lib/git/base/factory.rb#35
  def diff(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end

  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base/factory.rb#40
  def gblob(objectish); end

  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base/factory.rb#45
  def gcommit(objectish); end

  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base/factory.rb#50
  def gtree(objectish); end

  # @return [Git::Log] a log with the specified number of commits
  #
  # source://git//lib/git/base/factory.rb#55
  def log(count = T.unsafe(nil)); end

  # Find as good common ancestors as possible for a merge
  # example: g.merge_base('master', 'some_branch', 'some_sha', octopus: true)
  #
  # @return [Array<Git::Object::Commit>] a collection of common ancestors
  #
  # source://git//lib/git/base/factory.rb#92
  def merge_base(*args); end

  # returns a Git::Object of the appropriate type
  # you can also call @git.gtree('tree'), but that's
  # just for readability.  If you call @git.gtree('HEAD') it will
  # still return a Git::Object::Commit object.
  #
  # object calls a factory method that will run a rev-parse
  # on the objectish and determine the type of the object and return
  # an appropriate object for that type
  #
  # @return [Git::Object] an instance of the appropriate type of Git::Object
  #
  # source://git//lib/git/base/factory.rb#69
  def object(objectish); end

  # @return [Git::Remote] a remote of the specified name
  #
  # source://git//lib/git/base/factory.rb#74
  def remote(remote_name = T.unsafe(nil)); end

  # @return [Git::Status] a status object
  #
  # source://git//lib/git/base/factory.rb#79
  def status; end

  # @return [Git::Object::Tag] a tag object
  #
  # source://git//lib/git/base/factory.rb#84
  def tag(tag_name); end

  # returns a Git::Worktree object for dir, commitish
  #
  # source://git//lib/git/base/factory.rb#19
  def worktree(dir, commitish = T.unsafe(nil)); end

  # returns a Git::worktrees object of all the Git::Worktrees
  # objects for this repo
  #
  # source://git//lib/git/base/factory.rb#25
  def worktrees; end
end

# source://git//lib/git/branch.rb#5
class Git::Branch < ::Git::Path
  # @return [Branch] a new instance of Branch
  #
  # source://git//lib/git/branch.rb#9
  def initialize(base, name); end

  # source://git//lib/git/branch.rb#31
  def archive(file, opts = T.unsafe(nil)); end

  # source://git//lib/git/branch.rb#26
  def checkout; end

  # @return [Boolean]
  #
  # source://git//lib/git/branch.rb#63
  def contains?(commit); end

  # source://git//lib/git/branch.rb#51
  def create; end

  # source://git//lib/git/branch.rb#59
  def current; end

  # source://git//lib/git/branch.rb#55
  def delete; end

  # Returns the value of attribute full.
  #
  # source://git//lib/git/branch.rb#7
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  #
  # source://git//lib/git/branch.rb#7
  def full=(_arg0); end

  # source://git//lib/git/branch.rb#17
  def gcommit; end

  # g.branch('new_branch').in_branch do
  #   # create new file
  #   # do other stuff
  #   return true # auto commits and switches back
  # end
  #
  # source://git//lib/git/branch.rb#40
  def in_branch(message = T.unsafe(nil)); end

  # source://git//lib/git/branch.rb#67
  def merge(branch = T.unsafe(nil), message = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/branch.rb#7
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/branch.rb#7
  def name=(_arg0); end

  # Returns the value of attribute remote.
  #
  # source://git//lib/git/branch.rb#7
  def remote; end

  # Sets the attribute remote
  #
  # @param value the value to set the attribute remote to.
  #
  # source://git//lib/git/branch.rb#7
  def remote=(_arg0); end

  # source://git//lib/git/branch.rb#22
  def stashes; end

  # source://git//lib/git/branch.rb#84
  def to_a; end

  # source://git//lib/git/branch.rb#88
  def to_s; end

  # source://git//lib/git/branch.rb#80
  def update_ref(commit); end

  private

  # source://git//lib/git/branch.rb#94
  def check_if_create; end

  # source://git//lib/git/branch.rb#98
  def determine_current; end

  # Given a full branch name return an Array containing the remote and branch names.
  #
  # Removes 'remotes' from the beggining of the name (if present).
  # Takes the second part (splittign by '/') as the remote name.
  # Takes the rest as the repo name (can also hold one or more '/').
  #
  # Example:
  #   parse_name('master') #=> [nil, 'master']
  #   parse_name('origin/master') #=> ['origin', 'master']
  #   parse_name('remotes/origin/master') #=> ['origin', 'master']
  #   parse_name('origin/master/v2') #=> ['origin', 'master/v2']
  #
  # param [String] name branch full name.
  # return [<Git::Remote,NilClass,String>] an Array containing the remote and branch names.
  #
  # source://git//lib/git/branch.rb#116
  def parse_name(name); end
end

# object that holds all the available branches
#
# source://git//lib/git/branches.rb#4
class Git::Branches
  include ::Enumerable

  # @return [Branches] a new instance of Branches
  #
  # source://git//lib/git/branches.rb#8
  def initialize(base); end

  # Returns the target branch
  #
  # Example:
  #   Given (git branch -a):
  #    master
  #    remotes/working/master
  #
  #   g.branches['master'].full #=> 'master'
  #   g.branches['working/master'].full => 'remotes/working/master'
  #   g.branches['remotes/working/master'].full => 'remotes/working/master'
  #
  # @param branch_name [#to_s] the target branch name.
  # @return [Git::Branch] the target branch.
  #
  # source://git//lib/git/branches.rb#49
  def [](branch_name); end

  # source://git//lib/git/branches.rb#32
  def each(&block); end

  # source://git//lib/git/branches.rb#18
  def local; end

  # source://git//lib/git/branches.rb#22
  def remote; end

  # array like methods
  #
  # source://git//lib/git/branches.rb#28
  def size; end

  # source://git//lib/git/branches.rb#61
  def to_s; end
end

# source://git//lib/git/config.rb#3
class Git::Config
  # @return [Config] a new instance of Config
  #
  # source://git//lib/git/config.rb#7
  def initialize; end

  # source://git//lib/git/config.rb#12
  def binary_path; end

  # Sets the attribute binary_path
  #
  # @param value the value to set the attribute binary_path to.
  #
  # source://git//lib/git/config.rb#5
  def binary_path=(_arg0); end

  # source://git//lib/git/config.rb#16
  def git_ssh; end

  # Sets the attribute git_ssh
  #
  # @param value the value to set the attribute git_ssh to.
  #
  # source://git//lib/git/config.rb#5
  def git_ssh=(_arg0); end
end

# object that holds the last X commits on given branch
#
# source://git//lib/git/diff.rb#4
class Git::Diff
  include ::Enumerable

  # @return [Diff] a new instance of Diff
  #
  # source://git//lib/git/diff.rb#7
  def initialize(base, from = T.unsafe(nil), to = T.unsafe(nil)); end

  # enumerable methods
  #
  # source://git//lib/git/diff.rb#62
  def [](key); end

  # source://git//lib/git/diff.rb#38
  def deletions; end

  # :yields: each Git::DiffFile in turn
  #
  # source://git//lib/git/diff.rb#67
  def each(&block); end

  # Returns the value of attribute from.
  #
  # source://git//lib/git/diff.rb#17
  def from; end

  # source://git//lib/git/diff.rb#43
  def insertions; end

  # source://git//lib/git/diff.rb#33
  def lines; end

  # source://git//lib/git/diff.rb#19
  def name_status; end

  # if file is provided and is writable, it will write the patch into the file
  #
  # source://git//lib/git/diff.rb#54
  def patch(file = T.unsafe(nil)); end

  # source://git//lib/git/diff.rb#23
  def path(path); end

  # source://git//lib/git/diff.rb#28
  def size; end

  # source://git//lib/git/diff.rb#48
  def stats; end

  # Returns the value of attribute to.
  #
  # source://git//lib/git/diff.rb#17
  def to; end

  # if file is provided and is writable, it will write the patch into the file
  #
  # source://git//lib/git/diff.rb#54
  def to_s(file = T.unsafe(nil)); end

  private

  # source://git//lib/git/diff.rb#103
  def cache_full; end

  # source://git//lib/git/diff.rb#117
  def cache_name_status; end

  # source://git//lib/git/diff.rb#113
  def cache_stats; end

  # source://git//lib/git/diff.rb#107
  def process_full; end

  # break up @diff_full
  #
  # source://git//lib/git/diff.rb#122
  def process_full_diff; end
end

# source://git//lib/git/diff.rb#72
class Git::Diff::DiffFile
  # @return [DiffFile] a new instance of DiffFile
  #
  # source://git//lib/git/diff.rb#77
  def initialize(base, hash); end

  # @return [Boolean]
  #
  # source://git//lib/git/diff.rb#88
  def binary?; end

  # source://git//lib/git/diff.rb#92
  def blob(type = T.unsafe(nil)); end

  # Returns the value of attribute dst.
  #
  # source://git//lib/git/diff.rb#73
  def dst; end

  # Sets the attribute dst
  #
  # @param value the value to set the attribute dst to.
  #
  # source://git//lib/git/diff.rb#73
  def dst=(_arg0); end

  # Returns the value of attribute mode.
  #
  # source://git//lib/git/diff.rb#73
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://git//lib/git/diff.rb#73
  def mode=(_arg0); end

  # Returns the value of attribute patch.
  #
  # source://git//lib/git/diff.rb#73
  def patch; end

  # Sets the attribute patch
  #
  # @param value the value to set the attribute patch to.
  #
  # source://git//lib/git/diff.rb#73
  def patch=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/diff.rb#73
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://git//lib/git/diff.rb#73
  def path=(_arg0); end

  # Returns the value of attribute src.
  #
  # source://git//lib/git/diff.rb#73
  def src; end

  # Sets the attribute src
  #
  # @param value the value to set the attribute src to.
  #
  # source://git//lib/git/diff.rb#73
  def src=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://git//lib/git/diff.rb#73
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://git//lib/git/diff.rb#73
  def type=(_arg0); end
end

# source://git//lib/git/diff.rb#75
Git::Diff::DiffFile::NIL_BLOB_REGEXP = T.let(T.unsafe(nil), Regexp)

# Method that can be used to detect and normalize string encoding
#
# source://git//lib/git/encoding_utils.rb#7
module Git::EncodingUtils
  class << self
    # source://git//lib/git/encoding_utils.rb#12
    def best_guess_encoding; end

    # source://git//lib/git/encoding_utils.rb#8
    def default_encoding; end

    # source://git//lib/git/encoding_utils.rb#17
    def detected_encoding(str); end

    # source://git//lib/git/encoding_utils.rb#21
    def encoding_options; end

    # source://git//lib/git/encoding_utils.rb#25
    def normalize_encoding(str); end
  end
end

# Represents an escaped Git path string
#
# Git commands that output paths (e.g. ls-files, diff), will escape usual
# characters in the path with backslashes in the same way C escapes control
# characters (e.g. \t for TAB, \n for LF, \\ for backslash) or bytes with values
# larger than 0x80 (e.g. octal \302\265 for "micro" in UTF-8).
#
# @example
#   Git::GitPath.new('\302\265').unescape # => "Âµ"
#
# source://git//lib/git/escaped_path.rb#14
class Git::EscapedPath
  # @return [EscapedPath] a new instance of EscapedPath
  #
  # source://git//lib/git/escaped_path.rb#31
  def initialize(path); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/escaped_path.rb#29
  def path; end

  # Convert an escaped path to an unescaped path
  #
  # source://git//lib/git/escaped_path.rb#36
  def unescape; end

  private

  # source://git//lib/git/escaped_path.rb#66
  def escaped_path_to_bytes(path); end

  # source://git//lib/git/escaped_path.rb#48
  def extract_escape(path, index); end

  # source://git//lib/git/escaped_path.rb#44
  def extract_octal(path, index); end

  # source://git//lib/git/escaped_path.rb#52
  def extract_single_char(path, index); end

  # source://git//lib/git/escaped_path.rb#56
  def next_byte(path, index); end
end

# source://git//lib/git/escaped_path.rb#15
Git::EscapedPath::UNESCAPES = T.let(T.unsafe(nil), Hash)

# source://git//lib/git/lib.rb#6
class Git::GitExecuteError < ::StandardError; end

# source://git//lib/git/object.rb#3
class Git::GitTagNameDoesNotExist < ::StandardError; end

# source://git//lib/git/index.rb#2
class Git::Index < ::Git::Path; end

# source://git//lib/git/lib.rb#9
class Git::Lib
  # Create a new Git::Lib object
  #
  # @option base
  # @option base
  # @option base
  # @param base [Git::Base, Hash] An object that passes in values for
  #   @git_work_dir, @git_dir, and @git_index_file
  # @param logger [Logger]
  # @return [Lib] a new instance of Lib
  #
  # source://git//lib/git/lib.rb#50
  def initialize(base = T.unsafe(nil), logger = T.unsafe(nil)); end

  # updates the repository index using the working directory content
  #
  #    lib.add('path/to/file')
  #    lib.add(['path/to/file1','path/to/file2'])
  #    lib.add(:all => true)
  #
  # options:
  #   :all => true
  #   :force => true
  #
  # @param paths [String, Array] files paths to be added to the repository
  # @param options [Hash]
  #
  # source://git//lib/git/lib.rb#611
  def add(paths = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#704
  def apply(patch_file); end

  # source://git//lib/git/lib.rb#710
  def apply_mail(patch_file); end

  # creates an archive file
  #
  # options
  #  :format  (zip, tar)
  #  :prefix
  #  :remote
  #  :path
  #
  # source://git//lib/git/lib.rb#976
  def archive(sha, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#402
  def branch_contains(commit, branch_name = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#398
  def branch_current; end

  # source://git//lib/git/lib.rb#755
  def branch_delete(branch); end

  # source://git//lib/git/lib.rb#751
  def branch_new(branch); end

  # source://git//lib/git/lib.rb#349
  def branches_all; end

  # source://git//lib/git/lib.rb#345
  def change_head_branch(branch_name); end

  # source://git//lib/git/lib.rb#759
  def checkout(branch, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#768
  def checkout_file(version, file); end

  # source://git//lib/git/lib.rb#959
  def checkout_index(opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#683
  def clean(opts = T.unsafe(nil)); end

  # tries to clone the given repo
  #
  # accepts options:
  #  :bare::      no working directory
  #  :branch::    name of branch to track (rather than 'master')
  #  :depth::     the number of commits back to pull
  #  :origin::    name of remote (same as remote)
  #  :path::      directory where the repo will be cloned
  #  :remote::    name of remote (rather than 'origin')
  #  :recursive:: after the clone is created, initialize all submodules within, using their default settings.
  #
  # TODO - make this work with SSH password or auth_key
  #
  # @return [Hash] the options to pass to {Git::Base.new}
  #
  # source://git//lib/git/lib.rb#98
  def clone(repository, name, opts = T.unsafe(nil)); end

  # Takes the commit message with the options and executes the commit command
  #
  # accepts options:
  #  :amend
  #  :all
  #  :allow_empty
  #  :author
  #  :date
  #  :no_verify
  #  :allow_empty_message
  #  :gpg_sign
  #
  # @param message [String] the commit message to be used
  # @param opts [Hash] the commit options to be used
  #
  # source://git//lib/git/lib.rb#654
  def commit(message, opts = T.unsafe(nil)); end

  # returns useful array of raw commit object data
  #
  # source://git//lib/git/lib.rb#221
  def commit_data(sha); end

  # source://git//lib/git/lib.rb#942
  def commit_tree(tree, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#527
  def config_get(name); end

  # source://git//lib/git/lib.rb#543
  def config_list; end

  # source://git//lib/git/lib.rb#517
  def config_remote(name); end

  # WRITE COMMANDS ##
  #
  # source://git//lib/git/lib.rb#587
  def config_set(name, value, options = T.unsafe(nil)); end

  # :yields: file, your, their
  #
  # source://git//lib/git/lib.rb#807
  def conflicts; end

  # returns the current version of git, as an Array of Fixnums.
  #
  # source://git//lib/git/lib.rb#1009
  def current_command_version; end

  # Returns most recent tag that is reachable from a commit
  #
  # accepts options:
  #  :all
  #  :tags
  #  :contains
  #  :debug
  #  :exact_match
  #  :dirty
  #  :abbrev
  #  :candidates
  #  :long
  #  :always
  #  :math
  #
  #  @param [String|NilClass] committish target commit sha or object name
  #  @param [{Symbol=>Object}] opts the given options
  #  @return [String] the tag name
  #
  # source://git//lib/git/lib.rb#151
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the working directory
  #
  # source://git//lib/git/lib.rb#474
  def diff_files; end

  # source://git//lib/git/lib.rb#430
  def diff_full(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the repository
  #
  # source://git//lib/git/lib.rb#479
  def diff_index(treeish); end

  # source://git//lib/git/lib.rb#459
  def diff_name_status(reference1 = T.unsafe(nil), reference2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#439
  def diff_stats(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#878
  def fetch(remote, opts); end

  # source://git//lib/git/lib.rb#184
  def full_log_commits(opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#337
  def full_tree(sha); end

  # source://git//lib/git/lib.rb#926
  def gc; end

  # The path to the Git repository directory.  The default is
  # `"#{git_work_dir}/.git"`.
  #
  # @return [Pathname] the Git repository directory.
  # @see [Git repository](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefrepositoryarepository)
  #
  # source://git//lib/git/lib.rb#28
  def git_dir; end

  # The Git index file used to stage changes (using `git add`) before they
  # are committed.
  #
  # @return [Pathname] the Git index file
  # @see [Git index file](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefindexaindex)
  #
  # source://git//lib/git/lib.rb#37
  def git_index_file; end

  # The path to the Git working copy.  The default is '"./.git"'.
  #
  # @return [Pathname] the path to the Git working copy.
  # @see [Git working tree](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefworkingtreeaworkingtree)
  #
  # source://git//lib/git/lib.rb#19
  def git_work_dir; end

  # source://git//lib/git/lib.rb#539
  def global_config_get(name); end

  # source://git//lib/git/lib.rb#555
  def global_config_list; end

  # source://git//lib/git/lib.rb#595
  def global_config_set(name, value); end

  # returns hash
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  #
  # source://git//lib/git/lib.rb#409
  def grep(string, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#512
  def ignored_files; end

  # creates or reinitializes the repository
  #
  # options:
  #   :bare
  #   :working_directory
  #   :initial_branch
  #
  # source://git//lib/git/lib.rb#75
  def init(opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#391
  def list_files(ref_dir); end

  # source://git//lib/git/lib.rb#174
  def log_commits(opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#483
  def ls_files(location = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#495
  def ls_remote(location = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#321
  def ls_tree(sha); end

  # @return [Boolean]
  #
  # source://git//lib/git/lib.rb#1019
  def meets_required_version?; end

  # source://git//lib/git/lib.rb#775
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#784
  def merge_base(*args); end

  # source://git//lib/git/lib.rb#333
  def mv(file1, file2); end

  # source://git//lib/git/lib.rb#208
  def namerev(string); end

  # source://git//lib/git/lib.rb#317
  def object_contents(sha, &block); end

  # source://git//lib/git/lib.rb#216
  def object_size(sha); end

  # source://git//lib/git/lib.rb#212
  def object_type(sha); end

  # source://git//lib/git/lib.rb#568
  def parse_config(file); end

  # source://git//lib/git/lib.rb#559
  def parse_config_list(lines); end

  # source://git//lib/git/lib.rb#227
  def process_commit_data(data, sha = T.unsafe(nil), indent = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#276
  def process_commit_log_data(data); end

  # source://git//lib/git/lib.rb#257
  def process_tag_data(data, name, indent = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#911
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#893
  def push(remote, branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # reads a tree into the current index file
  #
  # source://git//lib/git/lib.rb#931
  def read_tree(treeish, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#822
  def remote_add(name, url, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#841
  def remote_remove(name); end

  # source://git//lib/git/lib.rb#833
  def remote_set_url(name, url); end

  # source://git//lib/git/lib.rb#845
  def remotes; end

  # source://git//lib/git/lib.rb#626
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#922
  def repack; end

  # source://git//lib/git/lib.rb#1015
  def required_command_version; end

  # source://git//lib/git/lib.rb#676
  def reset(commit, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#121
  def return_base_opts_from_clone(clone_dir, opts); end

  # source://git//lib/git/lib.rb#693
  def revert(commitish, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#197
  def revparse(string); end

  # Shows objects
  #
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  #
  # source://git//lib/git/lib.rb#577
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#735
  def stash_apply(id = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#743
  def stash_clear; end

  # source://git//lib/git/lib.rb#747
  def stash_list; end

  # source://git//lib/git/lib.rb#730
  def stash_save(message); end

  # source://git//lib/git/lib.rb#716
  def stashes_all; end

  # source://git//lib/git/lib.rb#853
  def tag(name, *opts); end

  # source://git//lib/git/lib.rb#251
  def tag_data(name); end

  # source://git//lib/git/lib.rb#915
  def tag_sha(tag_name); end

  # source://git//lib/git/lib.rb#849
  def tags; end

  # source://git//lib/git/lib.rb#341
  def tree_depth(sha); end

  # source://git//lib/git/lib.rb#799
  def unmerged; end

  # source://git//lib/git/lib.rb#955
  def update_ref(branch, commit); end

  # source://git//lib/git/lib.rb#378
  def worktree_add(dir, commitish = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#387
  def worktree_prune; end

  # source://git//lib/git/lib.rb#383
  def worktree_remove(dir); end

  # source://git//lib/git/lib.rb#358
  def worktrees_all; end

  # source://git//lib/git/lib.rb#938
  def write_tree; end

  private

  # @raise [Git::GitExecuteError]
  #
  # source://git//lib/git/lib.rb#1078
  def command(cmd, *opts, &block); end

  # source://git//lib/git/lib.rb#1031
  def command_lines(cmd, *opts); end

  # Takes the diff command line output (as Array) and parse it into a Hash
  #
  # @param diff_command [String] the diff commadn to be used
  # @param opts [Array] the diff options to be used
  # @return [Hash] the diff as Hash
  #
  # source://git//lib/git/lib.rb#1131
  def diff_as_hash(diff_command, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1188
  def escape(s); end

  # source://git//lib/git/lib.rb#1192
  def escape_for_sh(s); end

  # source://git//lib/git/lib.rb#1196
  def escape_for_windows(s); end

  # Returns an array holding the common options for the log commands
  #
  # @param opts [Hash] the given options
  # @return [Array] the set of common options that the log command will use
  #
  # source://git//lib/git/lib.rb#1155
  def log_common_options(opts); end

  # Retrurns an array holding path options for the log commands
  #
  # @param opts [Hash] the given options
  # @return [Array] the set of path options that the log command will use
  #
  # source://git//lib/git/lib.rb#1174
  def log_path_options(opts); end

  # Takes the previously stored git's ENV variables and set them again on ENV.
  #
  # source://git//lib/git/lib.rb#1050
  def restore_git_system_env_variables; end

  # source://git//lib/git/lib.rb#1182
  def run_command(git_cmd, &block); end

  # Sets git's ENV variables to the custom values for the current instance.
  #
  # source://git//lib/git/lib.rb#1057
  def set_custom_git_env_variables; end

  # Takes the current git's system ENV variables and store them.
  #
  # source://git//lib/git/lib.rb#1042
  def store_git_system_env_variables; end

  # @return [Boolean]
  #
  # source://git//lib/git/lib.rb#1202
  def windows_platform?; end

  # Runs a block inside an environment with customized ENV variables.
  # It restores the ENV after execution.
  #
  # @param block [Proc] block to be executed within the customized environment
  #
  # source://git//lib/git/lib.rb#1068
  def with_custom_env_variables(&block); end
end

# Systen ENV variables involved in the git commands.
#
# @return [<String>] the names of the EVN variables involved in the git commands
#
# source://git//lib/git/lib.rb#1029
Git::Lib::ENV_VARIABLE_NAMES = T.let(T.unsafe(nil), Array)

# object that holds the last X commits on given branch
#
# source://git//lib/git/log.rb#4
class Git::Log
  include ::Enumerable

  # @return [Log] a new instance of Log
  #
  # source://git//lib/git/log.rb#7
  def initialize(base, count = T.unsafe(nil)); end

  # source://git//lib/git/log.rb#105
  def [](index); end

  # source://git//lib/git/log.rb#30
  def author(regex); end

  # source://git//lib/git/log.rb#66
  def between(sha1, sha2 = T.unsafe(nil)); end

  # source://git//lib/git/log.rb#72
  def cherry; end

  # source://git//lib/git/log.rb#90
  def each(&block); end

  # source://git//lib/git/log.rb#95
  def first; end

  # source://git//lib/git/log.rb#36
  def grep(regex); end

  # source://git//lib/git/log.rb#100
  def last; end

  # source://git//lib/git/log.rb#24
  def object(objectish); end

  # source://git//lib/git/log.rb#42
  def path(path); end

  # source://git//lib/git/log.rb#54
  def since(date); end

  # forces git log to run
  #
  # source://git//lib/git/log.rb#85
  def size; end

  # source://git//lib/git/log.rb#48
  def skip(num); end

  # source://git//lib/git/log.rb#78
  def to_s; end

  # source://git//lib/git/log.rb#60
  def until(date); end

  private

  # source://git//lib/git/log.rb#117
  def check_log; end

  # source://git//lib/git/log.rb#113
  def dirty_log; end

  # actually run the 'git log' command
  #
  # source://git//lib/git/log.rb#125
  def run_log; end
end

# represents a git object
#
# source://git//lib/git/object.rb#7
class Git::Object
  class << self
    # if we're calling this, we don't know what type it is yet
    # so this is our little factory method
    #
    # source://git//lib/git/object.rb#292
    def new(base, objectish, type = T.unsafe(nil), is_tag = T.unsafe(nil)); end
  end
end

# source://git//lib/git/object.rb#9
class Git::Object::AbstractObject
  # @return [AbstractObject] a new instance of AbstractObject
  #
  # source://git//lib/git/object.rb#14
  def initialize(base, objectish); end

  # creates an archive of this object (tree)
  #
  # source://git//lib/git/object.rb#67
  def archive(file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#73
  def blob?; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#75
  def commit?; end

  # Get the object's contents.
  # If no block is given, the contents are cached in memory and returned as a string.
  # If a block is given, it yields an IO object (via IO::popen) which could be used to
  # read a large file in chunks.
  #
  # Use this for large files so that they are not held in memory.
  #
  # source://git//lib/git/object.rb#37
  def contents(&block); end

  # source://git//lib/git/object.rb#45
  def contents_array; end

  # source://git//lib/git/object.rb#58
  def diff(objectish); end

  # source://git//lib/git/object.rb#53
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/object.rb#62
  def log(count = T.unsafe(nil)); end

  # Returns the value of attribute mode.
  #
  # source://git//lib/git/object.rb#10
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://git//lib/git/object.rb#10
  def mode=(_arg0); end

  # Returns the value of attribute objectish.
  #
  # source://git//lib/git/object.rb#10
  def objectish; end

  # Sets the attribute objectish
  #
  # @param value the value to set the attribute objectish to.
  #
  # source://git//lib/git/object.rb#10
  def objectish=(_arg0); end

  # source://git//lib/git/object.rb#23
  def sha; end

  # source://git//lib/git/object.rb#27
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  #
  # source://git//lib/git/object.rb#12
  def size=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#77
  def tag?; end

  # source://git//lib/git/object.rb#49
  def to_s; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#71
  def tree?; end

  # Returns the value of attribute type.
  #
  # source://git//lib/git/object.rb#10
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://git//lib/git/object.rb#10
  def type=(_arg0); end
end

# source://git//lib/git/object.rb#82
class Git::Object::Blob < ::Git::Object::AbstractObject
  # @return [Blob] a new instance of Blob
  #
  # source://git//lib/git/object.rb#84
  def initialize(base, sha, mode = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#89
  def blob?; end
end

# source://git//lib/git/object.rb#156
class Git::Object::Commit < ::Git::Object::AbstractObject
  # @return [Commit] a new instance of Commit
  #
  # source://git//lib/git/object.rb#158
  def initialize(base, sha, init = T.unsafe(nil)); end

  # git author
  #
  # source://git//lib/git/object.rb#195
  def author; end

  # source://git//lib/git/object.rb#200
  def author_date; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#228
  def commit?; end

  # git author
  #
  # source://git//lib/git/object.rb#205
  def committer; end

  # source://git//lib/git/object.rb#210
  def committer_date; end

  # source://git//lib/git/object.rb#210
  def date; end

  # source://git//lib/git/object.rb#215
  def diff_parent; end

  # source://git//lib/git/object.rb#179
  def gtree; end

  # source://git//lib/git/object.rb#170
  def message; end

  # source://git//lib/git/object.rb#175
  def name; end

  # source://git//lib/git/object.rb#184
  def parent; end

  # array of all parent commits
  #
  # source://git//lib/git/object.rb#189
  def parents; end

  # source://git//lib/git/object.rb#219
  def set_commit(data); end

  private

  # see if this object has been initialized and do so if not
  #
  # source://git//lib/git/object.rb#235
  def check_commit; end
end

# source://git//lib/git/object.rb#244
class Git::Object::Tag < ::Git::Object::AbstractObject
  # @return [Tag] a new instance of Tag
  #
  # source://git//lib/git/object.rb#247
  def initialize(base, sha, name); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#254
  def annotated?; end

  # source://git//lib/git/object.rb#258
  def message; end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/object.rb#245
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/object.rb#245
  def name=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#263
  def tag?; end

  # source://git//lib/git/object.rb#267
  def tagger; end

  private

  # source://git//lib/git/object.rb#274
  def check_tag; end
end

# source://git//lib/git/object.rb#95
class Git::Object::Tree < ::Git::Object::AbstractObject
  # @return [Tree] a new instance of Tree
  #
  # source://git//lib/git/object.rb#97
  def initialize(base, sha, mode = T.unsafe(nil)); end

  # source://git//lib/git/object.rb#108
  def blobs; end

  # source://git//lib/git/object.rb#104
  def children; end

  # source://git//lib/git/object.rb#123
  def depth; end

  # source://git//lib/git/object.rb#108
  def files; end

  # source://git//lib/git/object.rb#119
  def full_tree; end

  # source://git//lib/git/object.rb#113
  def subdirectories; end

  # source://git//lib/git/object.rb#113
  def subtrees; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#127
  def tree?; end

  # source://git//lib/git/object.rb#113
  def trees; end

  private

  # actually run the git command
  #
  # source://git//lib/git/object.rb#134
  def check_tree; end
end

# source://git//lib/git/path.rb#3
class Git::Path
  # @return [Path] a new instance of Path
  #
  # source://git//lib/git/path.rb#7
  def initialize(path, check_path = T.unsafe(nil)); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/path.rb#5
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://git//lib/git/path.rb#5
  def path=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/path.rb#17
  def readable?; end

  # source://git//lib/git/path.rb#25
  def to_s; end

  # @return [Boolean]
  #
  # source://git//lib/git/path.rb#21
  def writable?; end
end

# source://git//lib/git/remote.rb#2
class Git::Remote < ::Git::Path
  # @return [Remote] a new instance of Remote
  #
  # source://git//lib/git/remote.rb#6
  def initialize(base, name); end

  # source://git//lib/git/remote.rb#23
  def branch(branch = T.unsafe(nil)); end

  # source://git//lib/git/remote.rb#14
  def fetch(opts = T.unsafe(nil)); end

  # Returns the value of attribute fetch_opts.
  #
  # source://git//lib/git/remote.rb#4
  def fetch_opts; end

  # Sets the attribute fetch_opts
  #
  # @param value the value to set the attribute fetch_opts to.
  #
  # source://git//lib/git/remote.rb#4
  def fetch_opts=(_arg0); end

  # merge this remote locally
  #
  # source://git//lib/git/remote.rb#19
  def merge(branch = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/remote.rb#4
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/remote.rb#4
  def name=(_arg0); end

  # source://git//lib/git/remote.rb#27
  def remove; end

  # source://git//lib/git/remote.rb#31
  def to_s; end

  # Returns the value of attribute url.
  #
  # source://git//lib/git/remote.rb#4
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  #
  # source://git//lib/git/remote.rb#4
  def url=(_arg0); end
end

# source://git//lib/git/repository.rb#3
class Git::Repository < ::Git::Path; end

# source://git//lib/git/stash.rb#2
class Git::Stash
  # @return [Stash] a new instance of Stash
  #
  # source://git//lib/git/stash.rb#4
  def initialize(base, message, existing = T.unsafe(nil)); end

  # source://git//lib/git/stash.rb#18
  def message; end

  # source://git//lib/git/stash.rb#10
  def save; end

  # @return [Boolean]
  #
  # source://git//lib/git/stash.rb#14
  def saved?; end

  # source://git//lib/git/stash.rb#22
  def to_s; end
end

# object that holds all the available stashes
#
# source://git//lib/git/stashes.rb#4
class Git::Stashes
  include ::Enumerable

  # @return [Stashes] a new instance of Stashes
  #
  # source://git//lib/git/stashes.rb#7
  def initialize(base); end

  # source://git//lib/git/stashes.rb#50
  def [](index); end

  # Returns an multi-dimensional Array of elements that have been stash saved.
  # Array is based on position and name. See Example
  #
  # @example Returns Array of items that have been stashed
  #   .all - [0, "testing-stash-all"]]
  # @return [Array]
  #
  # source://git//lib/git/stashes.rb#24
  def all; end

  # source://git//lib/git/stashes.rb#33
  def apply(index = T.unsafe(nil)); end

  # source://git//lib/git/stashes.rb#37
  def clear; end

  # source://git//lib/git/stashes.rb#46
  def each(&block); end

  # source://git//lib/git/stashes.rb#28
  def save(message); end

  # source://git//lib/git/stashes.rb#42
  def size; end
end

# A class for git status
#
# source://git//lib/git/status.rb#5
class Git::Status
  include ::Enumerable

  # @return [Status] a new instance of Status
  #
  # source://git//lib/git/status.rb#8
  def initialize(base); end

  # enumerable method
  #
  # source://git//lib/git/status.rb#119
  def [](file); end

  # Returns an Enumerable containing files that have been added.
  # File path starts at git base directory
  #
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#39
  def added; end

  # Determines whether the given file has been added to the repository
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb is added.
  #   added?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#51
  def added?(file); end

  # Returns an Enumerable containing files that have changed from the
  # git base directory
  #
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#18
  def changed; end

  # Determines whether the given file has been changed.
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb has changed.
  #   changed?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#30
  def changed?(file); end

  # Returns an Enumerable containing files that have been deleted.
  # File path starts at git base directory
  #
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#60
  def deleted; end

  # Determines whether the given file has been deleted from the repository
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb is deleted.
  #   deleted?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#72
  def deleted?(file); end

  # source://git//lib/git/status.rb#123
  def each(&block); end

  # source://git//lib/git/status.rb#97
  def pretty; end

  # source://git//lib/git/status.rb#106
  def pretty_file(file); end

  # Returns an Enumerable containing files that are not tracked in git.
  # File path starts at git base directory
  #
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#81
  def untracked; end

  # Determines whether the given file has is tracked by git.
  # File path starts at git base directory
  #
  # @example Check if lib/git.rb is an untracked file.
  #   untracked?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#93
  def untracked?(file); end

  private

  # source://git//lib/git/status.rb#160
  def construct_status; end

  # source://git//lib/git/status.rb#192
  def fetch_added; end

  # source://git//lib/git/status.rb#185
  def fetch_modified; end

  # source://git//lib/git/status.rb#172
  def fetch_untracked; end
end

# subclass that does heavy lifting
#
# source://git//lib/git/status.rb#128
class Git::Status::StatusFile
  # @return [StatusFile] a new instance of StatusFile
  #
  # source://git//lib/git/status.rb#133
  def initialize(base, hash); end

  # source://git//lib/git/status.rb#145
  def blob(type = T.unsafe(nil)); end

  # Returns the value of attribute mode_index.
  #
  # source://git//lib/git/status.rb#130
  def mode_index; end

  # Sets the attribute mode_index
  #
  # @param value the value to set the attribute mode_index to.
  #
  # source://git//lib/git/status.rb#130
  def mode_index=(_arg0); end

  # Returns the value of attribute mode_repo.
  #
  # source://git//lib/git/status.rb#130
  def mode_repo; end

  # Sets the attribute mode_repo
  #
  # @param value the value to set the attribute mode_repo to.
  #
  # source://git//lib/git/status.rb#130
  def mode_repo=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/status.rb#129
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://git//lib/git/status.rb#129
  def path=(_arg0); end

  # Returns the value of attribute sha_index.
  #
  # source://git//lib/git/status.rb#131
  def sha_index; end

  # Sets the attribute sha_index
  #
  # @param value the value to set the attribute sha_index to.
  #
  # source://git//lib/git/status.rb#131
  def sha_index=(_arg0); end

  # Returns the value of attribute sha_repo.
  #
  # source://git//lib/git/status.rb#131
  def sha_repo; end

  # Sets the attribute sha_repo
  #
  # @param value the value to set the attribute sha_repo to.
  #
  # source://git//lib/git/status.rb#131
  def sha_repo=(_arg0); end

  # Returns the value of attribute stage.
  #
  # source://git//lib/git/status.rb#129
  def stage; end

  # Sets the attribute stage
  #
  # @param value the value to set the attribute stage to.
  #
  # source://git//lib/git/status.rb#129
  def stage=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://git//lib/git/status.rb#129
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://git//lib/git/status.rb#129
  def type=(_arg0); end

  # Returns the value of attribute untracked.
  #
  # source://git//lib/git/status.rb#129
  def untracked; end

  # Sets the attribute untracked
  #
  # @param value the value to set the attribute untracked to.
  #
  # source://git//lib/git/status.rb#129
  def untracked=(_arg0); end
end

# The current gem version
#
# @return [String] the current gem version.
#
# source://git//lib/git/version.rb#4
Git::VERSION = T.let(T.unsafe(nil), String)

# source://git//lib/git/working_directory.rb#2
class Git::WorkingDirectory < ::Git::Path; end

# source://git//lib/git/worktree.rb#5
class Git::Worktree < ::Git::Path
  # @return [Worktree] a new instance of Worktree
  #
  # source://git//lib/git/worktree.rb#9
  def initialize(base, dir, gcommit = T.unsafe(nil)); end

  # source://git//lib/git/worktree.rb#22
  def add; end

  # Returns the value of attribute dir.
  #
  # source://git//lib/git/worktree.rb#7
  def dir; end

  # Sets the attribute dir
  #
  # @param value the value to set the attribute dir to.
  #
  # source://git//lib/git/worktree.rb#7
  def dir=(_arg0); end

  # Returns the value of attribute full.
  #
  # source://git//lib/git/worktree.rb#7
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  #
  # source://git//lib/git/worktree.rb#7
  def full=(_arg0); end

  # Returns the value of attribute gcommit.
  #
  # source://git//lib/git/worktree.rb#17
  def gcommit; end

  # Sets the attribute gcommit
  #
  # @param value the value to set the attribute gcommit to.
  #
  # source://git//lib/git/worktree.rb#7
  def gcommit=(_arg0); end

  # source://git//lib/git/worktree.rb#26
  def remove; end

  # source://git//lib/git/worktree.rb#30
  def to_a; end

  # source://git//lib/git/worktree.rb#34
  def to_s; end
end

# object that holds all the available worktrees
#
# source://git//lib/git/worktrees.rb#3
class Git::Worktrees
  include ::Enumerable

  # @return [Worktrees] a new instance of Worktrees
  #
  # source://git//lib/git/worktrees.rb#7
  def initialize(base); end

  # source://git//lib/git/worktrees.rb#28
  def [](worktree_name); end

  # source://git//lib/git/worktrees.rb#24
  def each(&block); end

  # source://git//lib/git/worktrees.rb#43
  def prune; end

  # array like methods
  #
  # source://git//lib/git/worktrees.rb#20
  def size; end

  # source://git//lib/git/worktrees.rb#35
  def to_s; end
end
