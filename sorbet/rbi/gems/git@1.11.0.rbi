# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `git` gem.
# Please instead update this file by running `bin/tapioca gem git`.

module Git
  def config(name = T.unsafe(nil), value = T.unsafe(nil)); end
  def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  class << self
    def bare(git_dir, options = T.unsafe(nil)); end
    def clone(repository, name, options = T.unsafe(nil)); end
    def config; end
    def configure; end
    def export(repository, name, options = T.unsafe(nil)); end
    def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end
    def ls_remote(location = T.unsafe(nil), options = T.unsafe(nil)); end
    def open(working_dir, options = T.unsafe(nil)); end
  end
end

class Git::Author
  def initialize(author_string); end

  def date; end
  def date=(_arg0); end
  def email; end
  def email=(_arg0); end
  def name; end
  def name=(_arg0); end
end

class Git::Base
  include ::Git::Base::Factory

  def initialize(options = T.unsafe(nil)); end

  def add(paths = T.unsafe(nil), **options); end
  def add_remote(name, url, opts = T.unsafe(nil)); end
  def add_tag(name, *options); end
  def apply(file); end
  def apply_mail(file); end
  def archive(treeish, file = T.unsafe(nil), opts = T.unsafe(nil)); end
  def cat_file(objectish); end
  def chdir; end
  def checkout(branch = T.unsafe(nil), opts = T.unsafe(nil)); end
  def checkout_file(version, file); end
  def checkout_index(opts = T.unsafe(nil)); end
  def clean(opts = T.unsafe(nil)); end
  def commit(message, opts = T.unsafe(nil)); end
  def commit_all(message, opts = T.unsafe(nil)); end
  def config(name = T.unsafe(nil), value = T.unsafe(nil), options = T.unsafe(nil)); end
  def current_branch; end
  def delete_tag(name); end
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def dir; end
  def each_conflict(&block); end
  def fetch(remote = T.unsafe(nil), opts = T.unsafe(nil)); end
  def gc; end
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def index; end
  def is_branch?(branch); end
  def is_local_branch?(branch); end
  def is_remote_branch?(branch); end
  def lib; end
  def ls_files(location = T.unsafe(nil)); end
  def ls_tree(objectish); end
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil)); end
  def push(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end
  def read_tree(treeish, opts = T.unsafe(nil)); end
  def remotes; end
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end
  def remove_remote(name); end
  def repack; end
  def repo; end
  def repo_size; end
  def reset(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def reset_hard(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def revert(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def revparse(objectish); end
  def set_index(index_file, check = T.unsafe(nil)); end
  def set_remote_url(name, url); end
  def set_working(work_dir, check = T.unsafe(nil)); end
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end
  def tags; end
  def update_ref(branch, commit); end
  def with_index(new_index); end
  def with_temp_index(&blk); end
  def with_temp_working(&blk); end
  def with_working(work_dir); end
  def write_and_commit_tree(opts = T.unsafe(nil)); end
  def write_tree; end

  class << self
    def bare(git_dir, options = T.unsafe(nil)); end
    def clone(repository, name, options = T.unsafe(nil)); end
    def config; end
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end
    def open(working_dir, options = T.unsafe(nil)); end

    private

    def normalize_index(options); end
    def normalize_paths(options, default_working_directory: T.unsafe(nil), default_repository: T.unsafe(nil), bare: T.unsafe(nil)); end
    def normalize_repository(options, default:, bare: T.unsafe(nil)); end
    def normalize_working_directory(options, default:, bare: T.unsafe(nil)); end
  end
end

module Git::Base::Factory
  def branch(branch_name = T.unsafe(nil)); end
  def branches; end
  def commit_tree(tree = T.unsafe(nil), opts = T.unsafe(nil)); end
  def diff(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end
  def gblob(objectish); end
  def gcommit(objectish); end
  def gtree(objectish); end
  def log(count = T.unsafe(nil)); end
  def merge_base(*args); end
  def object(objectish); end
  def remote(remote_name = T.unsafe(nil)); end
  def status; end
  def tag(tag_name); end
  def worktree(dir, commitish = T.unsafe(nil)); end
  def worktrees; end
end

class Git::Branch < ::Git::Path
  def initialize(base, name); end

  def archive(file, opts = T.unsafe(nil)); end
  def checkout; end
  def contains?(commit); end
  def create; end
  def current; end
  def delete; end
  def full; end
  def full=(_arg0); end
  def gcommit; end
  def in_branch(message = T.unsafe(nil)); end
  def merge(branch = T.unsafe(nil), message = T.unsafe(nil)); end
  def name; end
  def name=(_arg0); end
  def remote; end
  def remote=(_arg0); end
  def stashes; end
  def to_a; end
  def to_s; end
  def update_ref(commit); end

  private

  def check_if_create; end
  def determine_current; end
  def parse_name(name); end
end

class Git::Branches
  include ::Enumerable

  def initialize(base); end

  def [](branch_name); end
  def each(&block); end
  def local; end
  def remote; end
  def size; end
  def to_s; end
end

class Git::Config
  def initialize; end

  def binary_path; end
  def binary_path=(_arg0); end
  def git_ssh; end
  def git_ssh=(_arg0); end
end

class Git::Diff
  include ::Enumerable

  def initialize(base, from = T.unsafe(nil), to = T.unsafe(nil)); end

  def [](key); end
  def deletions; end
  def each(&block); end
  def from; end
  def insertions; end
  def lines; end
  def name_status; end
  def patch(file = T.unsafe(nil)); end
  def path(path); end
  def size; end
  def stats; end
  def to; end
  def to_s(file = T.unsafe(nil)); end

  private

  def cache_full; end
  def cache_name_status; end
  def cache_stats; end
  def process_full; end
  def process_full_diff; end
end

class Git::Diff::DiffFile
  def initialize(base, hash); end

  def binary?; end
  def blob(type = T.unsafe(nil)); end
  def dst; end
  def dst=(_arg0); end
  def mode; end
  def mode=(_arg0); end
  def patch; end
  def patch=(_arg0); end
  def path; end
  def path=(_arg0); end
  def src; end
  def src=(_arg0); end
  def type; end
  def type=(_arg0); end
end

Git::Diff::DiffFile::NIL_BLOB_REGEXP = T.let(T.unsafe(nil), Regexp)

module Git::EncodingUtils
  class << self
    def best_guess_encoding; end
    def default_encoding; end
    def detected_encoding(str); end
    def encoding_options; end
    def normalize_encoding(str); end
  end
end

class Git::EscapedPath
  def initialize(path); end

  def path; end
  def unescape; end

  private

  def escaped_path_to_bytes(path); end
  def extract_escape(path, index); end
  def extract_octal(path, index); end
  def extract_single_char(path, index); end
  def next_byte(path, index); end
end

Git::EscapedPath::UNESCAPES = T.let(T.unsafe(nil), Hash)
class Git::GitExecuteError < ::StandardError; end
class Git::GitTagNameDoesNotExist < ::StandardError; end
class Git::Index < ::Git::Path; end

class Git::Lib
  def initialize(base = T.unsafe(nil), logger = T.unsafe(nil)); end

  def add(paths = T.unsafe(nil), options = T.unsafe(nil)); end
  def apply(patch_file); end
  def apply_mail(patch_file); end
  def archive(sha, file = T.unsafe(nil), opts = T.unsafe(nil)); end
  def branch_contains(commit, branch_name = T.unsafe(nil)); end
  def branch_current; end
  def branch_delete(branch); end
  def branch_new(branch); end
  def branches_all; end
  def change_head_branch(branch_name); end
  def checkout(branch, opts = T.unsafe(nil)); end
  def checkout_file(version, file); end
  def checkout_index(opts = T.unsafe(nil)); end
  def clean(opts = T.unsafe(nil)); end
  def clone(repository, name, opts = T.unsafe(nil)); end
  def commit(message, opts = T.unsafe(nil)); end
  def commit_data(sha); end
  def commit_tree(tree, opts = T.unsafe(nil)); end
  def config_get(name); end
  def config_list; end
  def config_remote(name); end
  def config_set(name, value, options = T.unsafe(nil)); end
  def conflicts; end
  def current_command_version; end
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end
  def diff_files; end
  def diff_full(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end
  def diff_index(treeish); end
  def diff_name_status(reference1 = T.unsafe(nil), reference2 = T.unsafe(nil), opts = T.unsafe(nil)); end
  def diff_stats(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end
  def fetch(remote, opts); end
  def full_log_commits(opts = T.unsafe(nil)); end
  def full_tree(sha); end
  def gc; end
  def git_dir; end
  def git_index_file; end
  def git_work_dir; end
  def global_config_get(name); end
  def global_config_list; end
  def global_config_set(name, value); end
  def grep(string, opts = T.unsafe(nil)); end
  def ignored_files; end
  def init(opts = T.unsafe(nil)); end
  def list_files(ref_dir); end
  def log_commits(opts = T.unsafe(nil)); end
  def ls_files(location = T.unsafe(nil)); end
  def ls_remote(location = T.unsafe(nil), opts = T.unsafe(nil)); end
  def ls_tree(sha); end
  def meets_required_version?; end
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end
  def merge_base(*args); end
  def mv(file1, file2); end
  def namerev(string); end
  def object_contents(sha, &block); end
  def object_size(sha); end
  def object_type(sha); end
  def parse_config(file); end
  def parse_config_list(lines); end
  def process_commit_data(data, sha = T.unsafe(nil), indent = T.unsafe(nil)); end
  def process_commit_log_data(data); end
  def process_tag_data(data, name, indent = T.unsafe(nil)); end
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil)); end
  def push(remote, branch = T.unsafe(nil), opts = T.unsafe(nil)); end
  def read_tree(treeish, opts = T.unsafe(nil)); end
  def remote_add(name, url, opts = T.unsafe(nil)); end
  def remote_remove(name); end
  def remote_set_url(name, url); end
  def remotes; end
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end
  def repack; end
  def required_command_version; end
  def reset(commit, opts = T.unsafe(nil)); end
  def return_base_opts_from_clone(clone_dir, opts); end
  def revert(commitish, opts = T.unsafe(nil)); end
  def revparse(string); end
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end
  def stash_apply(id = T.unsafe(nil)); end
  def stash_clear; end
  def stash_list; end
  def stash_save(message); end
  def stashes_all; end
  def tag(name, *opts); end
  def tag_data(name); end
  def tag_sha(tag_name); end
  def tags; end
  def tree_depth(sha); end
  def unmerged; end
  def update_ref(branch, commit); end
  def worktree_add(dir, commitish = T.unsafe(nil)); end
  def worktree_prune; end
  def worktree_remove(dir); end
  def worktrees_all; end
  def write_tree; end

  private

  def command(cmd, *opts, &block); end
  def command_lines(cmd, *opts); end
  def diff_as_hash(diff_command, opts = T.unsafe(nil)); end
  def escape(s); end
  def escape_for_sh(s); end
  def escape_for_windows(s); end
  def log_common_options(opts); end
  def log_path_options(opts); end
  def restore_git_system_env_variables; end
  def run_command(git_cmd, &block); end
  def set_custom_git_env_variables; end
  def store_git_system_env_variables; end
  def windows_platform?; end
  def with_custom_env_variables(&block); end
end

Git::Lib::ENV_VARIABLE_NAMES = T.let(T.unsafe(nil), Array)

class Git::Log
  include ::Enumerable

  def initialize(base, count = T.unsafe(nil)); end

  def [](index); end
  def author(regex); end
  def between(sha1, sha2 = T.unsafe(nil)); end
  def cherry; end
  def each(&block); end
  def first; end
  def grep(regex); end
  def last; end
  def object(objectish); end
  def path(path); end
  def since(date); end
  def size; end
  def skip(num); end
  def to_s; end
  def until(date); end

  private

  def check_log; end
  def dirty_log; end
  def run_log; end
end

class Git::Object
  class << self
    def new(base, objectish, type = T.unsafe(nil), is_tag = T.unsafe(nil)); end
  end
end

class Git::Object::AbstractObject
  def initialize(base, objectish); end

  def archive(file = T.unsafe(nil), opts = T.unsafe(nil)); end
  def blob?; end
  def commit?; end
  def contents(&block); end
  def contents_array; end
  def diff(objectish); end
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def log(count = T.unsafe(nil)); end
  def mode; end
  def mode=(_arg0); end
  def objectish; end
  def objectish=(_arg0); end
  def sha; end
  def size; end
  def size=(_arg0); end
  def tag?; end
  def to_s; end
  def tree?; end
  def type; end
  def type=(_arg0); end
end

class Git::Object::Blob < ::Git::Object::AbstractObject
  def initialize(base, sha, mode = T.unsafe(nil)); end

  def blob?; end
end

class Git::Object::Commit < ::Git::Object::AbstractObject
  def initialize(base, sha, init = T.unsafe(nil)); end

  def author; end
  def author_date; end
  def commit?; end
  def committer; end
  def committer_date; end
  def date; end
  def diff_parent; end
  def gtree; end
  def message; end
  def name; end
  def parent; end
  def parents; end
  def set_commit(data); end

  private

  def check_commit; end
end

class Git::Object::Tag < ::Git::Object::AbstractObject
  def initialize(base, sha, name); end

  def annotated?; end
  def message; end
  def name; end
  def name=(_arg0); end
  def tag?; end
  def tagger; end

  private

  def check_tag; end
end

class Git::Object::Tree < ::Git::Object::AbstractObject
  def initialize(base, sha, mode = T.unsafe(nil)); end

  def blobs; end
  def children; end
  def depth; end
  def files; end
  def full_tree; end
  def subdirectories; end
  def subtrees; end
  def tree?; end
  def trees; end

  private

  def check_tree; end
end

class Git::Path
  def initialize(path, check_path = T.unsafe(nil)); end

  def path; end
  def path=(_arg0); end
  def readable?; end
  def to_s; end
  def writable?; end
end

class Git::Remote < ::Git::Path
  def initialize(base, name); end

  def branch(branch = T.unsafe(nil)); end
  def fetch(opts = T.unsafe(nil)); end
  def fetch_opts; end
  def fetch_opts=(_arg0); end
  def merge(branch = T.unsafe(nil)); end
  def name; end
  def name=(_arg0); end
  def remove; end
  def to_s; end
  def url; end
  def url=(_arg0); end
end

class Git::Repository < ::Git::Path; end

class Git::Stash
  def initialize(base, message, existing = T.unsafe(nil)); end

  def message; end
  def save; end
  def saved?; end
  def to_s; end
end

class Git::Stashes
  include ::Enumerable

  def initialize(base); end

  def [](index); end
  def all; end
  def apply(index = T.unsafe(nil)); end
  def clear; end
  def each(&block); end
  def save(message); end
  def size; end
end

class Git::Status
  include ::Enumerable

  def initialize(base); end

  def [](file); end
  def added; end
  def added?(file); end
  def changed; end
  def changed?(file); end
  def deleted; end
  def deleted?(file); end
  def each(&block); end
  def pretty; end
  def pretty_file(file); end
  def untracked; end
  def untracked?(file); end

  private

  def construct_status; end
  def fetch_added; end
  def fetch_modified; end
  def fetch_untracked; end
end

class Git::Status::StatusFile
  def initialize(base, hash); end

  def blob(type = T.unsafe(nil)); end
  def mode_index; end
  def mode_index=(_arg0); end
  def mode_repo; end
  def mode_repo=(_arg0); end
  def path; end
  def path=(_arg0); end
  def sha_index; end
  def sha_index=(_arg0); end
  def sha_repo; end
  def sha_repo=(_arg0); end
  def stage; end
  def stage=(_arg0); end
  def type; end
  def type=(_arg0); end
  def untracked; end
  def untracked=(_arg0); end
end

Git::VERSION = T.let(T.unsafe(nil), String)
class Git::WorkingDirectory < ::Git::Path; end

class Git::Worktree < ::Git::Path
  def initialize(base, dir, gcommit = T.unsafe(nil)); end

  def add; end
  def dir; end
  def dir=(_arg0); end
  def full; end
  def full=(_arg0); end
  def gcommit; end
  def gcommit=(_arg0); end
  def remove; end
  def to_a; end
  def to_s; end
end

class Git::Worktrees
  include ::Enumerable

  def initialize(base); end

  def [](worktree_name); end
  def each(&block); end
  def prune; end
  def size; end
  def to_s; end
end
