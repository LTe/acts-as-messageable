# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mongo` gem.
# Please instead update this file by running `bin/tapioca gem mongo`.


module Mongo
  private

  def clear_ocsp_cache; end
  def tls_context_hooks; end
  def tls_context_hooks=(hooks); end

  class << self
    def broken_view_aggregate(*args, **_arg1, &block); end
    def broken_view_aggregate=(*args, **_arg1, &block); end
    def broken_view_aggregate?(*args, **_arg1, &block); end
    def broken_view_options(*args, **_arg1, &block); end
    def broken_view_options=(*args, **_arg1, &block); end
    def broken_view_options?(*args, **_arg1, &block); end
    def clear_ocsp_cache; end
    def options=(*args, **_arg1, &block); end
    def tls_context_hooks; end
    def tls_context_hooks=(hooks); end
    def validate_update_replace(*args, **_arg1, &block); end
    def validate_update_replace=(*args, **_arg1, &block); end
    def validate_update_replace?(*args, **_arg1, &block); end
  end
end

class Mongo::Address
  extend ::Forwardable

  def initialize(seed, options = T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def host; end
  def inspect; end
  def options; end
  def port; end
  def seed; end
  def socket(socket_timeout, opts = T.unsafe(nil)); end
  def to_s; end

  private

  def getaddrinfo(host, family); end
  def map_exceptions(csot); end
  def parse_host_port; end
end

Mongo::Address::FAMILY_MAP = T.let(T.unsafe(nil), Hash)

class Mongo::Address::IPv4
  def initialize(host, port, host_name = T.unsafe(nil)); end

  def host; end
  def host_name; end
  def port; end
  def socket(socket_timeout, options = T.unsafe(nil)); end

  class << self
    def parse(address); end
  end
end

Mongo::Address::IPv4::MATCH = T.let(T.unsafe(nil), Regexp)
Mongo::Address::IPv4::SPLIT = T.let(T.unsafe(nil), String)

class Mongo::Address::IPv6
  def initialize(host, port, host_name = T.unsafe(nil)); end

  def host; end
  def host_name; end
  def port; end
  def socket(socket_timeout, options = T.unsafe(nil)); end

  class << self
    def parse(address); end
  end
end

Mongo::Address::IPv6::MATCH = T.let(T.unsafe(nil), Regexp)
Mongo::Address::LOCALHOST = T.let(T.unsafe(nil), String)

class Mongo::Address::Unix
  def initialize(host, port = T.unsafe(nil), host_name = T.unsafe(nil)); end

  def host; end
  def port; end
  def socket(socket_timeout, options = T.unsafe(nil)); end

  class << self
    def parse(address); end
  end
end

Mongo::Address::Unix::MATCH = T.let(T.unsafe(nil), Regexp)

module Mongo::Address::Validator
  def validate_address_str!(address_str); end

  private

  def validate_hostname!(host); end
  def validate_port_str!(port); end
end

module Mongo::Auth
  extend ::Mongo::Auth

  def get(user, connection, **opts); end
end

class Mongo::Auth::Aws < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::Aws::Conversation < ::Mongo::Auth::SaslConversationBase
  def continue(reply_document, connection); end

  private

  def client_final_payload; end
  def client_first_data; end
  def client_first_payload; end
  def client_nonce; end
  def conversation_id; end
  def server_nonce; end
  def wrap_data(data); end
end

class Mongo::Auth::Aws::Credentials < ::Struct
  def access_key_id; end
  def access_key_id=(_); end
  def expiration; end
  def expiration=(_); end
  def expired?; end
  def secret_access_key; end
  def secret_access_key=(_); end
  def session_token; end
  def session_token=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class Mongo::Auth::Aws::CredentialsCache
  def initialize; end

  def clear; end
  def credentials; end
  def credentials=(credentials); end
  def fetch; end

  class << self
    def instance; end
  end
end

class Mongo::Auth::Aws::CredentialsNotFound < ::Mongo::Error::AuthError
  def initialize; end
end

class Mongo::Auth::Aws::CredentialsRetriever
  def initialize(user = T.unsafe(nil), credentials_cache: T.unsafe(nil)); end

  def credentials(timeout_holder = T.unsafe(nil)); end
  def user; end

  private

  def credentials_from_environment; end
  def credentials_from_user(user); end
  def credentials_from_web_identity_response(response); end
  def credentials_valid?(credentials, source); end
  def ec2_metadata_credentials(timeout_holder = T.unsafe(nil)); end
  def ecs_metadata_credentials(timeout_holder = T.unsafe(nil)); end
  def http_get(http, uri, metadata_token); end
  def obtain_credentials_from_endpoints(timeout_holder = T.unsafe(nil)); end
  def prepare_web_identity_inputs; end
  def request_web_identity_credentials(token, role_arn, role_session_name, timeout_holder); end
  def web_identity_credentials(timeout_holder = T.unsafe(nil)); end
  def with_timeout(timeout_holder); end
end

Mongo::Auth::Aws::CredentialsRetriever::METADATA_TIMEOUT = T.let(T.unsafe(nil), Integer)
Mongo::Auth::Aws::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::Aws::Request
  def initialize(access_key_id:, secret_access_key:, host:, server_nonce:, session_token: T.unsafe(nil), time: T.unsafe(nil)); end

  def access_key_id; end
  def authorization; end
  def canonical_request; end
  def formatted_date; end
  def formatted_time; end
  def headers; end
  def headers_to_sign; end
  def host; end
  def region; end
  def scope; end
  def secret_access_key; end
  def server_nonce; end
  def session_token; end
  def signature; end
  def signed_headers_string; end
  def time; end
  def validate!; end

  private

  def hmac(key, data); end
  def hmac_hex(key, data); end
end

Mongo::Auth::Aws::Request::STS_REQUEST_BODY = T.let(T.unsafe(nil), String)
Mongo::Auth::Aws::Request::VALIDATE_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Auth::Base
  def initialize(user, connection, **opts); end

  def connection; end
  def conversation; end
  def user; end

  private

  def converse_1_step(connection, conversation); end
  def converse_2_step(connection, conversation); end
  def converse_multi_step(connection, conversation, speculative_auth_result: T.unsafe(nil)); end
  def dispatch_msg(connection, conversation, msg); end
  def validate_reply!(connection, conversation, doc); end
end

class Mongo::Auth::CR < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::CR::Conversation < ::Mongo::Auth::ConversationBase
  def continue(reply_document, connection); end
  def database; end
  def nonce; end
  def start(connection); end
end

Mongo::Auth::CR::Conversation::LOGIN = T.let(T.unsafe(nil), Hash)
Mongo::Auth::CR::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::ConversationBase
  def initialize(user, connection, **opts); end

  def build_message(connection, auth_source, selector); end
  def connection; end
  def speculative_auth_document; end
  def user; end
  def validate_external_auth_source; end
end

module Mongo::Auth::CredentialCache
  private

  def cache(key); end
  def clear; end
  def get(key); end
  def set(key, value); end

  class << self
    def cache(key); end
    def clear; end
    def get(key); end
    def set(key, value); end
    def store; end
  end
end

Mongo::Auth::CredentialCache::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
Mongo::Auth::EXTERNAL = T.let(T.unsafe(nil), String)
Mongo::Auth::GET_NONCE = T.let(T.unsafe(nil), Hash)

class Mongo::Auth::Gssapi < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::Gssapi::Conversation < ::Mongo::Auth::SaslConversationBase
  def initialize(user, connection, **opts); end

  def authenticator; end
  def client_first_document; end
  def continue(reply_document, connection); end
  def finalize(connection); end
  def id; end
  def process_continue_response(reply_document); end
end

Mongo::Auth::Gssapi::Conversation::CONTINUE_MESSAGE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::Gssapi::Conversation::START_MESSAGE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::Gssapi::MECHANISM = T.let(T.unsafe(nil), String)
class Mongo::Auth::InvalidConfiguration < ::Mongo::Error::AuthError; end

class Mongo::Auth::InvalidMechanism < ::Mongo::Auth::InvalidConfiguration
  def initialize(mechanism); end
end

class Mongo::Auth::LDAP < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::LDAP::Conversation < ::Mongo::Auth::ConversationBase
  def start(connection); end

  private

  def payload; end
end

Mongo::Auth::LDAP::Conversation::LOGIN = T.let(T.unsafe(nil), Hash)
Mongo::Auth::LDAP::MECHANISM = T.let(T.unsafe(nil), String)
Mongo::Auth::NONCE = T.let(T.unsafe(nil), String)
module Mongo::Auth::Roles; end
Mongo::Auth::Roles::BACKUP = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::CLUSTER_ADMIN = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::CLUSTER_MANAGER = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::CLUSTER_MONITOR = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::DATABASE_ADMIN = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::DATABASE_ADMIN_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::DATABASE_OWNER = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::HOST_MANAGER = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ_WRITE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ_WRITE_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::RESTORE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::ROOT = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::USER_ADMIN = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::USER_ADMIN_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::SOURCES = T.let(T.unsafe(nil), Hash)

class Mongo::Auth::SaslConversationBase < ::Mongo::Auth::ConversationBase
  def start(connection); end

  private

  def auth_mechanism_name; end
  def client_first_document; end
  def client_first_message_options; end
  def validate_server_nonce!; end
end

Mongo::Auth::SaslConversationBase::CLIENT_CONTINUE_MESSAGE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::SaslConversationBase::CLIENT_FIRST_MESSAGE = T.let(T.unsafe(nil), Hash)

class Mongo::Auth::Scram < ::Mongo::Auth::Base
  def initialize(user, connection, **opts); end

  def conversation; end
  def login; end
  def speculative_auth_client_nonce; end
  def speculative_auth_result; end
end

class Mongo::Auth::Scram256 < ::Mongo::Auth::Scram; end

class Mongo::Auth::Scram256::Conversation < ::Mongo::Auth::ScramConversationBase
  private

  def digest; end
  def hi(data); end
  def salted_password; end
end

Mongo::Auth::Scram256::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::Scram::Conversation < ::Mongo::Auth::ScramConversationBase
  private

  def digest; end
  def hi(data); end
  def salted_password; end
end

Mongo::Auth::Scram::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::ScramConversationBase < ::Mongo::Auth::SaslConversationBase
  def initialize(user, connection, client_nonce: T.unsafe(nil)); end

  def client_nonce; end
  def continue(reply_document, connection); end
  def finalize(connection); end
  def id; end
  def process_continue_response(reply_document); end
  def server_verified?; end
  def speculative_auth_document; end

  private

  def auth_message; end
  def cache_key(*extra); end
  def check_server_signature(payload_data); end
  def client_empty_message; end
  def client_final; end
  def client_final_message; end
  def client_first_message_options; end
  def client_first_payload; end
  def client_key; end
  def client_proof(key, signature); end
  def client_signature(key, message); end
  def compare_digest(a, b); end
  def first_bare; end
  def h(string); end
  def hmac(data, key); end
  def iterations; end
  def parse_payload(payload); end
  def payload_data; end
  def salt; end
  def server_key; end
  def server_nonce; end
  def server_signature; end
  def stored_key(key); end
  def without_proof; end
  def xor(first, second); end
end

Mongo::Auth::ScramConversationBase::MIN_ITER_COUNT = T.let(T.unsafe(nil), Integer)

module Mongo::Auth::StringPrep
  extend ::Mongo::Auth::StringPrep

  def prepare(data, mappings, prohibited, options = T.unsafe(nil)); end

  private

  def apply_maps(data, mappings); end
  def check_bidi!(out); end
  def check_prohibited!(out, prohibited); end
  def mapping(c, mappings); end
  def normalize!(out); end
  def table_contains?(table, c); end
end

module Mongo::Auth::StringPrep::Profiles; end
module Mongo::Auth::StringPrep::Profiles::SASL; end
Mongo::Auth::StringPrep::Profiles::SASL::MAPPINGS = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Profiles::SASL::MAP_NON_ASCII_TO_SPACE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Profiles::SASL::PROHIBITED = T.let(T.unsafe(nil), Array)
module Mongo::Auth::StringPrep::Tables; end
Mongo::Auth::StringPrep::Tables::A1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::B1 = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Tables::B2 = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Tables::B3 = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Tables::C1_1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C1_2 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C2_1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C2_2 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C3 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C4 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C5 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C6 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C7 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C8 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C9 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::D1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::D2 = T.let(T.unsafe(nil), Array)

class Mongo::Auth::Unauthorized < ::Mongo::Error::AuthError
  include ::Mongo::Error::ReadWriteRetryable
  include ::Mongo::Error::Labelable

  def initialize(user, used_mechanism: T.unsafe(nil), message: T.unsafe(nil), server: T.unsafe(nil), code: T.unsafe(nil)); end

  def code; end
end

class Mongo::Auth::User
  include ::Mongo::Loggable

  def initialize(options); end

  def ==(other); end
  def auth_key(nonce); end
  def auth_mech_properties; end
  def auth_source; end
  def database; end
  def encoded_name; end
  def hash; end
  def hashed_password; end
  def mechanism; end
  def name; end
  def options; end
  def password; end
  def roles; end
  def sasl_prepped_password; end
  def spec; end

  class << self
    def default_auth_source(options); end
  end
end

class Mongo::Auth::User::View
  extend ::Forwardable

  def initialize(database); end

  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def create(user_or_name, options = T.unsafe(nil)); end
  def database; end
  def info(name, options = T.unsafe(nil)); end
  def next_primary(*args, **_arg1, &block); end
  def read_preference(*args, **_arg1, &block); end
  def remove(name, options = T.unsafe(nil)); end
  def update(user_or_name, options = T.unsafe(nil)); end

  private

  def execute_operation(options); end
  def generate(user, options); end
  def user_query(name, options = T.unsafe(nil)); end
end

class Mongo::Auth::X509 < ::Mongo::Auth::Base
  def initialize(user, connection, **opts); end

  def login; end
end

class Mongo::Auth::X509::Conversation < ::Mongo::Auth::ConversationBase
  def speculative_auth_document; end
  def start(connection); end

  private

  def client_first_document; end
end

Mongo::Auth::X509::Conversation::LOGIN = T.let(T.unsafe(nil), Hash)
Mongo::Auth::X509::MECHANISM = T.let(T.unsafe(nil), String)

module Mongo::BackgroundThread
  include ::Mongo::Loggable

  def run!; end
  def running?; end
  def stop!; end

  private

  def do_work; end
  def pre_stop; end
  def start!; end
  def wait_for_stop; end
end

class Mongo::BulkWrite
  include ::Mongo::Operation::ResponseHandling
  extend ::Forwardable

  def initialize(collection, requests, options = T.unsafe(nil)); end

  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def collection; end
  def database(*args, **_arg1, &block); end
  def execute; end
  def next_primary(*args, **_arg1, &block); end
  def nro_write_with_retry(*args, **_arg1, &block); end
  def options; end
  def ordered?; end
  def requests; end
  def write_concern(session = T.unsafe(nil)); end
  def write_with_retry(*args, **_arg1, &block); end

  private

  def base_spec(operation_id, session); end
  def calculate_deadline; end
  def can_hint?(connection); end
  def delete_many(documents, connection, context, operation_id, session, txn_num); end
  def delete_one(documents, connection, context, operation_id, session, txn_num); end
  def execute_operation(name, values, connection, context, operation_id, result_combiner, session, txn_num = T.unsafe(nil)); end
  def insert_one(documents, connection, context, operation_id, session, txn_num); end
  def maybe_first(obj); end
  def op_combiner; end
  def op_timeout_ms(deadline); end
  def replace_one(documents, connection, context, operation_id, session, txn_num); end
  def single_statement?(operation); end
  def split_execute(name, values, connection, context, operation_id, result_combiner, session, txn_num); end
  def update_many(documents, connection, context, operation_id, session, txn_num); end
  def update_one(documents, connection, context, operation_id, session, txn_num); end
  def validate_array_filters!(connection); end
  def validate_collation!(connection); end
  def validate_hint!(connection); end
  def validate_requests!; end
end

module Mongo::BulkWrite::Combineable
  def initialize(requests); end

  def has_array_filters?; end
  def has_collation?; end
  def has_hint?; end
  def requests; end

  private

  def combine_requests(ops); end
end

class Mongo::BulkWrite::OrderedCombiner
  include ::Mongo::BulkWrite::Transformable
  include ::Mongo::BulkWrite::Validatable
  include ::Mongo::BulkWrite::Combineable

  def combine; end

  private

  def add(operations, name, document); end
  def next_group?(name, operations); end
end

class Mongo::BulkWrite::Result
  def initialize(results, acknowledged); end

  def acknowledged?; end
  def deleted_count; end
  def inserted_count; end
  def inserted_ids; end
  def matched_count; end
  def modified_count; end
  def upserted_count; end
  def upserted_ids; end
  def validate!; end
end

Mongo::BulkWrite::Result::FIELDS = T.let(T.unsafe(nil), Array)
Mongo::BulkWrite::Result::INSERTED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::INSERTED_IDS = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::MATCHED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::MODIFIED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::REMOVED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::UPSERTED = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::UPSERTED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::UPSERTED_IDS = T.let(T.unsafe(nil), String)

class Mongo::BulkWrite::ResultCombiner
  def initialize; end

  def combine!(result, count); end
  def count; end
  def result; end
  def results; end

  private

  def combine_counts!(result); end
  def combine_errors!(result); end
  def combine_ids!(result); end
  def combine_write_concern_errors!(result); end
  def combine_write_errors!(result); end
end

Mongo::BulkWrite::SINGLE_STATEMENT_OPS = T.let(T.unsafe(nil), Array)

module Mongo::BulkWrite::Transformable
  private

  def transform(name, document); end
end

Mongo::BulkWrite::Transformable::DELETE_MANY = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::DELETE_MANY_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::DELETE_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::DELETE_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::INSERT_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::INSERT_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::MAPPERS = T.let(T.unsafe(nil), Hash)
Mongo::BulkWrite::Transformable::REPLACE_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::REPLACE_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::UPDATE_MANY = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::UPDATE_MANY_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::UPDATE_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::UPDATE_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)

class Mongo::BulkWrite::UnorderedCombiner
  include ::Mongo::BulkWrite::Transformable
  include ::Mongo::BulkWrite::Validatable
  include ::Mongo::BulkWrite::Combineable

  def combine; end

  private

  def add(operations, name, document); end
end

module Mongo::BulkWrite::Validatable
  def validate(name, document); end

  private

  def validate_document(name, document); end
  def validate_operation(name); end
end

class Mongo::CachingCursor < ::Mongo::Cursor
  def cached_docs; end
  def each; end
  def inspect; end
  def try_next; end
end

class Mongo::Client
  include ::Mongo::Loggable
  extend ::Forwardable

  def initialize(addresses_or_uri, options = T.unsafe(nil)); end

  def ==(other); end
  def [](collection_name, options = T.unsafe(nil)); end
  def close; end
  def close_encrypter; end
  def closed?; end
  def cluster; end
  def cluster_options; end
  def collections(*args, **_arg1, &block); end
  def command(*args, **_arg1, &block); end
  def database; end
  def database_names(filter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def encrypted_fields_map; end
  def encrypter; end
  def eql?(other); end
  def get_session(options = T.unsafe(nil)); end
  def hash; end
  def inspect; end
  def list_databases(filter = T.unsafe(nil), name_only = T.unsafe(nil), opts = T.unsafe(nil)); end
  def list_mongo_databases(filter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def max_read_retries; end
  def max_write_retries; end
  def options; end
  def read_concern; end
  def read_preference; end
  def read_retry_interval; end
  def reconnect; end
  def server_selector; end
  def start_session(options = T.unsafe(nil)); end
  def subscribe(*args, **_arg1, &block); end
  def summary; end
  def timeout_ms; end
  def timeout_sec; end
  def unsubscribe(*args, **_arg1, &block); end
  def update_options(new_options); end
  def use(name); end
  def watch(pipeline = T.unsafe(nil), options = T.unsafe(nil)); end
  def with(new_options = T.unsafe(nil)); end
  def with_session(options = T.unsafe(nil), &block); end
  def write_concern; end

  private

  def assert_not_closed; end
  def build_encrypter; end
  def cluster_modifying?(new_options); end
  def default_options(options); end
  def do_close; end
  def get_session!(options = T.unsafe(nil)); end
  def initialize_copy(original); end
  def monitoring; end
  def process_addresses(addresses, options); end
  def process_addresses_array(addresses, options); end
  def process_addresses_string(addresses, options); end
  def valid_compressors(compressors); end
  def validate_authentication_options!; end
  def validate_max_connecting!(option, opts); end
  def validate_max_min_pool_size!(option, opts); end
  def validate_new_options!(opts); end
  def validate_options!(addresses = T.unsafe(nil), is_srv: T.unsafe(nil)); end
  def validate_read!(option, opts); end
  def validate_snappy_compression!; end
  def validate_zstd_compression!; end

  class << self
    def canonicalize_ruby_options(options); end
  end
end

Mongo::Client::CRUD_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Client::VALID_COMPRESSORS = T.let(T.unsafe(nil), Array)
Mongo::Client::VALID_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Client::VALID_SERVER_API_VERSIONS = T.let(T.unsafe(nil), Array)

class Mongo::ClientEncryption
  def initialize(key_vault_client, options = T.unsafe(nil)); end

  def add_key_alt_name(id, key_alt_name); end
  def create_data_key(kms_provider, options = T.unsafe(nil)); end
  def create_encrypted_collection(database, coll_name, coll_opts, kms_provider, master_key); end
  def decrypt(value); end
  def delete_key(id); end
  def encrypt(value, options = T.unsafe(nil)); end
  def encrypt_expression(expression, options = T.unsafe(nil)); end
  def get_key(id); end
  def get_key_by_alt_name(key_alt_name); end
  def get_keys; end
  def keys; end
  def remove_key_alt_name(id, key_alt_name); end
  def rewrap_many_data_key(filter, opts = T.unsafe(nil)); end

  private

  def create_data_keys(encrypted_fields, kms_provider, master_key); end
end

class Mongo::Cluster
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  include ::Mongo::Event::Subscriber
  include ::Mongo::ClusterTime::Consumer
  extend ::Forwardable

  def initialize(seeds, monitoring, options = T.unsafe(nil)); end

  def ==(other); end
  def add(host, add_options = T.unsafe(nil)); end
  def addresses; end
  def app_metadata; end
  def close; end
  def connected?; end
  def connecting?; end
  def disconnect_server_if_connected(server); end
  def has_readable_server?(server_selector = T.unsafe(nil)); end
  def has_writable_server?; end
  def heartbeat_interval; end
  def inspect; end
  def load_balanced?; end
  def logical_session_timeout(*args, **_arg1, &block); end
  def max_read_retries; end
  def monitor_app_metadata; end
  def monitoring; end
  def next_primary(ping = T.unsafe(nil), session = T.unsafe(nil), timeout: T.unsafe(nil)); end
  def options; end
  def pool(server); end
  def push_monitor_app_metadata; end
  def read_retry_interval; end
  def reconnect!; end
  def register_cursor(*args); end
  def remove(host, disconnect: T.unsafe(nil)); end
  def replica_set?(*args, **_arg1, &block); end
  def replica_set_name(*args, **_arg1, &block); end
  def run_sdam_flow(previous_desc, updated_desc, options = T.unsafe(nil)); end
  def scan!(sync = T.unsafe(nil)); end
  def schedule_kill_cursor(*args); end
  def seeds; end
  def server_selection_semaphore; end
  def servers; end
  def servers_list; end
  def session_pool; end
  def set_server_list(server_address_strs); end
  def sharded?(*args, **_arg1, &block); end
  def single?(*args, **_arg1, &block); end
  def srv_monitor; end
  def summary; end
  def topology; end
  def unknown?(*args, **_arg1, &block); end
  def unregister_cursor(*args); end
  def update_cluster_time(result); end
  def update_topology(new_topology); end
  def validate_session_support!(timeout: T.unsafe(nil)); end

  private

  def fabricate_lb_sdam_events_and_set_server_type; end
  def possibly_warn_about_compatibility!; end
  def raise_sessions_not_supported; end
  def recreate_topology(new_topology_template, previous_topology); end
  def start_stop_srv_monitor; end

  class << self
    def create(client, monitoring: T.unsafe(nil)); end
  end
end

Mongo::Cluster::CLUSTER_TIME = T.let(T.unsafe(nil), String)
Mongo::Cluster::COSMOSDB_HOST_PATTERNS = T.let(T.unsafe(nil), Array)
Mongo::Cluster::COSMOSDB_LOG_MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Cluster::CursorReaper
  include ::Mongo::Retryable

  def initialize(cluster); end

  def cluster; end
  def execute; end
  def flush; end
  def kill_cursors; end
  def read_scheduled_kill_specs; end
  def register_cursor(id); end
  def schedule_kill_cursor(kill_spec); end
  def unregister_cursor(id); end
end

Mongo::Cluster::CursorReaper::FREQUENCY = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::DOCUMENTDB_HOST_PATTERNS = T.let(T.unsafe(nil), Array)
Mongo::Cluster::DOCUMENTDB_LOG_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Cluster::IDLE_WRITE_PERIOD_SECONDS = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::MAX_READ_RETRIES = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::MAX_WRITE_RETRIES = T.let(T.unsafe(nil), Integer)

class Mongo::Cluster::PeriodicExecutor
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread

  def initialize(executors, options = T.unsafe(nil)); end

  def do_work; end
  def execute; end
  def flush; end
  def options; end
  def pre_stop; end
  def restart!; end
  def stop(final = T.unsafe(nil)); end
end

Mongo::Cluster::PeriodicExecutor::FREQUENCY = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::READ_RETRY_INTERVAL = T.let(T.unsafe(nil), Integer)

class Mongo::Cluster::SdamFlow
  extend ::Forwardable

  def initialize(cluster, previous_desc, updated_desc, awaited: T.unsafe(nil)); end

  def add_servers_from_desc(updated_desc); end
  def awaited?; end
  def became_unknown?; end
  def check_if_has_primary; end
  def cluster; end
  def commit_changes; end
  def disconnect_servers; end
  def do_remove(address_str); end
  def log_warn(*args, **_arg1, &block); end
  def original_desc; end
  def previous_desc; end
  def publish_description_change_event; end
  def publish_sdam_event(*args, **_arg1, &block); end
  def remove; end
  def remove_servers_not_in_desc(updated_desc); end
  def replica_set_name(*args, **_arg1, &block); end
  def seeds(*args, **_arg1, &block); end
  def server_description_changed; end
  def servers_list(*args, **_arg1, &block); end
  def stale_primary?; end
  def start_pool_if_data_bearing; end
  def topology; end
  def topology_effectively_changed?; end
  def update_rs_from_primary; end
  def update_rs_with_primary_from_member; end
  def update_rs_without_primary; end
  def update_server_descriptions; end
  def update_unknown_with_standalone; end
  def updated_desc; end
  def verify_invariants; end
end

class Mongo::Cluster::SocketReaper
  def initialize(cluster); end

  def execute; end
  def flush; end
end

module Mongo::Cluster::Topology
  extend ::Mongo::Cluster::Topology

  def initial(cluster, monitoring, options); end
end

class Mongo::Cluster::Topology::Base
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  extend ::Forwardable

  def initialize(options, monitoring, cluster); end

  def addresses; end
  def compatibility_error; end
  def compatible?; end
  def data_bearing_servers?; end
  def logical_session_timeout; end
  def max_election_id; end
  def max_set_version; end
  def monitoring; end
  def new_max_election_id(description); end
  def new_max_set_version(description); end
  def options; end
  def replica_set_name; end
  def server_descriptions; end
  def server_hosts_match_any?(patterns); end

  private

  def cluster; end
  def validate_options(options, cluster); end
end

class Mongo::Cluster::Topology::LoadBalanced < ::Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers, name = T.unsafe(nil)); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end

  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::LoadBalanced::NAME = T.let(T.unsafe(nil), String)

module Mongo::Cluster::Topology::NoReplicaSetOptions
  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::OPTIONS = T.let(T.unsafe(nil), Hash)

class Mongo::Cluster::Topology::ReplicaSetNoPrimary < ::Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end

  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::ReplicaSetNoPrimary::NAME = T.let(T.unsafe(nil), String)
class Mongo::Cluster::Topology::ReplicaSetWithPrimary < ::Mongo::Cluster::Topology::ReplicaSetNoPrimary; end

class Mongo::Cluster::Topology::Sharded < ::Mongo::Cluster::Topology::Base
  include ::Mongo::Cluster::Topology::NoReplicaSetOptions

  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
end

Mongo::Cluster::Topology::Sharded::NAME = T.let(T.unsafe(nil), String)

class Mongo::Cluster::Topology::Single < ::Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers, name = T.unsafe(nil)); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end

  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::Single::NAME = T.let(T.unsafe(nil), String)

class Mongo::Cluster::Topology::Unknown < ::Mongo::Cluster::Topology::Base
  include ::Mongo::Cluster::Topology::NoReplicaSetOptions

  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
end

Mongo::Cluster::Topology::Unknown::NAME = T.let(T.unsafe(nil), String)

class Mongo::ClusterTime < ::BSON::Document
  def initialize(elements = T.unsafe(nil)); end

  def <(other); end
  def <=(other); end
  def <=>(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def advance(other); end

  class << self
    def [](doc); end
  end
end

module Mongo::ClusterTime::Consumer
  def advance_cluster_time(new_cluster_time); end
  def cluster_time; end
end

class Mongo::Collection
  include ::Mongo::Retryable
  include ::Mongo::Collection::QueryableEncryption
  include ::Mongo::Collection::Helpers
  extend ::Forwardable

  def initialize(database, name, options = T.unsafe(nil)); end

  def ==(other); end
  def aggregate(pipeline, options = T.unsafe(nil)); end
  def bulk_write(requests, options = T.unsafe(nil)); end
  def capped?; end
  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def count(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def count_documents(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def create(opts = T.unsafe(nil)); end
  def database; end
  def delete_many(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def delete_one(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def distinct(field_name, filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def drop(opts = T.unsafe(nil)); end
  def encrypted_fields_map(*args, **_arg1, &block); end
  def estimated_document_count(options = T.unsafe(nil)); end
  def find(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def find_one_and_delete(filter, options = T.unsafe(nil)); end
  def find_one_and_replace(filter, replacement, options = T.unsafe(nil)); end
  def find_one_and_update(filter, update, options = T.unsafe(nil)); end
  def indexes(options = T.unsafe(nil)); end
  def insert_many(documents, options = T.unsafe(nil)); end
  def insert_one(document, opts = T.unsafe(nil)); end
  def inspect; end
  def name; end
  def namespace; end
  def next_primary(*args, **_arg1, &block); end
  def operation_timeouts(opts = T.unsafe(nil)); end
  def options; end
  def parallel_scan(cursor_count, options = T.unsafe(nil)); end
  def read_concern; end
  def read_preference; end
  def replace_one(filter, replacement, options = T.unsafe(nil)); end
  def search_indexes(options = T.unsafe(nil)); end
  def server_selector; end
  def system_collection?; end
  def timeout_ms; end
  def update_many(filter, update, options = T.unsafe(nil)); end
  def update_one(filter, update, options = T.unsafe(nil)); end
  def watch(pipeline = T.unsafe(nil), options = T.unsafe(nil)); end
  def with(new_options); end
  def write_concern; end
  def write_concern_with_session(session); end
end

Mongo::Collection::CAPPED = T.let(T.unsafe(nil), String)
Mongo::Collection::CHANGEABLE_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Collection::CREATE_COLLECTION_OPTIONS = T.let(T.unsafe(nil), Hash)

module Mongo::Collection::Helpers
  def do_drop(operation, session, context); end
end

Mongo::Collection::NS = T.let(T.unsafe(nil), String)

module Mongo::Collection::QueryableEncryption
  def maybe_create_qe_collections(encrypted_fields, client, session); end
  def maybe_drop_emm_collections(encrypted_fields, client, session); end

  private

  def check_wire_version!(connection); end
  def create_operation_for(coll); end
  def emm_collections(encrypted_fields); end
  def encrypted_fields_for_drop_from_map; end
  def encrypted_fields_from(fields); end
end

Mongo::Collection::QueryableEncryption::QE2_MIN_WIRE_VERSION = T.let(T.unsafe(nil), Integer)

class Mongo::Collection::View
  include ::Enumerable
  include ::Mongo::Collection::View::Immutable
  include ::Mongo::CursorHost
  include ::Mongo::Collection::View::Iterable
  include ::Mongo::Collection::View::Readable
  include ::Mongo::Collection::View::Explainable
  include ::Mongo::Collection::View::Writable
  extend ::Forwardable

  def initialize(collection, filter = T.unsafe(nil), options = T.unsafe(nil)); end

  def ==(other); end
  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def collection; end
  def database(*args, **_arg1, &block); end
  def eql?(other); end
  def filter; end
  def hash; end
  def inspect; end
  def next_primary(*args, **_arg1, &block); end
  def nro_write_with_retry(*args, **_arg1, &block); end
  def operation_timeout_ms; end
  def operation_timeouts(opts = T.unsafe(nil)); end
  def read_with_retry(*args, **_arg1, &block); end
  def read_with_retry_cursor(*args, **_arg1, &block); end
  def selector; end
  def timeout_ms; end
  def write_concern; end
  def write_concern_with_session(*args, **_arg1, &block); end
  def write_with_retry(*args, **_arg1, &block); end

  private

  def initialize_copy(other); end
  def new(options); end
  def view; end
  def with_session(opts = T.unsafe(nil), &block); end
end

class Mongo::Collection::View::Aggregation
  include ::Enumerable
  include ::Mongo::Collection::View::Immutable
  include ::Mongo::CursorHost
  include ::Mongo::Collection::View::Iterable
  include ::Mongo::Collection::View::Explainable
  include ::Mongo::Loggable
  include ::Mongo::Retryable
  include ::Mongo::Collection::View::Aggregation::Behavior

  def initialize(view, pipeline, options = T.unsafe(nil)); end

  def pipeline; end

  private

  def effective_read_preference(connection); end
  def initial_query_op(session, read_preference); end
  def new(options); end
  def send_initial_query(server, context); end
end

module Mongo::Collection::View::Aggregation::Behavior
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Enumerable
  include ::Mongo::Collection::View::Immutable
  include ::Mongo::CursorHost
  include ::Mongo::Collection::View::Iterable
  include ::Mongo::Collection::View::Explainable
  include ::Mongo::Loggable
  include ::Mongo::Retryable
  extend ::Forwardable

  def allow_disk_use(value = T.unsafe(nil)); end
  def batch_size(*args, **_arg1, &block); end
  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def collection(*args, **_arg1, &block); end
  def cursor_type(*args, **_arg1, &block); end
  def database(*args, **_arg1, &block); end
  def explain; end
  def limit(*args, **_arg1, &block); end
  def read(*args, **_arg1, &block); end
  def timeout_ms; end
  def view; end
  def write?; end

  private

  def aggregate_spec(session, read_preference); end
  def cache_options; end
  def operation_timeouts(opts = T.unsafe(nil)); end
  def perform_setup(view, options, forbid: T.unsafe(nil)); end
  def server_selector; end
end

module Mongo::Collection::View::Builder; end

class Mongo::Collection::View::Builder::Aggregation
  extend ::Forwardable

  def initialize(pipeline, view, options); end

  def collection(*args, **_arg1, &block); end
  def database(*args, **_arg1, &block); end
  def options; end
  def pipeline; end
  def read(*args, **_arg1, &block); end
  def specification; end
  def view; end
  def write_concern(*args, **_arg1, &block); end

  private

  def aggregation_command; end
  def batch_size_doc; end
  def write?; end
end

Mongo::Collection::View::Builder::Aggregation::MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Collection::View::Builder::MapReduce
  extend ::Forwardable

  def initialize(map, reduce, view, options); end

  def collection(*args, **_arg1, &block); end
  def database(*args, **_arg1, &block); end
  def filter(*args, **_arg1, &block); end
  def map; end
  def options; end
  def read(*args, **_arg1, &block); end
  def reduce; end
  def specification; end
  def view; end
  def write_concern(*args, **_arg1, &block); end

  private

  def map_reduce_command; end
  def view_options; end
  def write?(spec); end
end

Mongo::Collection::View::Builder::MapReduce::MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Collection::View::ChangeStream < ::Mongo::Collection::View::Aggregation
  include ::Mongo::Collection::View::ChangeStream::Retryable

  def initialize(view, pipeline, changes_for, options = T.unsafe(nil)); end

  def close(opts = T.unsafe(nil)); end
  def closed?; end
  def cursor; end
  def cursor_type; end
  def each; end
  def inspect; end
  def max_await_time_ms; end
  def options; end
  def resume_token; end
  def timeout_mode; end
  def to_enum; end
  def try_next; end

  private

  def aggregate_spec(session, read_preference); end
  def change_doc; end
  def create_cursor!(timeout_ms = T.unsafe(nil)); end
  def for_cluster?; end
  def for_collection?; end
  def for_database?; end
  def pipeline; end
  def recreate_cursor!(context = T.unsafe(nil)); end
  def resuming?; end
  def send_initial_query(connection, context); end
  def time_to_bson_timestamp(time); end
end

Mongo::Collection::View::ChangeStream::CLUSTER = T.let(T.unsafe(nil), Symbol)
Mongo::Collection::View::ChangeStream::DATABASE = T.let(T.unsafe(nil), Symbol)
Mongo::Collection::View::ChangeStream::FULL_DOCUMENT_DEFAULT = T.let(T.unsafe(nil), String)

module Mongo::Collection::View::ChangeStream::Retryable
  private

  def read_with_one_retry; end
end

module Mongo::Collection::View::Explainable
  def explain(**opts); end

  private

  def explain_options(**opts); end
  def explained?; end
end

Mongo::Collection::View::Explainable::ALL_PLANS_EXECUTION = T.let(T.unsafe(nil), String)
Mongo::Collection::View::Explainable::EXECUTION_STATS = T.let(T.unsafe(nil), String)
Mongo::Collection::View::Explainable::QUERY_PLANNER = T.let(T.unsafe(nil), String)

module Mongo::Collection::View::Immutable
  def options; end

  private

  def configure(field, value); end
end

module Mongo::Collection::View::Iterable
  include ::Mongo::CursorHost

  def close_query; end
  def each; end
  def kill_cursors; end

  private

  def cache_options; end
  def cached_cursor; end
  def compute_limit_for_cached_query; end
  def initial_query_op(session); end
  def maybe_set_tailable_options(spec); end
  def new_cursor_for_iteration; end
  def oplog_replay; end
  def prefer_cached_cursor?; end
  def select_cursor(session); end
  def send_initial_query(server, context); end
  def use_query_cache?; end
end

class Mongo::Collection::View::MapReduce
  include ::Enumerable
  include ::Mongo::Collection::View::Immutable
  include ::Mongo::Loggable
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(view, map, reduce, options = T.unsafe(nil)); end

  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def collection(*args, **_arg1, &block); end
  def database(*args, **_arg1, &block); end
  def each; end
  def execute; end
  def finalize(function = T.unsafe(nil)); end
  def js_mode(value = T.unsafe(nil)); end
  def map_function; end
  def out(location = T.unsafe(nil)); end
  def out_collection_name; end
  def out_database_name; end
  def read(*args, **_arg1, &block); end
  def reduce_function; end
  def scope(object = T.unsafe(nil)); end
  def timeout_ms(*args, **_arg1, &block); end
  def verbose(value = T.unsafe(nil)); end
  def view; end

  private

  def fetch_query_op(session); end
  def fetch_query_spec; end
  def find_command_spec(session); end
  def initial_query_op(session); end
  def inline?; end
  def map_reduce_spec(session = T.unsafe(nil)); end
  def new(options); end
  def secondary_ok?; end
  def send_fetch_query(server, session); end
  def send_fetch_query_with_connection(connection, session); end
  def send_initial_query(server, context); end
  def send_initial_query_with_connection(connection, session, context:); end
  def server_selector; end
  def valid_server?(description); end
end

Mongo::Collection::View::MapReduce::INLINE = T.let(T.unsafe(nil), String)
Mongo::Collection::View::MapReduce::OUT_ACTIONS = T.let(T.unsafe(nil), Array)
Mongo::Collection::View::MapReduce::REROUTE = T.let(T.unsafe(nil), String)

module Mongo::Collection::View::Readable
  def aggregate(pipeline, options = T.unsafe(nil)); end
  def allow_disk_use; end
  def allow_partial_results; end
  def await_data; end
  def batch_size(batch_size = T.unsafe(nil)); end
  def comment(comment = T.unsafe(nil)); end
  def count(opts = T.unsafe(nil)); end
  def count_documents(opts = T.unsafe(nil)); end
  def cursor_type(type = T.unsafe(nil)); end
  def distinct(field_name, opts = T.unsafe(nil)); end
  def estimated_document_count(opts = T.unsafe(nil)); end
  def hint(hint = T.unsafe(nil)); end
  def limit(limit = T.unsafe(nil)); end
  def map_reduce(map, reduce, options = T.unsafe(nil)); end
  def max_await_time_ms(max = T.unsafe(nil)); end
  def max_scan(value = T.unsafe(nil)); end
  def max_time_ms(max = T.unsafe(nil)); end
  def max_value(value = T.unsafe(nil)); end
  def min_value(value = T.unsafe(nil)); end
  def modifiers(doc = T.unsafe(nil)); end
  def no_cursor_timeout; end
  def parallel_scan(cursor_count, options = T.unsafe(nil)); end
  def projection(document = T.unsafe(nil)); end
  def read(value = T.unsafe(nil)); end
  def read_concern; end
  def read_preference; end
  def return_key(value = T.unsafe(nil)); end
  def show_disk_loc(value = T.unsafe(nil)); end
  def show_record_id(value = T.unsafe(nil)); end
  def skip(number = T.unsafe(nil)); end
  def snapshot(value = T.unsafe(nil)); end
  def sort(spec = T.unsafe(nil)); end
  def timeout_ms(timeout_ms = T.unsafe(nil)); end

  private

  def collation(doc = T.unsafe(nil)); end
  def server_selector; end
  def validate_doc!(doc); end
end

module Mongo::Collection::View::Writable
  def delete_many(opts = T.unsafe(nil)); end
  def delete_one(opts = T.unsafe(nil)); end
  def find_one_and_delete(opts = T.unsafe(nil)); end
  def find_one_and_replace(replacement, opts = T.unsafe(nil)); end
  def find_one_and_update(document, opts = T.unsafe(nil)); end
  def replace_one(replacement, opts = T.unsafe(nil)); end
  def update_many(spec, opts = T.unsafe(nil)); end
  def update_one(spec, opts = T.unsafe(nil)); end

  private

  def validate_replacement_documents!(spec); end
  def validate_update_documents!(spec); end
end

Mongo::Collection::View::Writable::ARRAY_FILTERS = T.let(T.unsafe(nil), String)

class Mongo::ConditionVariable
  extend ::Forwardable

  def initialize(lock = T.unsafe(nil)); end

  def broadcast; end
  def signal; end
  def synchronize(*args, **_arg1, &block); end
  def wait(timeout = T.unsafe(nil)); end

  private

  def raise_unless_locked!; end
end

module Mongo::Config
  extend ::Forwardable
  extend ::Mongo::Config::Options
  extend ::Mongo::Config

  def broken_view_aggregate; end
  def broken_view_aggregate=(value); end
  def broken_view_aggregate?; end
  def broken_view_options; end
  def broken_view_options=(value); end
  def broken_view_options?; end
  def options=(options); end
  def validate_update_replace; end
  def validate_update_replace=(value); end
  def validate_update_replace?; end
end

module Mongo::Config::Options
  def defaults; end
  def option(name, options = T.unsafe(nil)); end
  def reset; end
  def settings; end
end

module Mongo::Config::Validators; end

module Mongo::Config::Validators::Option
  extend ::Mongo::Config::Validators::Option

  def validate(option); end
end

module Mongo::Crypt
  private

  def validate_ffi!; end

  class << self
    def validate_ffi!; end
  end
end

class Mongo::Crypt::AutoDecryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, command); end
end

class Mongo::Crypt::AutoEncrypter
  def initialize(options); end

  def close; end
  def decrypt(command, timeout_holder); end
  def encrypt(database_name, command, timeout_holder); end
  def encrypt?; end
  def key_vault_client; end
  def metadata_client; end
  def mongocryptd_client; end
  def options; end

  private

  def internal_client(client); end
  def set_default_options(options); end
  def set_or_create_clients(options); end
end

Mongo::Crypt::AutoEncrypter::DEFAULT_EXTRA_OPTIONS = T.let(T.unsafe(nil), Mongo::Options::Redacted)

class Mongo::Crypt::AutoEncryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, db_name, command); end
end

class Mongo::Crypt::Context
  extend ::Forwardable

  def initialize(mongocrypt_handle, io); end

  def ctx_p; end
  def kms_providers(*args, **_arg1, &block); end
  def run_state_machine(timeout_holder); end
  def state; end

  private

  def azure_access_token(timeout_holder); end
  def feed_kms; end
  def gcp_access_token(timeout_holder); end
  def mongocrypt_done; end
  def mongocrypt_feed(doc); end
  def provide_collection_info(timeout_ms); end
  def provide_keys(timeout_ms); end
  def provide_markings(timeout_ms); end
  def retrieve_kms_credentials(timeout_holder); end
end

class Mongo::Crypt::DataKeyContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, master_key_document, key_alt_names, key_material); end

  private

  def initialize_ctx; end
  def set_key_alt_names(key_alt_names); end
end

class Mongo::Crypt::EncryptionIO
  def initialize(key_vault_namespace:, key_vault_client:, metadata_client:, client: T.unsafe(nil), mongocryptd_client: T.unsafe(nil), mongocryptd_options: T.unsafe(nil)); end

  def add_key_alt_name(id, key_alt_name, timeout_ms: T.unsafe(nil)); end
  def collection_info(db_name, filter, timeout_ms: T.unsafe(nil)); end
  def delete_key(id, timeout_ms: T.unsafe(nil)); end
  def feed_kms(kms_context, tls_options, timeout_ms: T.unsafe(nil)); end
  def find_keys(filter, timeout_ms: T.unsafe(nil)); end
  def get_key(id, timeout_ms: T.unsafe(nil)); end
  def get_key_by_alt_name(key_alt_name, timeout_ms: T.unsafe(nil)); end
  def get_keys(timeout_ms: T.unsafe(nil)); end
  def insert_data_key(document, timeout_ms: T.unsafe(nil)); end
  def mark_command(cmd, timeout_ms: T.unsafe(nil)); end
  def remove_key_alt_name(id, key_alt_name, timeout_ms: T.unsafe(nil)); end
  def update_data_keys(updates, timeout_ms: T.unsafe(nil)); end

  private

  def key_vault_collection; end
  def spawn_mongocryptd; end
  def validate_key_vault_client!(key_vault_client); end
  def validate_key_vault_namespace!(key_vault_namespace); end
  def with_ssl_socket(endpoint, tls_options, timeout_ms: T.unsafe(nil)); end
end

Mongo::Crypt::EncryptionIO::SOCKET_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Crypt::ExplicitDecryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, doc); end
end

class Mongo::Crypt::ExplicitEncrypter
  extend ::Forwardable

  def initialize(key_vault_client, key_vault_namespace, kms_providers, kms_tls_options, timeout_ms = T.unsafe(nil)); end

  def add_key_alt_name(id, key_alt_name); end
  def create_and_insert_data_key(master_key_document, key_alt_names, key_material = T.unsafe(nil)); end
  def decrypt(value); end
  def delete_key(id); end
  def encrypt(value, options); end
  def encrypt_expression(expression, options); end
  def get_key(id); end
  def get_key_by_alt_name(key_alt_name); end
  def get_keys; end
  def remove_key_alt_name(id, key_alt_name); end
  def rewrap_many_data_key(filter, opts = T.unsafe(nil)); end

  private

  def master_key_for_provider(opts); end
  def timeout_holder; end
  def updates_from_data_key_documents(documents); end
  def validate_rewrap_options!(opts); end
end

class Mongo::Crypt::ExplicitEncryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, doc, options = T.unsafe(nil)); end

  def init(doc); end

  private

  def convert_range_opts(range_opts); end
  def set_algorithm_opts(options); end
  def set_key_alt_name(key_alt_name); end
  def set_key_id(key_id); end
  def set_key_opts(options); end
end

class Mongo::Crypt::ExplicitEncryptionExpressionContext < ::Mongo::Crypt::ExplicitEncryptionContext
  def init(doc); end
end

module Mongo::Crypt::Hooks
  private

  def aes(key, iv, input, decrypt: T.unsafe(nil), mode: T.unsafe(nil)); end
  def hash_sha256(input); end
  def hmac_sha(digest_name, key, input); end
  def random(num_bytes); end
  def rsaes_pkcs_signature(key, input); end

  class << self
    def aes(key, iv, input, decrypt: T.unsafe(nil), mode: T.unsafe(nil)); end
    def hash_sha256(input); end
    def hmac_sha(digest_name, key, input); end
    def random(num_bytes); end
    def rsaes_pkcs_signature(key, input); end
  end
end

module Mongo::Crypt::KMS; end
module Mongo::Crypt::KMS::AWS; end

class Mongo::Crypt::KMS::AWS::Credentials
  include ::Mongo::Crypt::KMS::Validations
  extend ::Forwardable

  def initialize(opts); end

  def access_key_id; end
  def empty?(*args, **_arg1, &block); end
  def secret_access_key; end
  def session_token; end
  def to_document; end
end

Mongo::Crypt::KMS::AWS::Credentials::FORMAT_HINT = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::AWS::MasterKeyDocument
  include ::Mongo::Crypt::KMS::Validations

  def initialize(opts); end

  def endpoint; end
  def key; end
  def region; end
  def to_document; end
end

Mongo::Crypt::KMS::AWS::MasterKeyDocument::FORMAT_HINT = T.let(T.unsafe(nil), String)
module Mongo::Crypt::KMS::Azure; end

class Mongo::Crypt::KMS::Azure::AccessToken
  def initialize(access_token, expires_in); end

  def access_token; end
  def expired?; end
  def expires_in; end
end

class Mongo::Crypt::KMS::Azure::Credentials
  include ::Mongo::Crypt::KMS::Validations
  extend ::Forwardable

  def initialize(opts); end

  def access_token; end
  def client_id; end
  def client_secret; end
  def empty?(*args, **_arg1, &block); end
  def identity_platform_endpoint; end
  def tenant_id; end
  def to_document; end
end

Mongo::Crypt::KMS::Azure::Credentials::FORMAT_HINT = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::Azure::CredentialsRetriever
  class << self
    def fetch_access_token(extra_headers: T.unsafe(nil), metadata_host: T.unsafe(nil), timeout_holder: T.unsafe(nil)); end

    private

    def do_request(uri, req, timeout_holder); end
    def fetch_response(uri, req, timeout_holder); end
    def prepare_request(extra_headers, metadata_host); end
  end
end

Mongo::Crypt::KMS::Azure::CredentialsRetriever::DEFAULT_HOST = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::Azure::MasterKeyDocument
  include ::Mongo::Crypt::KMS::Validations

  def initialize(opts); end

  def key_name; end
  def key_vault_endpoint; end
  def key_version; end
  def to_document; end
end

Mongo::Crypt::KMS::Azure::MasterKeyDocument::FORMAT_HINT = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::Credentials
  def initialize(kms_providers); end

  def aws; end
  def azure; end
  def gcp; end
  def kmip; end
  def local; end
  def to_document; end
end

class Mongo::Crypt::KMS::CredentialsNotFound < ::RuntimeError; end
module Mongo::Crypt::KMS::GCP; end

class Mongo::Crypt::KMS::GCP::Credentials
  include ::Mongo::Crypt::KMS::Validations
  extend ::Forwardable

  def initialize(opts); end

  def access_token; end
  def email; end
  def empty?(*args, **_arg1, &block); end
  def endpoint; end
  def private_key; end
  def to_document; end
end

Mongo::Crypt::KMS::GCP::Credentials::FORMAT_HINT = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::GCP::CredentialsRetriever
  class << self
    def fetch_access_token(timeout_holder = T.unsafe(nil)); end

    private

    def do_fetch(uri, req); end
    def fetch_response(uri, req, timeout_holder); end
  end
end

Mongo::Crypt::KMS::GCP::CredentialsRetriever::DEFAULT_HOST = T.let(T.unsafe(nil), String)
Mongo::Crypt::KMS::GCP::CredentialsRetriever::METADATA_HOST_ENV = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::GCP::MasterKeyDocument
  include ::Mongo::Crypt::KMS::Validations

  def initialize(opts); end

  def endpoint; end
  def key_name; end
  def key_ring; end
  def key_version; end
  def location; end
  def project_id; end
  def to_document; end
end

Mongo::Crypt::KMS::GCP::MasterKeyDocument::FORMAT_HINT = T.let(T.unsafe(nil), String)
module Mongo::Crypt::KMS::KMIP; end

class Mongo::Crypt::KMS::KMIP::Credentials
  include ::Mongo::Crypt::KMS::Validations
  extend ::Forwardable

  def initialize(opts); end

  def empty?(*args, **_arg1, &block); end
  def endpoint; end
  def to_document; end
end

Mongo::Crypt::KMS::KMIP::Credentials::FORMAT_HINT = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::KMIP::MasterKeyDocument
  include ::Mongo::Crypt::KMS::Validations

  def initialize(opts = T.unsafe(nil)); end

  def endpoint; end
  def key_id; end
  def to_document; end
end

Mongo::Crypt::KMS::KMIP::MasterKeyDocument::FORMAT_HINT = T.let(T.unsafe(nil), String)
module Mongo::Crypt::KMS::Local; end

class Mongo::Crypt::KMS::Local::Credentials
  include ::Mongo::Crypt::KMS::Validations
  extend ::Forwardable

  def initialize(opts); end

  def empty?(*args, **_arg1, &block); end
  def key; end
  def to_document; end
end

Mongo::Crypt::KMS::Local::Credentials::FORMAT_HINT = T.let(T.unsafe(nil), String)

class Mongo::Crypt::KMS::Local::MasterKeyDocument
  def initialize(_opts); end

  def to_document; end
end

class Mongo::Crypt::KMS::MasterKeyDocument
  def initialize(kms_provider, options); end

  def to_document; end
end

Mongo::Crypt::KMS::MasterKeyDocument::KMS_PROVIDERS = T.let(T.unsafe(nil), Array)

module Mongo::Crypt::KMS::Validations
  def validate_param(key, opts, format_hint, required: T.unsafe(nil)); end

  private

  def validate_tls_options(options); end

  class << self
    def validate_tls_options(options); end
  end
end

class Mongo::Crypt::KmsContext
  def initialize(kms_ctx); end

  def bytes_needed; end
  def endpoint; end
  def feed(data); end
  def kms_ctx_p; end
  def message; end
end

class Mongo::Crypt::RewrapManyDataKeyContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, filter, master_key_document); end
end

class Mongo::Crypt::RewrapManyDataKeyResult
  def initialize(bulk_write_result); end

  def bulk_write_result; end
end

class Mongo::CsotTimeoutHolder
  def initialize(session: T.unsafe(nil), operation_timeouts: T.unsafe(nil)); end

  def check_timeout!; end
  def csot?; end
  def deadline; end
  def operation_timeouts; end
  def remaining_timeout_ms; end
  def remaining_timeout_ms!; end
  def remaining_timeout_sec; end
  def remaining_timeout_sec!; end
  def timeout?; end
  def timeout_expired?; end
  def timeout_sec; end

  private

  def calculate_deadline(opts = T.unsafe(nil), session = T.unsafe(nil)); end
  def calculate_deadline_from_timeout_ms(operation_timeout_ms); end
  def check_no_override_inside_transaction!(opts, session); end
end

class Mongo::Cursor
  include ::Enumerable
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(view, result, server, options = T.unsafe(nil)); end

  def batch_size; end
  def client(*args, **_arg1, &block); end
  def close(opts = T.unsafe(nil)); end
  def closed?; end
  def cluster(*args, **_arg1, &block); end
  def collection(*args, **_arg1, &block); end
  def collection_name; end
  def connection; end
  def context; end
  def database(*args, **_arg1, &block); end
  def each; end
  def fully_iterated?; end
  def get_more; end
  def id; end
  def initial_result; end
  def inspect; end
  def kill_spec(connection_global_id); end
  def resume_token; end
  def server; end
  def to_return; end
  def try_next; end
  def view; end

  private

  def batch_size_for_get_more; end
  def cache_batch_resume_token; end
  def cache_resume_token(doc); end
  def check_in_connection; end
  def connection_global_id_for_context; end
  def end_session; end
  def execute_operation(op, context: T.unsafe(nil)); end
  def exhausted?; end
  def explicitly_closed?; end
  def fresh_context(opts = T.unsafe(nil)); end
  def get_more_operation; end
  def limit; end
  def limited?; end
  def possibly_refreshed_context; end
  def process(result); end
  def register; end
  def set_cursor_id(result); end
  def unregister; end
  def use_limit?; end

  class << self
    def finalize(kill_spec, cluster); end
  end
end

class Mongo::Cursor::KillSpec
  def initialize(cursor_id:, coll_name:, db_name:, connection_global_id:, server_address:, session:, connection: T.unsafe(nil)); end

  def ==(other); end
  def coll_name; end
  def connection; end
  def connection_global_id; end
  def cursor_id; end
  def db_name; end
  def eql?(other); end
  def hash; end
  def server_address; end
  def session; end
end

module Mongo::Cursor::NonTailable
  def cursor_type; end
  def timeout_mode; end
end

module Mongo::CursorHost
  def cursor; end
  def timeout_mode; end
  def validate_timeout_mode!(options, forbid: T.unsafe(nil)); end
end

Mongo::DBRef = BSON::DBRef

class Mongo::Database
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(client, name, options = T.unsafe(nil)); end

  def ==(other); end
  def [](collection_name, options = T.unsafe(nil)); end
  def aggregate(pipeline, options = T.unsafe(nil)); end
  def client; end
  def cluster(*args, **_arg1, &block); end
  def collection(collection_name, options = T.unsafe(nil)); end
  def collection_names(options = T.unsafe(nil)); end
  def collections(options = T.unsafe(nil)); end
  def command(operation, opts = T.unsafe(nil)); end
  def drop(options = T.unsafe(nil)); end
  def encrypted_fields_map(*args, **_arg1, &block); end
  def fs(options = T.unsafe(nil)); end
  def inspect; end
  def list_collections(options = T.unsafe(nil)); end
  def name; end
  def next_primary(*args, **_arg1, &block); end
  def operation_timeouts(opts); end
  def options; end
  def read_command(operation, opts = T.unsafe(nil)); end
  def read_concern(*args, **_arg1, &block); end
  def read_preference(*args, **_arg1, &block); end
  def server_selector(*args, **_arg1, &block); end
  def timeout_ms; end
  def users; end
  def watch(pipeline = T.unsafe(nil), options = T.unsafe(nil)); end
  def write_concern(*args, **_arg1, &block); end

  class << self
    def create(client); end
  end
end

Mongo::Database::ADMIN = T.let(T.unsafe(nil), String)
Mongo::Database::COMMAND = T.let(T.unsafe(nil), String)
Mongo::Database::DATABASES = T.let(T.unsafe(nil), String)
Mongo::Database::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Mongo::Options::Redacted)
Mongo::Database::NAME = T.let(T.unsafe(nil), String)
Mongo::Database::NAMESPACES = T.let(T.unsafe(nil), String)

class Mongo::Database::View
  include ::Enumerable
  include ::Mongo::Retryable
  include ::Mongo::CursorHost
  include ::Mongo::Cursor::NonTailable
  extend ::Forwardable

  def initialize(database, options = T.unsafe(nil)); end

  def aggregate(pipeline, options = T.unsafe(nil)); end
  def batch_size; end
  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def collection; end
  def collection_names(options = T.unsafe(nil)); end
  def database; end
  def limit; end
  def list_collections(options = T.unsafe(nil)); end
  def next_primary(*args, **_arg1, &block); end
  def operation_timeout_ms; end
  def operation_timeouts(opts = T.unsafe(nil)); end
  def read_concern(*args, **_arg1, &block); end
  def read_preference(*args, **_arg1, &block); end
  def server_selector(*args, **_arg1, &block); end
  def timeout_ms; end
  def write_concern(*args, **_arg1, &block); end

  private

  def collections_info(session, server_selector, options = T.unsafe(nil), &block); end
  def collections_info_spec(session, options = T.unsafe(nil)); end
  def initial_query_op(session, options = T.unsafe(nil)); end
  def send_initial_query(server, session, context, options = T.unsafe(nil)); end
end

class Mongo::DistinguishingSemaphore
  def initialize; end

  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
end

class Mongo::Error < ::StandardError
  include ::Mongo::Error::Notable
  include ::Mongo::Error::Labelable
  include ::Mongo::Error::WriteRetryable
  include ::Mongo::Error::ChangeStreamResumable

  def initialize(msg = T.unsafe(nil)); end

  def change_stream_resumable?; end
  def network_error?; end
  def write_concern_error_label?(label); end
  def write_concern_error_labels; end
end

class Mongo::Error::AuthError < ::RuntimeError
  include ::Mongo::Error::Notable
end

Mongo::Error::BAD_VALUE = T.let(T.unsafe(nil), Integer)
class Mongo::Error::BadLoadBalancerTarget < ::Mongo::Error; end

class Mongo::Error::BulkWriteError < ::Mongo::Error
  def initialize(result); end

  def result; end

  private

  def build_message; end
end

Mongo::Error::CODE = T.let(T.unsafe(nil), String)
Mongo::Error::CURSOR_NOT_FOUND = T.let(T.unsafe(nil), String)

module Mongo::Error::ChangeStreamResumable
  def change_stream_resumable?; end
end

class Mongo::Error::ClientClosed < ::Mongo::Error; end

class Mongo::Error::ClosedStream < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::ConnectionCheckOutTimeout < ::Timeout::Error
  def initialize(msg, options); end

  def address; end
end

class Mongo::Error::ConnectionPerished < ::Mongo::Error; end
class Mongo::Error::ConnectionUnavailable < ::Mongo::Error; end
class Mongo::Error::CredentialCheckError < ::Mongo::Error::AuthError; end

class Mongo::Error::CryptError < ::Mongo::Error
  def initialize(message, code: T.unsafe(nil)); end
end

Mongo::Error::ERR = T.let(T.unsafe(nil), String)
Mongo::Error::ERRMSG = T.let(T.unsafe(nil), String)
Mongo::Error::ERROR = T.let(T.unsafe(nil), String)

class Mongo::Error::ExtraFileChunk < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::FailedStringPrepValidation < ::Mongo::Error
  def initialize(msg); end
end

Mongo::Error::FailedStringPrepValidation::INVALID_BIDIRECTIONAL = T.let(T.unsafe(nil), String)
Mongo::Error::FailedStringPrepValidation::PROHIBITED_CHARACTER = T.let(T.unsafe(nil), String)
Mongo::Error::FailedStringPrepValidation::UNABLE_TO_NORMALIZE = T.let(T.unsafe(nil), String)

class Mongo::Error::FileNotFound < ::Mongo::Error
  def initialize(value, property); end
end

class Mongo::Error::HandshakeError < ::Mongo::Error; end

class Mongo::Error::InsufficientIterationCount < ::Mongo::Error
  def initialize(msg); end

  class << self
    def message(required_count, given_count); end
  end
end

class Mongo::Error::InternalDriverError < ::Mongo::Error; end
class Mongo::Error::InvalidAddress < ::Mongo::Error; end

class Mongo::Error::InvalidApplicationName < ::Mongo::Error
  def initialize(app_name, max_size); end
end

class Mongo::Error::InvalidBulkOperation < ::Mongo::Error
  def initialize(type, operation); end
end

class Mongo::Error::InvalidBulkOperationType < ::Mongo::Error
  def initialize(type); end
end

class Mongo::Error::InvalidCollectionName < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidCollectionName::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidConfigOption < ::Mongo::Error
  def initialize(name); end
end

class Mongo::Error::InvalidCursorOperation < ::Mongo::Error; end

class Mongo::Error::InvalidDatabaseName < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidDatabaseName::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidDocument < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidDocument::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidFile < ::Mongo::Error
  def initialize(client_md5, server_md5); end
end

class Mongo::Error::InvalidFileRevision < ::Mongo::Error
  def initialize(filename, revision); end
end

class Mongo::Error::InvalidMaxConnecting < ::Mongo::Error
  def initialize(max_connecting); end
end

class Mongo::Error::InvalidMinPoolSize < ::Mongo::Error
  def initialize(min, max); end
end

class Mongo::Error::InvalidNonce < ::Mongo::Error
  def initialize(nonce, rnonce); end

  def nonce; end
  def rnonce; end
end

class Mongo::Error::InvalidReadConcern < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::InvalidReadOption < ::Mongo::Error
  def initialize(read_option, msg); end
end

class Mongo::Error::InvalidReplacementDocument < ::Mongo::Error
  def initialize(key: T.unsafe(nil)); end

  class << self
    def message(key); end
    def warn(logger, key); end
  end
end

Mongo::Error::InvalidReplacementDocument::MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::InvalidServerAuthHost < ::Mongo::Error::InvalidServerAuthResponse; end
class Mongo::Error::InvalidServerAuthResponse < ::Mongo::Error::AuthError; end

class Mongo::Error::InvalidServerPreference < ::Mongo::Error
  def initialize(message); end
end

Mongo::Error::InvalidServerPreference::INVALID_MAX_STALENESS = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_HEDGE_SUPPORT = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_MAX_STALENESS_SUPPORT = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_MAX_STALENESS_WITH_LEGACY_SERVER = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_TAG_SUPPORT = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidSession < ::Mongo::Error
  def initialize(message); end
end

class Mongo::Error::InvalidSignature < ::Mongo::Error
  def initialize(verifier, server_signature); end

  def server_signature; end
  def verifier; end
end

class Mongo::Error::InvalidTXTRecord < ::Mongo::Error; end

class Mongo::Error::InvalidTransactionOperation < ::Mongo::Error
  def initialize(msg); end

  class << self
    def cannot_call_after_msg(last_op, current_op); end
    def cannot_call_twice_msg(op); end
  end
end

Mongo::Error::InvalidTransactionOperation::INVALID_READ_PREFERENCE = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidTransactionOperation::NO_TRANSACTION_STARTED = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidTransactionOperation::TRANSACTION_ALREADY_IN_PROGRESS = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidTransactionOperation::UNACKNOWLEDGED_WRITE_CONCERN = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidURI < ::Mongo::Error
  def initialize(uri, details, format = T.unsafe(nil)); end
end

class Mongo::Error::InvalidUpdateDocument < ::Mongo::Error
  def initialize(key: T.unsafe(nil)); end

  class << self
    def message(key); end
    def warn(logger, key); end
  end
end

Mongo::Error::InvalidUpdateDocument::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidWriteConcern < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::KmsError < ::Mongo::Error::CryptError
  def initialize(message, code: T.unsafe(nil), network_error: T.unsafe(nil)); end
end

module Mongo::Error::Labelable
  def add_label(label); end
  def label?(label); end
  def labels; end
end

class Mongo::Error::LintError < ::Mongo::Error; end

class Mongo::Error::MaxBSONSize < ::Mongo::Error
  def initialize(max_size_or_msg = T.unsafe(nil)); end
end

Mongo::Error::MaxBSONSize::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::MaxMessageSize < ::Mongo::Error
  def initialize(max_size = T.unsafe(nil)); end
end

Mongo::Error::MaxMessageSize::MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::MismatchedDomain < ::Mongo::Error; end
class Mongo::Error::MissingConnection < ::Mongo::Error; end

class Mongo::Error::MissingFileChunk < ::Mongo::Error
  def initialize(expected_n, chunk); end
end

class Mongo::Error::MissingPassword < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::MissingResumeToken < ::Mongo::Error
  def initialize; end
end

Mongo::Error::MissingResumeToken::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::MissingScramServerSignature < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::MissingServiceId < ::Mongo::Error; end
class Mongo::Error::MongocryptdSpawnError < ::Mongo::Error::CryptError; end

class Mongo::Error::MultiIndexDrop < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::NeedPrimaryServer < ::Mongo::Error; end
class Mongo::Error::NoSRVRecords < ::Mongo::Error; end

class Mongo::Error::NoServerAvailable < ::Mongo::Error
  def initialize(server_selector, cluster = T.unsafe(nil), msg = T.unsafe(nil)); end
end

class Mongo::Error::NoServiceConnectionAvailable < ::Mongo::Error
  def initialize(message, address:, service_id:); end

  def address; end
  def service_id; end

  class << self
    def generate(address:, service_id:); end
  end
end

module Mongo::Error::Notable
  def add_note(note); end
  def add_notes(*notes); end
  def connection_global_id; end
  def connection_global_id=(_arg0); end
  def generation; end
  def generation=(_arg0); end
  def notes; end
  def service_id; end
  def service_id=(_arg0); end
  def to_s; end

  private

  def notes_tail; end
end

class Mongo::Error::OperationFailure < ::Mongo::Error
  include ::Mongo::Error::SdamErrorDetection
  include ::Mongo::Error::ReadWriteRetryable
  include ::Mongo::Error::OperationFailure::Family
end

module Mongo::Error::OperationFailure::Family
  include ::Mongo::Error::SdamErrorDetection
  include ::Mongo::Error::ReadWriteRetryable
  extend ::Forwardable

  def initialize(message = T.unsafe(nil), result = T.unsafe(nil), options = T.unsafe(nil)); end

  def change_stream_resumable?; end
  def code; end
  def code_name; end
  def connection_description(*args, **_arg1, &block); end
  def details; end
  def document; end
  def max_time_ms_expired?; end
  def operation_time(*args, **_arg1, &block); end
  def result; end
  def server_message; end
  def unsupported_retryable_write?; end
  def write_concern_error?; end
  def write_concern_error_code; end
  def write_concern_error_code_name; end
  def write_concern_error_document; end
  def wtimeout?; end

  private

  def append_details(message, details); end
  def change_stream_resumable_code?; end
  def retrieve_details(document); end
end

Mongo::Error::OperationFailure::Family::CHANGE_STREAM_RESUME_ERRORS = T.let(T.unsafe(nil), Array)
Mongo::Error::OperationFailure::Family::CHANGE_STREAM_RESUME_MESSAGES = T.let(T.unsafe(nil), Array)

class Mongo::Error::Parser
  include ::Mongo::Error::SdamErrorDetection

  def initialize(document, replies = T.unsafe(nil), options = T.unsafe(nil)); end

  def code; end
  def code_name; end
  def document; end
  def labels; end
  def message; end
  def replies; end
  def server_message; end
  def write_concern_error?; end
  def write_concern_error_code; end
  def write_concern_error_code_name; end
  def write_concern_error_document; end
  def write_concern_error_labels; end
  def wtimeout; end

  private

  def append(message, error); end
  def parse!; end
  def parse_code; end
  def parse_flag(message); end
  def parse_labels; end
  def parse_multiple(message, key); end
  def parse_single(message, key, doc = T.unsafe(nil)); end
  def parse_wtimeout; end

  class << self
    def build_message(code: T.unsafe(nil), code_name: T.unsafe(nil), message: T.unsafe(nil)); end
  end
end

class Mongo::Error::PoolClearedError < ::Mongo::Error::PoolError
  def initialize(address, pool); end
end

class Mongo::Error::PoolClosedError < ::Mongo::Error::PoolError
  def initialize(address, pool); end
end

class Mongo::Error::PoolError < ::Mongo::Error
  def initialize(address, pool, message); end

  def address; end
  def pool; end
end

class Mongo::Error::PoolPausedError < ::Mongo::Error::PoolError
  def initialize(address, pool); end
end

class Mongo::Error::RaiseOriginalError < ::Exception; end

module Mongo::Error::ReadWriteRetryable
  def retryable?; end
  def write_retryable?; end

  private

  def write_retryable_code?; end
end

Mongo::Error::ReadWriteRetryable::RETRY_MESSAGES = T.let(T.unsafe(nil), Array)
Mongo::Error::ReadWriteRetryable::WRITE_RETRY_ERRORS = T.let(T.unsafe(nil), Array)
Mongo::Error::ReadWriteRetryable::WRITE_RETRY_MESSAGES = T.let(T.unsafe(nil), Array)

module Mongo::Error::SdamErrorDetection
  def node_recovering?; end
  def node_shutting_down?; end
  def not_master?; end
end

Mongo::Error::SdamErrorDetection::NODE_RECOVERING_CODES = T.let(T.unsafe(nil), Array)
Mongo::Error::SdamErrorDetection::NODE_SHUTTING_DOWN_CODES = T.let(T.unsafe(nil), Array)
Mongo::Error::SdamErrorDetection::NOT_MASTER_CODES = T.let(T.unsafe(nil), Array)
class Mongo::Error::ServerApiConflict < ::Mongo::Error; end
class Mongo::Error::ServerApiNotSupported < ::Mongo::Error; end
class Mongo::Error::ServerCertificateRevoked < ::Mongo::Error; end

class Mongo::Error::ServerNotUsable < ::Mongo::Error
  def initialize(address); end
end

class Mongo::Error::ServerTimeoutError < ::Mongo::Error::TimeoutError
  include ::Mongo::Error::SdamErrorDetection
  include ::Mongo::Error::ReadWriteRetryable
  include ::Mongo::Error::OperationFailure::Family
end

class Mongo::Error::SessionEnded < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::SessionNotMaterialized < ::Mongo::Error::InvalidSession
  def initialize; end
end

class Mongo::Error::SessionsNotSupported < ::Mongo::Error::InvalidSession
  def initialize(message); end
end

class Mongo::Error::SnapshotSessionInvalidServerVersion < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::SnapshotSessionTransactionProhibited < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::SocketError < ::Mongo::Error; end
class Mongo::Error::SocketTimeoutError < ::Mongo::Error::TimeoutError; end
Mongo::Error::TRANSIENT_TRANSACTION_ERROR_LABEL = T.let(T.unsafe(nil), String)
class Mongo::Error::TimeoutError < ::Mongo::Error; end

class Mongo::Error::TransactionsNotSupported < ::Mongo::Error
  def initialize(reason); end
end

Mongo::Error::UNKNOWN_ERROR = T.let(T.unsafe(nil), Integer)
Mongo::Error::UNKNOWN_TRANSACTION_COMMIT_RESULT_LABEL = T.let(T.unsafe(nil), String)

class Mongo::Error::UnchangeableCollectionOption < ::Mongo::Error
  def initialize(option); end
end

class Mongo::Error::UnexpectedChunkLength < ::Mongo::Error
  def initialize(expected_len, chunk); end
end

class Mongo::Error::UnexpectedResponse < ::Mongo::Error
  def initialize(expected_response_to, response_to); end
end

class Mongo::Error::UnknownPayloadType < ::Mongo::Error
  def initialize(byte); end
end

Mongo::Error::UnknownPayloadType::MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::UnmetDependency < ::Mongo::Error; end

class Mongo::Error::UnsupportedArrayFilters < ::Mongo::Error::UnsupportedOption
  def initialize(message = T.unsafe(nil)); end
end

Mongo::Error::UnsupportedArrayFilters::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedArrayFilters::UNACKNOWLEDGED_WRITES_MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::UnsupportedCollation < ::Mongo::Error::UnsupportedOption
  def initialize(message = T.unsafe(nil)); end
end

Mongo::Error::UnsupportedCollation::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedCollation::UNACKNOWLEDGED_WRITES_MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::UnsupportedFeatures < ::Mongo::Error; end
class Mongo::Error::UnsupportedMessageType < ::Mongo::Error; end

class Mongo::Error::UnsupportedOption < ::Mongo::Error
  class << self
    def allow_disk_use_error; end
    def commit_quorum_error; end
    def hint_error(**options); end
  end
end

Mongo::Error::UnsupportedOption::ALLOW_DISK_USE_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedOption::COMMIT_QUORUM_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedOption::HINT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedOption::UNACKNOWLEDGED_HINT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::WRITE_CONCERN_ERROR = T.let(T.unsafe(nil), String)
Mongo::Error::WRITE_CONCERN_ERRORS = T.let(T.unsafe(nil), String)
Mongo::Error::WRITE_ERRORS = T.let(T.unsafe(nil), String)

module Mongo::Error::WriteRetryable
  def write_retryable?; end
end

module Mongo::Event; end

class Mongo::Event::Base
  def summary; end

  private

  def short_class_name; end
end

Mongo::Event::DESCRIPTION_CHANGED = T.let(T.unsafe(nil), String)

class Mongo::Event::Listeners
  def initialize; end

  def add_listener(event, listener); end
  def listeners_for(event); end
end

Mongo::Event::MEMBER_DISCOVERED = T.let(T.unsafe(nil), String)
Mongo::Event::PRIMARY_ELECTED = T.let(T.unsafe(nil), String)

module Mongo::Event::Publisher
  def event_listeners; end
  def publish(event, *args); end
end

Mongo::Event::STANDALONE_DISCOVERED = T.let(T.unsafe(nil), String)

module Mongo::Event::Subscriber
  def event_listeners; end
  def subscribe_to(event, listener); end
end

module Mongo::Grid; end

class Mongo::Grid::FSBucket
  extend ::Forwardable

  def initialize(database, options = T.unsafe(nil)); end

  def chunks_collection; end
  def client(*args, **_arg1, &block); end
  def database; end
  def delete(id, opts = T.unsafe(nil)); end
  def delete_one(file, opts = T.unsafe(nil)); end
  def download_to_stream(id, io); end
  def download_to_stream_by_name(filename, io, opts = T.unsafe(nil)); end
  def drop(opts = T.unsafe(nil)); end
  def files_collection; end
  def find(selector = T.unsafe(nil), options = T.unsafe(nil)); end
  def find_one(selector = T.unsafe(nil)); end
  def insert_one(file); end
  def open_download_stream(id, options = T.unsafe(nil)); end
  def open_download_stream_by_name(filename, opts = T.unsafe(nil), &block); end
  def open_upload_stream(filename, opts = T.unsafe(nil)); end
  def options; end
  def prefix; end
  def read_preference; end
  def upload_from_stream(filename, io, opts = T.unsafe(nil)); end
  def write_concern; end

  private

  def chunks_name; end
  def create_index_if_missing!(collection, index_spec, options = T.unsafe(nil)); end
  def ensure_indexes!(timeout_holder = T.unsafe(nil)); end
  def files_name; end
  def operation_timeouts(opts = T.unsafe(nil)); end
  def read_stream(id, **opts); end
  def write_stream(filename, **opts); end
end

Mongo::Grid::FSBucket::CHUNKS_INDEX = T.let(T.unsafe(nil), Hash)
Mongo::Grid::FSBucket::DEFAULT_ROOT = T.let(T.unsafe(nil), String)
Mongo::Grid::FSBucket::FILES_INDEX = T.let(T.unsafe(nil), Hash)

module Mongo::Grid::FSBucket::Stream
  extend ::Mongo::Grid::FSBucket::Stream

  def get(fs, mode, options = T.unsafe(nil)); end
end

Mongo::Grid::FSBucket::Stream::MODE_MAP = T.let(T.unsafe(nil), Hash)
Mongo::Grid::FSBucket::Stream::READ_MODE = T.let(T.unsafe(nil), Symbol)

class Mongo::Grid::FSBucket::Stream::Read
  include ::Enumerable

  def initialize(fs, options); end

  def close; end
  def closed?; end
  def each; end
  def file_id; end
  def file_info; end
  def fs; end
  def options; end
  def read; end
  def read_preference; end

  private

  def ensure_file_info!; end
  def ensure_open!; end
  def ensure_readable!; end
  def raise_unexpected_chunk_length!(chunk); end
  def validate!(index, num_chunks, chunk, length_read); end
  def validate_length!(index, num_chunks, chunk, length_read); end
  def validate_n!(index, chunk); end
  def view; end
end

Mongo::Grid::FSBucket::Stream::WRITE_MODE = T.let(T.unsafe(nil), Symbol)

class Mongo::Grid::FSBucket::Stream::Write
  def initialize(fs, options); end

  def abort; end
  def close; end
  def closed?; end
  def file_id; end
  def filename; end
  def fs; end
  def options; end
  def write(io); end
  def write_concern; end

  private

  def chunks_collection; end
  def ensure_indexes!; end
  def ensure_open!; end
  def file_info; end
  def files_collection; end
  def update_length; end
  def with_write_concern(collection); end
end

class Mongo::Grid::File
  extend ::Forwardable

  def initialize(data, options = T.unsafe(nil)); end

  def ==(other); end
  def chunk_size(*args, **_arg1, &block); end
  def chunks; end
  def content_type(*args, **_arg1, &block); end
  def data; end
  def filename(*args, **_arg1, &block); end
  def id(*args, **_arg1, &block); end
  def info; end
  def inspect; end
  def md5(*args, **_arg1, &block); end
  def upload_date(*args, **_arg1, &block); end

  private

  def initialize_chunks!(value); end
end

class Mongo::Grid::File::Chunk
  def initialize(document); end

  def ==(other); end
  def bson_type; end
  def data; end
  def document; end
  def files_id; end
  def id; end
  def n; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  class << self
    def assemble(chunks); end
    def split(io, file_info, offset = T.unsafe(nil)); end
  end
end

Mongo::Grid::File::Chunk::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Grid::File::Chunk::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)

class Mongo::Grid::File::Info
  def initialize(document); end

  def ==(other); end
  def bson_type; end
  def chunk_size; end
  def content_type; end
  def document; end
  def filename; end
  def id; end
  def inspect; end
  def length; end
  def md5; end
  def metadata; end
  def size; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def update_md5(bytes); end
  def upload_date; end

  private

  def default_document; end
end

Mongo::Grid::File::Info::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Grid::File::Info::DEFAULT_CONTENT_TYPE = T.let(T.unsafe(nil), String)
Mongo::Grid::File::Info::MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongo::Id
  class << self
    def included(klass); end
  end
end

module Mongo::Index; end
Mongo::Index::ALL = T.let(T.unsafe(nil), String)
Mongo::Index::ASCENDING = T.let(T.unsafe(nil), Integer)
Mongo::Index::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Index::DESCENDING = T.let(T.unsafe(nil), Integer)
Mongo::Index::GEO2D = T.let(T.unsafe(nil), String)
Mongo::Index::GEO2DSPHERE = T.let(T.unsafe(nil), String)
Mongo::Index::GEOHAYSTACK = T.let(T.unsafe(nil), String)
Mongo::Index::HASHED = T.let(T.unsafe(nil), String)
Mongo::Index::TEXT = T.let(T.unsafe(nil), String)

class Mongo::Index::View
  include ::Enumerable
  include ::Mongo::Retryable
  include ::Mongo::CursorHost
  include ::Mongo::Cursor::NonTailable
  extend ::Forwardable

  def initialize(collection, options = T.unsafe(nil)); end

  def batch_size; end
  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def collection; end
  def create_many(*models); end
  def create_one(keys, options = T.unsafe(nil)); end
  def database(*args, **_arg1, &block); end
  def drop_all(options = T.unsafe(nil)); end
  def drop_one(name, options = T.unsafe(nil)); end
  def each(&block); end
  def get(keys_or_name); end
  def next_primary(*args, **_arg1, &block); end
  def operation_timeout_ms; end
  def operation_timeouts(opts = T.unsafe(nil)); end
  def read_preference(*args, **_arg1, &block); end
  def timeout_ms; end
  def write_concern(*args, **_arg1, &block); end

  private

  def drop_by_name(name, opts = T.unsafe(nil)); end
  def index_name(spec); end
  def indexes_spec(session); end
  def initial_query_op(session); end
  def limit; end
  def normalize_keys(spec); end
  def normalize_models(models, server); end
  def send_initial_query(server, session, context); end
end

Mongo::Index::View::KEY = T.let(T.unsafe(nil), String)
Mongo::Index::View::NAME = T.let(T.unsafe(nil), String)
Mongo::Index::View::OPTIONS = T.let(T.unsafe(nil), Hash)

module Mongo::Lint
  private

  def assert_type(obj, cls); end
  def enabled?; end
  def validate_camel_case_read_preference(read_pref); end
  def validate_camel_case_read_preference_mode(mode); end
  def validate_read_concern_option(read_concern); end
  def validate_underscore_read_preference(read_pref); end
  def validate_underscore_read_preference_mode(mode); end

  class << self
    def assert_type(obj, cls); end
    def enabled?; end
    def validate_camel_case_read_preference(read_pref); end
    def validate_camel_case_read_preference_mode(mode); end
    def validate_read_concern_option(read_concern); end
    def validate_underscore_read_preference(read_pref); end
    def validate_underscore_read_preference_mode(mode); end
  end
end

module Mongo::Loggable
  def log_debug(message); end
  def log_error(message); end
  def log_fatal(message); end
  def log_info(message); end
  def log_warn(message); end
  def logger; end

  private

  def _mongo_log_prefix; end
  def format_message(message); end
end

Mongo::Loggable::PREFIX = T.let(T.unsafe(nil), String)

class Mongo::Logger
  class << self
    def level; end
    def level=(level); end
    def logger; end
    def logger=(other); end

    private

    def default_logger; end
  end
end

class Mongo::Monitoring
  include ::Mongo::Id
  include ::Mongo::Monitoring::Subscribable

  def initialize(options = T.unsafe(nil)); end

  def failed(topic, event); end
  def monitoring?; end
  def options; end
  def publish_heartbeat(server, awaited: T.unsafe(nil)); end
  def published(topic, event); end
  def started(topic, event); end
  def succeeded(topic, event); end

  private

  def initialize_copy(original); end

  class << self
    def next_id; end
    def next_operation_id; end
  end
end

Mongo::Monitoring::COMMAND = T.let(T.unsafe(nil), String)
Mongo::Monitoring::CONNECTION_POOL = T.let(T.unsafe(nil), String)

class Mongo::Monitoring::CmapLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def options; end
  def published(event); end
end

class Mongo::Monitoring::CommandLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def failed(event); end
  def options; end
  def started(event); end
  def succeeded(event); end

  private

  def format_command(args); end
  def prefix(event, connection_generation: T.unsafe(nil), connection_id: T.unsafe(nil), server_connection_id: T.unsafe(nil)); end
  def truncate(command); end
  def truncating?; end
end

Mongo::Monitoring::CommandLogSubscriber::LOG_STRING_LIMIT = T.let(T.unsafe(nil), Integer)
module Mongo::Monitoring::Event; end
module Mongo::Monitoring::Event::Cmap; end
class Mongo::Monitoring::Event::Cmap::Base < ::Mongo::Event::Base; end

class Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, reason); end

  def address; end
  def reason; end
  def summary; end
end

Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed::CONNECTION_ERROR = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed::POOL_CLOSED = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed::TIMEOUT = T.let(T.unsafe(nil), Symbol)

class Mongo::Monitoring::Event::Cmap::ConnectionCheckOutStarted < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address); end

  def address; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionCheckedIn < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id, pool); end

  def address; end
  def connection_id; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionCheckedOut < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id, pool); end

  def address; end
  def connection_id; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionClosed < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id, reason); end

  def address; end
  def connection_id; end
  def reason; end
  def summary; end
end

Mongo::Monitoring::Event::Cmap::ConnectionClosed::ERROR = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::HANDSHAKE_FAILED = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::IDLE = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::POOL_CLOSED = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::STALE = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::UNKNOWN = T.let(T.unsafe(nil), Symbol)

class Mongo::Monitoring::Event::Cmap::ConnectionCreated < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id); end

  def address; end
  def connection_id; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionReady < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id); end

  def address; end
  def connection_id; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::PoolCleared < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, service_id: T.unsafe(nil), interrupt_in_use_connections: T.unsafe(nil)); end

  def address; end
  def options; end
  def service_id; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::PoolClosed < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, pool); end

  def address; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::PoolCreated < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, options, pool); end

  def address; end
  def options; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::PoolReady < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, options, pool); end

  def address; end
  def options; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::CommandFailed < ::Mongo::Event::Base
  include ::Mongo::Monitoring::Event::Secure

  def initialize(command_name, database_name, address, request_id, operation_id, message, failure, duration, started_event:, server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end

  def address; end
  def command_name; end
  def database_name; end
  def duration; end
  def failure; end
  def message; end
  def operation_id; end
  def request_id; end
  def server_connection_id; end
  def service_id; end
  def started_event; end
  def summary; end

  class << self
    def generate(address, operation_id, payload, message, failure, duration, started_event:, server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  end
end

class Mongo::Monitoring::Event::CommandStarted < ::Mongo::Event::Base
  include ::Mongo::Monitoring::Event::Secure

  def initialize(command_name, database_name, address, request_id, operation_id, command, socket_object_id: T.unsafe(nil), connection_id: T.unsafe(nil), connection_generation: T.unsafe(nil), server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end

  def address; end
  def command; end
  def command_name; end
  def connection_generation; end
  def connection_id; end
  def database_name; end
  def inspect; end
  def operation_id; end
  def request_id; end
  def sensitive; end
  def server_connection_id; end
  def service_id; end
  def socket_object_id; end
  def summary; end

  private

  def command_summary; end

  class << self
    def generate(address, operation_id, payload, socket_object_id: T.unsafe(nil), connection_id: T.unsafe(nil), connection_generation: T.unsafe(nil), server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  end
end

class Mongo::Monitoring::Event::CommandSucceeded < ::Mongo::Event::Base
  include ::Mongo::Monitoring::Event::Secure

  def initialize(command_name, database_name, address, request_id, operation_id, reply, duration, started_event:, server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end

  def address; end
  def command_name; end
  def database_name; end
  def duration; end
  def operation_id; end
  def reply; end
  def request_id; end
  def server_connection_id; end
  def service_id; end
  def started_event; end
  def summary; end

  class << self
    def generate(address, operation_id, command_payload, reply_payload, duration, started_event:, server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
    def generate_reply(command_payload, reply_payload); end
    def namespace(payload); end
  end
end

module Mongo::Monitoring::Event::Secure
  def compression_allowed?(command_name); end
  def redacted(command_name, document); end
  def sensitive?(command_name:, document:); end
end

Mongo::Monitoring::Event::Secure::REDACTED_COMMANDS = T.let(T.unsafe(nil), Array)

class Mongo::Monitoring::Event::ServerClosed < ::Mongo::Event::Base
  def initialize(address, topology); end

  def address; end
  def summary; end
  def topology; end
end

class Mongo::Monitoring::Event::ServerDescriptionChanged < ::Mongo::Event::Base
  def initialize(address, topology, previous_description, new_description, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def new_description; end
  def previous_description; end
  def summary; end
  def topology; end

  private

  def awaited_indicator; end
end

class Mongo::Monitoring::Event::ServerHeartbeatFailed < ::Mongo::Event::Base
  def initialize(address, round_trip_time, error, started_event:, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def duration; end
  def error; end
  def failure; end
  def round_trip_time; end
  def started_event; end
  def summary; end
end

class Mongo::Monitoring::Event::ServerHeartbeatStarted < ::Mongo::Event::Base
  def initialize(address, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def summary; end
end

class Mongo::Monitoring::Event::ServerHeartbeatSucceeded < ::Mongo::Event::Base
  def initialize(address, round_trip_time, started_event:, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def duration; end
  def round_trip_time; end
  def started_event; end
  def summary; end
end

class Mongo::Monitoring::Event::ServerOpening < ::Mongo::Event::Base
  def initialize(address, topology); end

  def address; end
  def summary; end
  def topology; end
end

class Mongo::Monitoring::Event::TopologyChanged < ::Mongo::Event::Base
  def initialize(previous_topology, new_topology); end

  def new_topology; end
  def previous_topology; end
  def summary; end
end

class Mongo::Monitoring::Event::TopologyClosed < ::Mongo::Event::Base
  def initialize(topology); end

  def summary; end
  def topology; end
end

class Mongo::Monitoring::Event::TopologyOpening < ::Mongo::Event::Base
  def initialize(topology); end

  def summary; end
  def topology; end
end

module Mongo::Monitoring::Global
  extend ::Mongo::Monitoring::Subscribable
end

module Mongo::Monitoring::Publishable
  include ::Mongo::Loggable

  def monitoring; end
  def publish_cmap_event(event); end
  def publish_event(topic, event); end
  def publish_sdam_event(topic, event); end

  private

  def command_completed(result, address, operation_id, payload, duration, started_event:, server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  def command_failed(failure, address, operation_id, payload, message, duration, started_event:, server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  def command_started(address, operation_id, payload, socket_object_id: T.unsafe(nil), connection_id: T.unsafe(nil), connection_generation: T.unsafe(nil), server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  def command_succeeded(result, address, operation_id, payload, duration, started_event:, server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  def duration(start); end
  def monitoring?; end
end

class Mongo::Monitoring::SDAMLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def options; end
  def succeeded(event); end
end

Mongo::Monitoring::SERVER_CLOSED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::SERVER_DESCRIPTION_CHANGED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::SERVER_HEARTBEAT = T.let(T.unsafe(nil), String)
Mongo::Monitoring::SERVER_OPENING = T.let(T.unsafe(nil), String)

class Mongo::Monitoring::ServerClosedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::ServerDescriptionChangedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def awaited_indicator(event); end
  def log_event(event); end
end

class Mongo::Monitoring::ServerOpeningLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

module Mongo::Monitoring::Subscribable
  def subscribe(topic, subscriber); end
  def subscribers; end
  def subscribers?(topic); end
  def unsubscribe(topic, subscriber); end

  private

  def subscribers_for(topic); end
end

Mongo::Monitoring::TOPOLOGY_CHANGED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::TOPOLOGY_CLOSED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::TOPOLOGY_OPENING = T.let(T.unsafe(nil), String)

class Mongo::Monitoring::TopologyChangedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::TopologyClosedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::TopologyOpeningLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::UnifiedSdamLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def options; end
  def published(event); end
  def subscribe(client); end
  def succeeded(event); end
end

module Mongo::Operation; end
Mongo::Operation::ARRAY_FILTERS = T.let(T.unsafe(nil), String)

class Mongo::Operation::Aggregate
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Aggregate::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods
end

class Mongo::Operation::Aggregate::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def post_batch_resume_token; end

  private

  def cursor_document; end
  def explain_document; end
  def first_document; end
end

Mongo::Operation::Aggregate::Result::EXPLAIN = T.let(T.unsafe(nil), String)
Mongo::Operation::Aggregate::Result::EXPLAIN_LEGACY = T.let(T.unsafe(nil), String)

module Mongo::Operation::BypassDocumentValidation
  private

  def add_bypass_document_validation(sel); end
  def command(connection); end
end

Mongo::Operation::CLUSTER_TIME = T.let(T.unsafe(nil), String)
Mongo::Operation::COLLATION = T.let(T.unsafe(nil), String)

module Mongo::Operation::CausalConsistencySupported
  private

  def apply_causal_consistency!(selector, connection); end
end

class Mongo::Operation::CollectionsInfo
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable

  private

  def final_operation; end
end

class Mongo::Operation::CollectionsInfo::Result < ::Mongo::Operation::Result
  def initialize(replies, connection_description, connection_global_id, database_name); end

  def namespace; end
end

class Mongo::Operation::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Command::OpMsg < ::Mongo::Operation::OpMsgBase
  def selector(connection); end
end

class Mongo::Operation::Context < ::Mongo::CsotTimeoutHolder
  def initialize(client: T.unsafe(nil), session: T.unsafe(nil), connection_global_id: T.unsafe(nil), operation_timeouts: T.unsafe(nil), view: T.unsafe(nil), options: T.unsafe(nil)); end

  def aborting_transaction?; end
  def any_retry_writes?; end
  def client; end
  def committing_transaction?; end
  def connection_global_id; end
  def decrypt(cmd); end
  def decrypt?; end
  def encrypt(db_name, cmd); end
  def encrypt?; end
  def encrypter; end
  def in_transaction?; end
  def inspect; end
  def legacy_retry_writes?; end
  def modern_retry_writes?; end
  def options; end
  def refresh(connection_global_id: T.unsafe(nil), timeout_ms: T.unsafe(nil), view: T.unsafe(nil)); end
  def retry?; end
  def server_api; end
  def session; end
  def starting_transaction?; end
  def view; end
  def with(**opts); end
end

class Mongo::Operation::Count
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Count::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported

  private

  def selector(connection); end
end

class Mongo::Operation::Create
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Create::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::CreateIndex
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::CreateIndex::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::CreateSearchIndexes
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::CreateSearchIndexes::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(_connection); end
end

class Mongo::Operation::CreateUser
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::CreateUser::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::Delete
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Write
end

class Mongo::Operation::Delete::BulkResult < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::Aggregatable

  def n_removed; end
end

Mongo::Operation::Delete::IDENTIFIER = T.let(T.unsafe(nil), String)

class Mongo::Operation::Delete::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::BypassDocumentValidation
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Delete::Result < ::Mongo::Operation::Result
  def bulk_result; end
  def deleted_count; end
end

class Mongo::Operation::Distinct
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Distinct::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::Drop
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Drop::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
end

class Mongo::Operation::DropDatabase
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::DropDatabase::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
end

class Mongo::Operation::DropIndex
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::DropIndex::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::DropSearchIndex
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::DropSearchIndex::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(_connection); end
end

module Mongo::Operation::Executable
  include ::Mongo::Operation::ResponseHandling

  def context; end
  def context=(_arg0); end
  def do_execute(connection, context, options = T.unsafe(nil)); end
  def execute(connection, context:, options: T.unsafe(nil)); end

  private

  def build_message(connection, context); end
  def check_for_network_error; end
  def dispatch_message(connection, context, options = T.unsafe(nil)); end
  def get_result(connection, context, options = T.unsafe(nil)); end
  def process_result(result, connection); end
  def process_result_for_sdam(result, connection); end
  def result_class; end
end

Mongo::Operation::Executable::NETWORK_ERRORS = T.let(T.unsafe(nil), Array)

module Mongo::Operation::ExecutableNoValidate
  def execute(connection, context:); end
end

module Mongo::Operation::ExecutableTransactionLabel; end

class Mongo::Operation::Explain
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Explain::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::Explain::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
end

class Mongo::Operation::Find
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

module Mongo::Operation::Find::Builder; end

module Mongo::Operation::Find::Builder::Command
  private

  def convert_limit_and_batch_size!(command); end
  def selector(spec, connection); end

  class << self
    def convert_limit_and_batch_size!(command); end
    def selector(spec, connection); end
  end
end

Mongo::Operation::Find::Builder::Command::OPTION_MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

module Mongo::Operation::Find::Builder::Flags
  private

  def map_flags(options); end

  class << self
    def map_flags(options); end
  end
end

Mongo::Operation::Find::Builder::Flags::MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongo::Operation::Find::Builder::Modifiers
  private

  def map_driver_options(modifiers); end
  def map_server_modifiers(options); end

  class << self
    def map_driver_options(modifiers); end
    def map_server_modifiers(options); end
  end
end

Mongo::Operation::Find::Builder::Modifiers::DRIVER_MAPPINGS = T.let(T.unsafe(nil), BSON::Document)
Mongo::Operation::Find::Builder::Modifiers::SERVER_MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Operation::Find::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def apply_find_timeouts_to(spec, timeout_ms); end
  def apply_relevant_timeouts_to(spec, connection); end
  def selector(connection); end
end

class Mongo::Operation::Find::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def namespace; end

  private

  def cursor_document; end
  def first_document; end
end

class Mongo::Operation::GetMore
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

module Mongo::Operation::GetMore::CommandBuilder
  private

  def selector(connection); end
end

class Mongo::Operation::GetMore::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::GetMore::CommandBuilder
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def apply_get_more_timeouts_to(spec, timeout_ms); end
  def apply_relevant_timeouts_to(spec, connection); end
end

class Mongo::Operation::GetMore::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def post_batch_resume_token; end

  private

  def cursor_document; end
  def first_document; end
end

module Mongo::Operation::Idable
  def documents; end

  private

  def ensure_ids(documents); end
  def has_id?(doc); end
  def id(doc); end
  def id_generator; end
end

Mongo::Operation::Idable::ID_GENERATOR = T.let(T.unsafe(nil), Symbol)

class Mongo::Operation::Indexes
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::Indexes::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods
end

class Mongo::Operation::Indexes::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def namespace; end
  def validate!; end

  private

  def cursor_document; end
  def first_document; end
end

class Mongo::Operation::Insert
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Write

  private

  def validate!(connection); end
end

class Mongo::Operation::Insert::BulkResult < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::Aggregatable

  def initialize(replies, connection_description, connection_global_id, ids); end

  def inserted_id; end
  def inserted_ids; end
  def n_inserted; end
end

Mongo::Operation::Insert::IDENTIFIER = T.let(T.unsafe(nil), String)

class Mongo::Operation::Insert::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Idable
  include ::Mongo::Operation::BypassDocumentValidation
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def get_result(connection, context, options = T.unsafe(nil)); end
  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Insert::Result < ::Mongo::Operation::Result
  def initialize(replies, connection_description, connection_global_id, ids, context: T.unsafe(nil)); end

  def bulk_result; end
  def inserted_id; end
  def inserted_ids; end
end

class Mongo::Operation::KillCursors
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

module Mongo::Operation::KillCursors::CommandBuilder
  private

  def int64_cursor_ids; end
end

class Mongo::Operation::KillCursors::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::KillCursors::CommandBuilder

  private

  def selector(connection); end
end

Mongo::Operation::LIMIT = T.let(T.unsafe(nil), String)

module Mongo::Operation::Limited
  private

  def options(connection); end
end

class Mongo::Operation::ListCollections
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::ListCollections::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::ListCollections::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def namespace; end
  def validate!; end

  private

  def cursor_document; end
  def first_document; end
end

Mongo::Operation::MULTI = T.let(T.unsafe(nil), String)

class Mongo::Operation::MapReduce
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::MapReduce::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods
end

class Mongo::Operation::MapReduce::Result < ::Mongo::Operation::Result
  def counts; end
  def cursor_id; end
  def documents; end
  def returned_count; end
  def successful?; end
  def time; end
  def validate!; end

  private

  def first_document; end
end

Mongo::Operation::MapReduce::Result::COUNTS = T.let(T.unsafe(nil), String)
Mongo::Operation::MapReduce::Result::RESULTS = T.let(T.unsafe(nil), String)
Mongo::Operation::MapReduce::Result::TIME = T.let(T.unsafe(nil), String)
Mongo::Operation::OPERATION_TIME = T.let(T.unsafe(nil), String)

class Mongo::Operation::ObjectIdGenerator
  def generate; end
end

class Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::SessionsSupported
  include ::Mongo::Operation::Timed

  private

  def message(connection); end
end

module Mongo::Operation::OpMsgExecutable
  include ::Mongo::Operation::PolymorphicLookup

  def execute(server, context:, options: T.unsafe(nil)); end
  def execute_with_connection(connection, context:, options: T.unsafe(nil)); end

  private

  def final_operation; end
end

class Mongo::Operation::ParallelScan
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::ParallelScan::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::ParallelScan::Result < ::Mongo::Operation::Result
  def cursor_ids; end
  def documents; end

  private

  def first; end
end

Mongo::Operation::ParallelScan::Result::CURSORS = T.let(T.unsafe(nil), String)

module Mongo::Operation::PolymorphicLookup
  private

  def polymorphic_class(base, name); end
end

module Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::PolymorphicLookup

  mixes_in_class_methods ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def result_class; end

  class << self
    def included(base); end
  end
end

module Mongo::Operation::PolymorphicResult::ClassMethods
  def result_class; end
  def result_class=(_arg0); end
end

Mongo::Operation::Q = T.let(T.unsafe(nil), String)

module Mongo::Operation::ReadPreferenceSupported
  private

  def add_read_preference_legacy(sel, connection); end
  def add_secondary_ok_flag?(connection); end
  def command(connection); end
  def options(connection); end
end

class Mongo::Operation::RemoveUser
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::RemoveUser::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

module Mongo::Operation::ResponseHandling
  private

  def add_error_labels(connection, context); end
  def add_server_diagnostics(connection); end
  def maybe_add_retryable_write_error_label!(error, connection, context); end
  def unpin_maybe(session, connection); end
  def validate_result(result, connection, context); end
end

class Mongo::Operation::Result
  include ::Enumerable
  extend ::Forwardable

  def initialize(replies, connection_description = T.unsafe(nil), connection_global_id = T.unsafe(nil), context: T.unsafe(nil), connection: T.unsafe(nil)); end

  def acknowledged?; end
  def cluster_time; end
  def connection; end
  def connection_description; end
  def connection_global_id; end
  def context; end
  def cursor_id; end
  def documents; end
  def each(&block); end
  def error; end
  def has_cursor_id?; end
  def inspect; end
  def labels; end
  def n; end
  def namespace; end
  def node_recovering?(*args, **_arg1, &block); end
  def node_shutting_down?(*args, **_arg1, &block); end
  def not_master?(*args, **_arg1, &block); end
  def ok?; end
  def operation_time; end
  def replies; end
  def reply; end
  def returned_count; end
  def snapshot_timestamp; end
  def successful?; end
  def topology_version; end
  def validate!; end
  def write_concern_error?; end
  def written_count; end

  private

  def aggregate_returned_count; end
  def aggregate_written_count; end
  def first_document; end
  def operation_failure_class; end
  def parser; end
  def query_failure?; end
  def raise_operation_failure; end
end

module Mongo::Operation::Result::Aggregatable
  def aggregate_write_concern_errors(count); end
  def aggregate_write_errors(count); end
end

Mongo::Operation::Result::CURSOR = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::CURSOR_ID = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::FIRST_BATCH = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::N = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::NAMESPACE = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::NEXT_BATCH = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::OK = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::RESULT = T.let(T.unsafe(nil), String)

module Mongo::Operation::Result::UseLegacyErrorParser
  def parser; end
end

module Mongo::Operation::SessionsSupported
  private

  def add_read_preference(sel, connection); end
  def add_write_concern!(sel); end
  def apply_autocommit!(selector); end
  def apply_causal_consistency!(selector, connection); end
  def apply_causal_consistency_if_possible(selector, connection); end
  def apply_cluster_time!(selector, connection); end
  def apply_read_pref!(selector); end
  def apply_session_options(sel, connection); end
  def apply_start_transaction!(selector); end
  def apply_txn_num!(selector); end
  def apply_txn_opts!(selector); end
  def build_message(connection, context); end
  def command(connection); end
  def flags; end
  def read_command?(sel); end
  def suppress_read_write_concern!(selector); end
  def validate_read_preference!(selector); end
end

Mongo::Operation::SessionsSupported::READ_COMMANDS = T.let(T.unsafe(nil), Array)
Mongo::Operation::SessionsSupported::ZERO_TIMESTAMP = T.let(T.unsafe(nil), BSON::Timestamp)

module Mongo::Operation::Specifiable
  def initialize(spec); end

  def ==(other); end
  def acknowledged_write?; end
  def apply_collation(selector, connection, collation); end
  def array_filters(connection); end
  def bypass_document_validation; end
  def coll_name; end
  def collation; end
  def command(connection); end
  def cursor_count; end
  def cursor_id; end
  def db_name; end
  def delete; end
  def deletes; end
  def documents; end
  def eql?(other); end
  def index; end
  def index_id; end
  def index_name; end
  def indexes; end
  def max_time_ms; end
  def namespace; end
  def operation_id; end
  def options(connection); end
  def ordered?; end
  def read; end
  def read_concern; end
  def selector(connection); end
  def session; end
  def spec; end
  def to_return; end
  def txn_num; end
  def update; end
  def updates; end
  def user; end
  def user_name; end
  def write_concern; end
end

Mongo::Operation::Specifiable::BYPASS_DOC_VALIDATION = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::COLLATION = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::COLL_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::CURSOR_COUNT = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::CURSOR_ID = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DB_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DELETE = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DELETES = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DOCUMENTS = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::INDEX = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::INDEXES = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::INDEX_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::MAX_TIME_MS = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::OPERATION_ID = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::OPTIONS = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::READ = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::READ_CONCERN = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::SELECTOR = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::TO_RETURN = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::UPDATE = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::UPDATES = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::USER = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::USER_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::WRITE_CONCERN = T.let(T.unsafe(nil), Symbol)

module Mongo::Operation::Timed
  def apply_relevant_timeouts_to(spec, connection); end
  def with_max_time(connection); end
end

Mongo::Operation::U = T.let(T.unsafe(nil), String)
Mongo::Operation::UPSERT = T.let(T.unsafe(nil), String)

class Mongo::Operation::Update
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Write
end

class Mongo::Operation::Update::BulkResult < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::Aggregatable

  def n_matched; end
  def n_modified; end
  def n_upserted; end
  def upserted; end

  private

  def upsert?(reply); end
end

Mongo::Operation::Update::BulkResult::MODIFIED = T.let(T.unsafe(nil), String)
Mongo::Operation::Update::BulkResult::UPSERTED = T.let(T.unsafe(nil), String)
Mongo::Operation::Update::IDENTIFIER = T.let(T.unsafe(nil), String)

class Mongo::Operation::Update::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::BypassDocumentValidation
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Update::Result < ::Mongo::Operation::Result
  def bulk_result; end
  def matched_count; end
  def modified_count; end
  def upserted_count; end
  def upserted_id; end

  private

  def upsert?; end
end

Mongo::Operation::Update::Result::MODIFIED = T.let(T.unsafe(nil), String)
Mongo::Operation::Update::Result::UPSERTED = T.let(T.unsafe(nil), String)

class Mongo::Operation::UpdateSearchIndex
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::UpdateSearchIndex::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(_connection); end
end

class Mongo::Operation::UpdateUser
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::UpdateUser::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::UsersInfo
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::UsersInfo::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::UsersInfo::Result < ::Mongo::Operation::Result
  def documents; end

  private

  def first_document; end
end

Mongo::Operation::UsersInfo::Result::USERS = T.let(T.unsafe(nil), String)

module Mongo::Operation::Validatable
  def validate_array_filters(connection, selector_or_item); end
  def validate_collation(connection, selector_or_item); end
  def validate_find_options(connection, selector); end
  def validate_hint_on_update(connection, selector_or_item); end
  def validate_updates(connection, updates); end
end

module Mongo::Operation::Write
  include ::Mongo::Operation::ResponseHandling

  def bulk_execute(connection, context:); end
  def execute(server, context:); end
  def execute_with_connection(connection, context:); end

  private

  def validate!(connection); end
end

class Mongo::Operation::WriteCommand
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgExecutable
end

class Mongo::Operation::WriteCommand::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Validatable

  private

  def selector(connection); end
end

module Mongo::Operation::WriteConcernSupported
  private

  def add_write_concern!(sel, connection); end
  def command(connection); end
  def write_concern_supported?(connection); end
end

module Mongo::Options; end

module Mongo::Options::Mapper
  extend ::Mongo::Options::Mapper

  def transform(options, mappings); end
  def transform_documents(options, mappings, document = T.unsafe(nil)); end
  def transform_keys_to_strings(options); end
  def transform_keys_to_symbols(options); end
  def transform_values_to_strings(options); end
end

class Mongo::Options::Redacted < ::BSON::Document
  def has_key?(key); end
  def inspect; end
  def key?(key); end
  def reject(&block); end
  def reject!; end
  def select(&block); end
  def select!; end
  def to_s; end

  private

  def redact(k, v, method); end
  def redacted_string(method); end
end

Mongo::Options::Redacted::SENSITIVE_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Options::Redacted::STRING_REPLACEMENT = T.let(T.unsafe(nil), String)
module Mongo::Protocol; end

class Mongo::Protocol::CachingHash
  def initialize(hash); end

  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

class Mongo::Protocol::Compressed < ::Mongo::Protocol::Message
  def initialize(message, compressor, zlib_compression_level = T.unsafe(nil)); end

  def compressed_message; end
  def compressor_id; end
  def maybe_inflate; end
  def op_code; end
  def original_op_code; end
  def replyable?; end
  def uncompressed_size; end

  private

  def compress(buffer); end
  def decompress(compressed_message); end
  def serialize_fields(buffer, max_bson_size); end
end

Mongo::Protocol::Compressed::COMPRESSOR_ID_MAP = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Compressed::NOOP = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::NOOP_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::OP_CODE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Compressed::SNAPPY = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::SNAPPY_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZLIB = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZLIB_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZSTD = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZSTD_BYTE = T.let(T.unsafe(nil), String)

class Mongo::Protocol::GetMore < ::Mongo::Protocol::Message
  def initialize(database, collection, number_to_return, cursor_id); end

  def cursor_id; end
  def namespace; end
  def number_to_return; end
  def op_code; end
  def payload; end
  def replyable?; end
  def zero; end

  protected

  def upconverter; end
end

Mongo::Protocol::GetMore::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::GetMore::Upconverter
  def initialize(collection, cursor_id, number_to_return); end

  def collection; end
  def command; end
  def cursor_id; end
  def number_to_return; end
end

Mongo::Protocol::GetMore::Upconverter::GET_MORE = T.let(T.unsafe(nil), String)

class Mongo::Protocol::KillCursors < ::Mongo::Protocol::Message
  def initialize(collection, database, cursor_ids); end

  def cursor_ids; end
  def id_count; end
  def op_code; end
  def payload; end
  def zero; end

  protected

  def upconverter; end
end

Mongo::Protocol::KillCursors::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::KillCursors::Upconverter
  def initialize(collection, cursor_ids); end

  def collection; end
  def command; end
  def cursor_ids; end
end

class Mongo::Protocol::Message
  include ::Mongo::Id
  include ::Mongo::Protocol::Serializers

  def initialize(*args); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def maybe_add_server_api(server_api); end
  def maybe_compress(compressor, zlib_compression_level = T.unsafe(nil)); end
  def maybe_decrypt(context); end
  def maybe_encrypt(connection, context); end
  def maybe_inflate; end
  def number_returned; end
  def replyable?; end
  def request_id; end
  def serialize(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end
  def set_request_id; end
  def to_s(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end

  private

  def compress_if_possible(command_name, compressor, zlib_compression_level); end
  def fields; end
  def merge_sections; end
  def serialize_fields(buffer, max_bson_size = T.unsafe(nil)); end
  def serialize_header(buffer); end

  class << self
    def deserialize(io, max_message_size = T.unsafe(nil), expected_response_to = T.unsafe(nil), options = T.unsafe(nil)); end
    def deserialize_array(message, io, field, options = T.unsafe(nil)); end
    def deserialize_field(message, io, field, options = T.unsafe(nil)); end
    def deserialize_header(io); end
    def field(name, type, multi = T.unsafe(nil)); end
    def fields; end
    def next_id; end
  end
end

Mongo::Protocol::Message::BATCH_SIZE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::LIMIT = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::MAX_MESSAGE_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Message::ORDERED = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::Q = T.let(T.unsafe(nil), String)

class Mongo::Protocol::Msg < ::Mongo::Protocol::Message
  include ::Mongo::Monitoring::Event::Secure

  def initialize(flags, options, main_document, *sequences); end

  def bulk_write?; end
  def documents; end
  def fix_after_deserialization; end
  def flags; end
  def maybe_add_server_api(server_api); end
  def maybe_compress(compressor, zlib_compression_level = T.unsafe(nil)); end
  def maybe_decrypt(context); end
  def maybe_encrypt(connection, context); end
  def number_returned; end
  def op_code; end
  def payload; end
  def replyable?; end
  def sections; end
  def serialize(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end

  private

  def add_check_sum(buffer); end
  def command; end
  def validate_document_size!(max_bson_size); end
end

Mongo::Protocol::Msg::DATABASE_IDENTIFIER = T.let(T.unsafe(nil), String)
Mongo::Protocol::Msg::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Msg::INTERNAL_KEYS = T.let(T.unsafe(nil), Set)
Mongo::Protocol::Msg::KNOWN_FLAGS = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Msg::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Msg::Section1
  def initialize(identifier, documents); end

  def ==(other); end
  def documents; end
  def eql?(other); end
  def identifier; end
end

class Mongo::Protocol::Query < ::Mongo::Protocol::Message
  include ::Mongo::Monitoring::Event::Secure

  def initialize(database, collection, selector, options = T.unsafe(nil)); end

  def flags; end
  def limit; end
  def maybe_compress(compressor, zlib_compression_level = T.unsafe(nil)); end
  def namespace; end
  def op_code; end
  def payload; end
  def project; end
  def replyable?; end
  def selector; end
  def serialize(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end
  def skip; end

  protected

  def upconverter; end

  private

  def determine_limit; end
  def validate_document_size!(max_bson_size); end
end

Mongo::Protocol::Query::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Query::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Query::Upconverter
  def initialize(collection, filter, options, flags); end

  def collection; end
  def command; end
  def command_name; end
  def filter; end
  def flags; end
  def options; end

  private

  def command?; end
  def find_command; end
  def op_command; end
  def query_filter; end
end

Mongo::Protocol::Query::Upconverter::FLAG_MAPPINGS = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Query::Upconverter::OPTION_MAPPINGS = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Query::Upconverter::SPECIAL_FIELD_MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongo::Protocol::Registry
  extend ::Mongo::Protocol::Registry

  def get(op_code, message = T.unsafe(nil)); end
  def register(op_code, type); end

  private

  def define_type_reader(type); end
  def handle_unsupported_op_code!(op_code); end
end

Mongo::Protocol::Registry::MAPPINGS = T.let(T.unsafe(nil), Hash)

class Mongo::Protocol::Reply < ::Mongo::Protocol::Message
  def cursor_id; end
  def cursor_not_found?; end
  def documents; end
  def flags; end
  def number_returned; end
  def op_code; end
  def payload; end
  def query_failure?; end
  def starting_from; end

  private

  def upconverter; end
end

Mongo::Protocol::Reply::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Reply::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Reply::Upconverter
  def initialize(documents, cursor_id, starting_from); end

  def command; end
  def cursor_id; end
  def documents; end
  def starting_from; end

  private

  def batch_field; end
  def command?; end
  def find_command; end
  def op_command; end
end

Mongo::Protocol::Reply::Upconverter::CURSOR = T.let(T.unsafe(nil), String)
Mongo::Protocol::Reply::Upconverter::FIRST_BATCH = T.let(T.unsafe(nil), String)
Mongo::Protocol::Reply::Upconverter::ID = T.let(T.unsafe(nil), String)
Mongo::Protocol::Reply::Upconverter::NEXT_BATCH = T.let(T.unsafe(nil), String)
module Mongo::Protocol::Serializers; end

class Mongo::Protocol::Serializers::BitVector
  def initialize(layout); end

  def deserialize(buffer, options = T.unsafe(nil)); end
  def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
end

module Mongo::Protocol::Serializers::Byte
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::Bytes
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::CString
  class << self
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::Document
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
    def size_limited?; end
  end
end

Mongo::Protocol::Serializers::HEADER_PACK = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Header
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::INT32_PACK = T.let(T.unsafe(nil), String)
Mongo::Protocol::Serializers::INT64_PACK = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Int32
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::Int64
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::NULL = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Sections
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
    def size_limited?; end
  end
end

module Mongo::Protocol::Serializers::Sections::PayloadOne
  class << self
    def deserialize(buffer); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::Sections::PayloadOne::TYPE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Serializers::Sections::PayloadOne::TYPE_BYTE = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Sections::PayloadZero
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::Sections::PayloadZero::TYPE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Serializers::Sections::PayloadZero::TYPE_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Serializers::ZERO = T.let(T.unsafe(nil), Integer)

module Mongo::Protocol::Serializers::Zero
  class << self
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::QueryCache
  class << self
    def cache; end
    def clear; end
    def clear_namespace(namespace); end
    def enabled=(value); end
    def enabled?; end
    def get(**opts); end
    def normalized_limit(limit); end
    def set(cursor, **opts); end
    def uncached; end

    private

    def cache_key(**opts); end
    def cache_table; end
    def namespace_key(**opts); end
  end
end

class Mongo::QueryCache::Middleware
  def initialize(app); end

  def call(env); end
end

module Mongo::QueryCache::Middleware::ActiveJob
  class << self
    def included(base); end
  end
end

module Mongo::Retryable
  extend ::Forwardable

  def nro_write_with_retry(*args, **_arg1, &block); end
  def read_with_one_retry(*args, **_arg1, &block); end
  def read_with_retry(*args, **_arg1, &block); end
  def read_with_retry_cursor(*args, **_arg1, &block); end
  def read_worker; end
  def select_server(cluster, server_selector, session, failed_server = T.unsafe(nil), timeout: T.unsafe(nil)); end
  def write_with_retry(*args, **_arg1, &block); end
  def write_worker; end
end

class Mongo::Retryable::BaseWorker
  extend ::Forwardable

  def initialize(retryable); end

  def client(*args, **_arg1, &block); end
  def cluster(*args, **_arg1, &block); end
  def retryable; end
  def select_server(*args, **_arg1, &block); end

  private

  def deprecation_warning(key, warning); end
  def is_legacy_retryable_exception?(e); end
  def is_retryable_exception?(e); end
  def legacy_retryable_exceptions; end
  def log_retry(e, options = T.unsafe(nil)); end
  def retryable_exceptions; end
end

class Mongo::Retryable::ReadWorker < ::Mongo::Retryable::BaseWorker
  def read_with_one_retry(options = T.unsafe(nil)); end
  def read_with_retry(session = T.unsafe(nil), server_selector = T.unsafe(nil), context = T.unsafe(nil), &block); end
  def read_with_retry_cursor(session, server_selector, view, context: T.unsafe(nil), &block); end

  private

  def deprecated_legacy_read_with_retry(&block); end
  def legacy_read_with_retry(session, server_selector, context = T.unsafe(nil), &block); end
  def modern_read_with_retry(session, server_selector, context, &block); end
  def read_without_retry(session, server_selector, &block); end
  def retry_read(original_error, session, server_selector, context: T.unsafe(nil), failed_server: T.unsafe(nil), &block); end
  def select_server_for_retry(original_error, session, server_selector, context, failed_server); end
end

class Mongo::Retryable::WriteWorker < ::Mongo::Retryable::BaseWorker
  def nro_write_with_retry(write_concern, context:, &block); end
  def retry_write_allowed?(session, write_concern); end
  def write_with_retry(write_concern, context:, ending_transaction: T.unsafe(nil), &block); end

  private

  def ensure_labeled_retryable!(e, connection_succeeded, session); end
  def ensure_retryable!(e); end
  def ensure_valid_state!(ending_transaction, session); end
  def fail_on_other_error!(e, original_error); end
  def legacy_write_with_retry(server = T.unsafe(nil), context:); end
  def maybe_fail_on_operation_failure(e, original_error, context, attempt); end
  def maybe_fail_on_retryable(e, original_error, context, attempt); end
  def modern_write_with_retry(session, server, context, &block); end
  def raise_unsupported_error(e); end
  def retry_write(original_error, txn_num, context:, failed_server: T.unsafe(nil), &block); end
end

module Mongo::SearchIndex; end

class Mongo::SearchIndex::View
  include ::Enumerable
  include ::Mongo::Retryable
  include ::Mongo::Collection::Helpers

  def initialize(collection, options = T.unsafe(nil)); end

  def aggregate_options; end
  def collection; end
  def create_many(indexes); end
  def create_one(definition, name: T.unsafe(nil), type: T.unsafe(nil)); end
  def drop_one(id: T.unsafe(nil), name: T.unsafe(nil)); end
  def each(&block); end
  def empty?; end
  def requested_index_id; end
  def requested_index_name; end
  def update_one(definition, id: T.unsafe(nil), name: T.unsafe(nil)); end

  private

  def execution_context; end
  def next_primary(ping = T.unsafe(nil), session = T.unsafe(nil)); end
  def spec_with(extras); end
  def validate_id_or_name!(id, name); end
  def validate_search_index!(doc); end
  def validate_search_index_definition!(definition); end
  def validate_search_index_keys!(keys); end
  def validate_search_index_name!(name); end
end

class Mongo::Semaphore
  def initialize; end

  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
end

class Mongo::Server
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  include ::Mongo::Event::Publisher
  extend ::Forwardable

  def initialize(address, cluster, monitoring, event_listeners, options = T.unsafe(nil)); end

  def ==(other); end
  def address; end
  def app_metadata(*args, **_arg1, &block); end
  def arbiter?(*args, **_arg1, &block); end
  def average_round_trip_time(*args, **_arg1, &block); end
  def check_driver_support!(*args, **_arg1, &block); end
  def clear_connection_pool(service_id: T.unsafe(nil), interrupt_in_use_connections: T.unsafe(nil)); end
  def clear_description; end
  def close; end
  def cluster; end
  def cluster_time(*args, **_arg1, &block); end
  def compressor; end
  def connectable?; end
  def connected?; end
  def description; end
  def disconnect!; end
  def features(*args, **_arg1, &block); end
  def force_load_balancer?; end
  def ghost?(*args, **_arg1, &block); end
  def handle_auth_failure!; end
  def handle_handshake_failure!; end
  def heartbeat_frequency; end
  def heartbeat_frequency_seconds; end
  def inspect; end
  def last_scan; end
  def last_scan_monotime; end
  def last_write_date(*args, **_arg1, &block); end
  def load_balancer?(*args, **_arg1, &block); end
  def logical_session_timeout(*args, **_arg1, &block); end
  def matches_tag_set?(tag_set); end
  def max_bson_object_size(*args, **_arg1, &block); end
  def max_message_size(*args, **_arg1, &block); end
  def max_wire_version(*args, **_arg1, &block); end
  def max_write_batch_size(*args, **_arg1, &block); end
  def minimum_round_trip_time(*args, **_arg1, &block); end
  def mongos?(*args, **_arg1, &block); end
  def monitor; end
  def monitor_app_metadata(*args, **_arg1, &block); end
  def monitoring; end
  def next_connection_id; end
  def options; end
  def other?(*args, **_arg1, &block); end
  def pool; end
  def pool_internal; end
  def primary?(*args, **_arg1, &block); end
  def publish_opening_event; end
  def push_monitor_app_metadata(*args, **_arg1, &block); end
  def reconnect!; end
  def replica_set_name(*args, **_arg1, &block); end
  def retry_reads?; end
  def retry_writes?; end
  def round_trip_time_calculator; end
  def scan!(*args, **_arg1, &block); end
  def scan_semaphore; end
  def secondary?(*args, **_arg1, &block); end
  def standalone?(*args, **_arg1, &block); end
  def start_monitoring; end
  def status; end
  def summary; end
  def tags(*args, **_arg1, &block); end
  def unknown!(options = T.unsafe(nil)); end
  def unknown?(*args, **_arg1, &block); end
  def update_cluster_time(*args, **_arg1, &block); end
  def update_description(description); end
  def update_last_scan; end
  def with_connection(connection_global_id: T.unsafe(nil), context: T.unsafe(nil), &block); end
end

class Mongo::Server::AppMetadata
  extend ::Forwardable

  def initialize(options = T.unsafe(nil)); end

  def client_document; end
  def platform; end
  def purpose; end
  def server_api; end
  def validated_document; end
  def wrapping_libraries; end

  private

  def architecture; end
  def check_purpose!(purpose); end
  def document; end
  def driver_doc; end
  def env_doc; end
  def name; end
  def os_doc; end
  def platform_string; end
  def type; end
  def validate!; end
end

Mongo::Server::AppMetadata::AUTH_OPTION_KEYS = T.let(T.unsafe(nil), Array)
Mongo::Server::AppMetadata::DRIVER_NAME = T.let(T.unsafe(nil), String)

class Mongo::Server::AppMetadata::Environment
  def initialize; end

  def aws?; end
  def azure?; end
  def container; end
  def error; end
  def faas?; end
  def fields; end
  def gcp?; end
  def name; end
  def present?; end
  def to_h; end
  def vercel?; end

  private

  def detect_container; end
  def detect_environment; end
  def discriminator_matches?(var); end
  def docker_present?; end
  def dockerenv_path; end
  def error=(msg); end
  def extract_field(var, definition); end
  def kubernetes_present?; end
  def populate_faas_fields; end
end

Mongo::Server::AppMetadata::Environment::COERCIONS = T.let(T.unsafe(nil), Hash)
Mongo::Server::AppMetadata::Environment::DISCRIMINATORS = T.let(T.unsafe(nil), Hash)
Mongo::Server::AppMetadata::Environment::DOCKERENV_PATH = T.let(T.unsafe(nil), String)
Mongo::Server::AppMetadata::Environment::FIELDS = T.let(T.unsafe(nil), Hash)
Mongo::Server::AppMetadata::Environment::MAXIMUM_VALUE_LENGTH = T.let(T.unsafe(nil), Integer)
class Mongo::Server::AppMetadata::Environment::MissingVariable < ::Mongo::Error; end
class Mongo::Server::AppMetadata::Environment::TooManyEnvironments < ::Mongo::Error; end
class Mongo::Server::AppMetadata::Environment::TypeMismatch < ::Mongo::Error; end
class Mongo::Server::AppMetadata::Environment::ValueTooLong < ::Mongo::Error; end
Mongo::Server::AppMetadata::MAX_APP_NAME_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::AppMetadata::PURPOSES = T.let(T.unsafe(nil), Array)

class Mongo::Server::AppMetadata::Platform
  def initialize(metadata); end

  def default_platform_list; end
  def java_version; end
  def jruby?; end
  def metadata; end
  def platforms; end
  def purpose; end
  def ruby_versions; end
  def to_s; end
end

class Mongo::Server::AppMetadata::Truncator
  def initialize(document); end

  def document; end
  def ok?; end
  def size; end

  private

  def excess; end
  def try_truncate!; end
  def try_truncate_env!; end
  def try_truncate_env_fields!; end
  def try_truncate_hash(hash, reserved: T.unsafe(nil)); end
  def try_truncate_os_fields!; end
  def try_truncate_platform!; end
  def try_truncate_string(string); end
end

Mongo::Server::AppMetadata::Truncator::MAX_DOCUMENT_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Server::Connection < ::Mongo::Server::ConnectionBase
  include ::Mongo::Retryable
  include ::Mongo::Id

  def initialize(server, options = T.unsafe(nil)); end

  def closed?; end
  def connect!(context = T.unsafe(nil)); end
  def connected?; end
  def connection_pool; end
  def disconnect!(options = T.unsafe(nil)); end
  def error?; end
  def global_id; end
  def id; end
  def interrupted!; end
  def interrupted?; end
  def last_checkin; end
  def pin; end
  def ping; end
  def pinned?; end
  def record_checkin!; end
  def socket_timeout; end
  def timeout; end
  def unpin; end

  private

  def create_socket(context = T.unsafe(nil)); end
  def deliver(message, client, options = T.unsafe(nil)); end
  def do_connect; end
  def handle_errors; end
  def raise_if_closed!; end

  class << self
    def next_id; end
  end
end

Mongo::Server::Connection::PING = T.let(T.unsafe(nil), Hash)
Mongo::Server::Connection::PING_BYTES = T.let(T.unsafe(nil), String)
Mongo::Server::Connection::PING_MESSAGE = T.let(T.unsafe(nil), Mongo::Protocol::Query)
Mongo::Server::Connection::PING_OP_MSG = T.let(T.unsafe(nil), Hash)
Mongo::Server::Connection::PING_OP_MSG_BYTES = T.let(T.unsafe(nil), String)
Mongo::Server::Connection::PING_OP_MSG_MESSAGE = T.let(T.unsafe(nil), Mongo::Protocol::Msg)

class Mongo::Server::ConnectionBase < ::Mongo::Server::ConnectionCommon
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  extend ::Forwardable

  def address(*args, **_arg1, &block); end
  def app_metadata; end
  def cluster_time(*args, **_arg1, &block); end
  def description; end
  def dispatch(messages, context, options = T.unsafe(nil)); end
  def features(*args, **_arg1, &block); end
  def generation; end
  def max_bson_object_size(*args, **_arg1, &block); end
  def max_message_size(*args, **_arg1, &block); end
  def mongos?(*args, **_arg1, &block); end
  def options; end
  def server; end
  def service_id; end
  def update_cluster_time(*args, **_arg1, &block); end

  private

  def check_timeout!(context); end
  def deliver(message, context, options = T.unsafe(nil)); end
  def serialize(message, context, buffer = T.unsafe(nil)); end
end

Mongo::Server::ConnectionBase::DEFAULT_MAX_BSON_OBJECT_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionBase::MAX_BSON_COMMAND_OVERHEAD = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionBase::REDUCED_MAX_BSON_SIZE = T.let(T.unsafe(nil), Integer)

class Mongo::Server::ConnectionCommon
  def compressor; end
  def connected?; end
  def handshake_command(handshake_document); end
  def handshake_document(app_metadata, speculative_auth_doc: T.unsafe(nil), load_balancer: T.unsafe(nil), server_api: T.unsafe(nil)); end
  def pid; end

  private

  def add_server_diagnostics; end
  def ensure_connected; end
  def set_compressor!(reply); end
  def socket; end
  def ssl_options; end
end

Mongo::Server::ConnectionCommon::HELLO_DOC = T.let(T.unsafe(nil), BSON::Document)
Mongo::Server::ConnectionCommon::LEGACY_HELLO_DOC = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Server::ConnectionPool
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  extend ::Forwardable

  def initialize(server, options = T.unsafe(nil)); end

  def address(*args, **_arg1, &block); end
  def available_count; end
  def check_in(connection); end
  def check_out(connection_global_id: T.unsafe(nil), context: T.unsafe(nil)); end
  def clear(options = T.unsafe(nil)); end
  def close(options = T.unsafe(nil)); end
  def close_idle_sockets; end
  def closed?; end
  def disconnect!(options = T.unsafe(nil)); end
  def do_check_in(connection); end
  def do_clear(options = T.unsafe(nil)); end
  def do_pause; end
  def generation(*args, **_arg1, &block); end
  def generation_manager; end
  def generation_unlocked(*args, **_arg1, &block); end
  def inspect; end
  def max_connecting; end
  def max_idle_time; end
  def max_size; end
  def min_size; end
  def monitoring(*args, **_arg1, &block); end
  def options; end
  def pause; end
  def paused?; end
  def populate; end
  def populate_semaphore; end
  def populator; end
  def ready; end
  def ready?; end
  def server; end
  def size; end
  def stop_populator; end
  def summary; end
  def unavailable_connections; end
  def wait_timeout(context = T.unsafe(nil)); end
  def with_connection(connection_global_id: T.unsafe(nil), context: T.unsafe(nil)); end

  private

  def check_invariants; end
  def clear_pending_connections; end
  def close_available_connections(service_id); end
  def connect_connection(connection, context = T.unsafe(nil)); end
  def connect_or_raise(connection, context); end
  def connection_stale_unlocked?(connection); end
  def create_and_add_connection; end
  def create_connection; end
  def decrement_connection_requests_and_signal; end
  def get_connection(pid, connection_global_id); end
  def maybe_raise_pool_cleared!(connection, e); end
  def next_available_connection(connection_global_id); end
  def raise_check_out_timeout!(connection_global_id); end
  def raise_check_out_timeout_locked!(connection_global_id); end
  def raise_if_closed!; end
  def raise_if_not_ready!; end
  def raise_if_pool_closed!; end
  def raise_if_pool_paused!; end
  def raise_if_pool_paused_locked!; end
  def raise_unless_locked!; end
  def remove_interrupted_connections; end
  def remove_stale_connection; end
  def retrieve_and_connect_connection(connection_global_id, context = T.unsafe(nil)); end
  def schedule_for_interruption(connections, service_id); end
  def unsynchronized_size; end
  def valid_available_connection?(connection, pid, connection_global_id); end
  def wait_for_connection(connection_global_id, deadline); end

  class << self
    def finalize(available_connections, pending_connections, populator); end
  end
end

Mongo::Server::ConnectionPool::DEFAULT_MAX_CONNECTING = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionPool::DEFAULT_MAX_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionPool::DEFAULT_MIN_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionPool::DEFAULT_WAIT_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Server::ConnectionPool::GenerationManager
  def initialize(server:); end

  def bump(service_id: T.unsafe(nil)); end
  def close_all_pipes; end
  def generation(service_id: T.unsafe(nil)); end
  def generation_unlocked(service_id: T.unsafe(nil)); end
  def pipe_fds(service_id: T.unsafe(nil)); end
  def remove_pipe_fds(generation, service_id: T.unsafe(nil)); end
  def server; end

  private

  def close_all_scheduled; end
  def validate_service_id!(service_id); end
end

class Mongo::Server::ConnectionPool::Populator
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread

  def initialize(pool, options = T.unsafe(nil)); end

  def options; end
  def pre_stop; end

  private

  def do_work; end
end

class Mongo::Server::Description
  def initialize(address, config = T.unsafe(nil), average_round_trip_time: T.unsafe(nil), minimum_round_trip_time: T.unsafe(nil), load_balancer: T.unsafe(nil), force_load_balancer: T.unsafe(nil)); end

  def ==(other); end
  def address; end
  def arbiter?; end
  def arbiters; end
  def average_round_trip_time; end
  def config; end
  def data_bearing?; end
  def election_id; end
  def eql?(other); end
  def features; end
  def ghost?; end
  def hidden?; end
  def hosts; end
  def inspect; end
  def is_server?(server); end
  def last_update_monotime; end
  def last_update_time; end
  def last_write_date; end
  def lists_server?(server); end
  def load_balancer?; end
  def logical_session_timeout; end
  def max_bson_object_size; end
  def max_message_size; end
  def max_wire_version; end
  def max_write_batch_size; end
  def me; end
  def me_mismatch?; end
  def min_wire_version; end
  def minimum_round_trip_time; end
  def mongocryptd?; end
  def mongos?; end
  def ok?; end
  def op_time; end
  def other?; end
  def passive?; end
  def passives; end
  def primary?; end
  def primary_host; end
  def replica_set_member?; end
  def replica_set_name; end
  def secondary?; end
  def server_connection_id; end
  def server_type; end
  def server_version_gte?(version); end
  def servers; end
  def service_id; end
  def set_version; end
  def standalone?; end
  def tags; end
  def topology_version; end
  def topology_version_gt?(other_desc); end
  def topology_version_gte?(other_desc); end
  def unknown?; end
  def wire_versions; end
end

Mongo::Server::Description::ARBITER = T.let(T.unsafe(nil), String)
Mongo::Server::Description::ARBITERS = T.let(T.unsafe(nil), String)
Mongo::Server::Description::CONNECTION_ID = T.let(T.unsafe(nil), String)
Mongo::Server::Description::DEFAULT_MAX_WRITE_BATCH_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::Description::ELECTION_ID = T.let(T.unsafe(nil), String)
Mongo::Server::Description::EXCLUDE_FOR_COMPARISON = T.let(T.unsafe(nil), Array)

class Mongo::Server::Description::Features
  def initialize(server_wire_versions, address = T.unsafe(nil)); end

  def array_filters_enabled?; end
  def check_driver_support!; end
  def collation_enabled?; end
  def commit_quorum_enabled?; end
  def find_and_modify_option_validation_enabled?; end
  def find_command_enabled?; end
  def get_more_comment_enabled?; end
  def list_collections_enabled?; end
  def list_indexes_enabled?; end
  def max_staleness_enabled?; end
  def merge_out_on_secondary_enabled?; end
  def op_msg_enabled?; end
  def retryable_write_error_label_enabled?; end
  def scram_sha_1_enabled?; end
  def scram_sha_256_enabled?; end
  def server_wire_versions; end
  def sessions_enabled?; end
  def sharded_transactions_enabled?; end
  def transactions_enabled?; end
  def update_delete_option_validation_enabled?; end
  def users_info_enabled?; end
  def write_command_enabled?; end
end

Mongo::Server::Description::Features::DRIVER_TOO_OLD = T.let(T.unsafe(nil), String)
Mongo::Server::Description::Features::DRIVER_WIRE_VERSIONS = T.let(T.unsafe(nil), Range)
Mongo::Server::Description::Features::MAPPINGS = T.let(T.unsafe(nil), Hash)
Mongo::Server::Description::Features::SERVER_TOO_OLD = T.let(T.unsafe(nil), String)
Mongo::Server::Description::HIDDEN = T.let(T.unsafe(nil), String)
Mongo::Server::Description::HOSTS = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LAST_WRITE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LAST_WRITE_DATE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LEGACY_WIRE_VERSION = T.let(T.unsafe(nil), Integer)
Mongo::Server::Description::LOCAL_TIME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LOGICAL_SESSION_TIMEOUT_MINUTES = T.let(T.unsafe(nil), String)

class Mongo::Server::Description::LoadBalancer
  def initialize(address); end

  def address; end
end

Mongo::Server::Description::MAX_BSON_OBJECT_SIZE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MAX_MESSAGE_BYTES = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MAX_WIRE_VERSION = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MAX_WRITE_BATCH_SIZE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::ME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MIN_WIRE_VERSION = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MONGOS_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::OPERATION_TIME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PASSIVE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PASSIVES = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PRIMARY = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PRIMARY_HOST = T.let(T.unsafe(nil), String)
Mongo::Server::Description::REPLICA_SET = T.let(T.unsafe(nil), String)
Mongo::Server::Description::SECONDARY = T.let(T.unsafe(nil), String)
Mongo::Server::Description::SET_NAME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::SET_VERSION = T.let(T.unsafe(nil), String)
Mongo::Server::Description::TAGS = T.let(T.unsafe(nil), String)

class Mongo::Server::Monitor
  include ::Mongo::Loggable
  include ::Mongo::Event::Publisher
  include ::Mongo::BackgroundThread
  extend ::Forwardable

  def initialize(server, event_listeners, monitoring, options = T.unsafe(nil)); end

  def compressor(*args, **_arg1, &block); end
  def connection; end
  def create_push_monitor!(topology_version); end
  def do_work; end
  def heartbeat_interval; end
  def last_scan(*args, **_arg1, &block); end
  def monitoring; end
  def options; end
  def push_monitor; end
  def restart!; end
  def run_sdam_flow(result, awaited: T.unsafe(nil), scan_error: T.unsafe(nil)); end
  def scan!; end
  def server; end
  def stop!; end
  def stop_push_monitor!; end
  def to_s; end

  private

  def check; end
  def do_scan; end
  def pre_stop; end
  def throttle_scan_frequency!; end
end

class Mongo::Server::Monitor::AppMetadata < ::Mongo::Server::AppMetadata
  def initialize(options = T.unsafe(nil)); end
end

class Mongo::Server::Monitor::Connection < ::Mongo::Server::ConnectionCommon
  include ::Mongo::Loggable

  def initialize(address, options = T.unsafe(nil)); end

  def address; end
  def check_document; end
  def connect!; end
  def disconnect!(options = T.unsafe(nil)); end
  def dispatch(message); end
  def dispatch_bytes(bytes, **opts); end
  def handshake!; end
  def options; end
  def read_response(**opts); end
  def server_connection_id; end
  def socket_timeout; end
  def write_bytes(bytes); end

  private

  def add_server_connection_id; end
  def hello_ok?; end
  def set_hello_ok!(reply); end
end

Mongo::Server::Monitor::DEFAULT_HEARTBEAT_INTERVAL = T.let(T.unsafe(nil), Integer)
Mongo::Server::Monitor::MIN_SCAN_INTERVAL = T.let(T.unsafe(nil), Float)
Mongo::Server::Monitor::RTT_WEIGHT_FACTOR = T.let(T.unsafe(nil), Float)

class Mongo::Server::PendingConnection < ::Mongo::Server::ConnectionBase
  def initialize(socket, server, monitoring, options = T.unsafe(nil)); end

  def handshake_and_authenticate!; end
  def id; end

  private

  def authenticate!(speculative_auth_client_nonce: T.unsafe(nil), speculative_auth_mech: T.unsafe(nil), speculative_auth_result: T.unsafe(nil)); end
  def default_mechanism; end
  def ensure_connected; end
  def get_handshake_response(hello_command); end
  def handshake!(speculative_auth_doc: T.unsafe(nil)); end
  def post_handshake(response, average_rtt, minimum_rtt); end
  def resolved_user(speculative_auth_mech: T.unsafe(nil)); end
end

class Mongo::Server::PushMonitor
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread
  extend ::Forwardable

  def initialize(monitor, topology_version, monitoring, **options); end

  def check; end
  def do_work; end
  def monitor; end
  def monitoring; end
  def options; end
  def read_response; end
  def server(*args, **_arg1, &block); end
  def start!; end
  def stop!; end
  def to_s; end
  def topology_version; end
  def write_check_command; end
end

class Mongo::Server::PushMonitor::Connection < ::Mongo::Server::Monitor::Connection
  def socket_timeout; end
end

class Mongo::Server::RoundTripTimeCalculator
  def initialize; end

  def average_round_trip_time; end
  def last_round_trip_time; end
  def measure; end
  def minimum_round_trip_time; end
  def update_average_round_trip_time; end
  def update_minimum_round_trip_time; end
end

Mongo::Server::RoundTripTimeCalculator::MIN_SAMPLES = T.let(T.unsafe(nil), Integer)
Mongo::Server::RoundTripTimeCalculator::RTT_SAMPLES_FOR_MINIMUM = T.let(T.unsafe(nil), Integer)
Mongo::Server::RoundTripTimeCalculator::RTT_WEIGHT_FACTOR = T.let(T.unsafe(nil), Float)

module Mongo::ServerSelector
  extend ::Mongo::ServerSelector

  def get(preference = T.unsafe(nil)); end
  def primary; end
end

class Mongo::ServerSelector::Base
  def initialize(options = T.unsafe(nil)); end

  def ==(other); end
  def candidates(cluster); end
  def hedge; end
  def inspect; end
  def local_threshold; end
  def local_threshold_with_cluster(cluster); end
  def max_staleness; end
  def options; end
  def select_server(cluster, ping = T.unsafe(nil), session = T.unsafe(nil), write_aggregation: T.unsafe(nil), deprioritized: T.unsafe(nil), timeout: T.unsafe(nil)); end
  def server_selection_timeout; end
  def suitable_servers(cluster); end
  def tag_sets; end
  def try_select_server(cluster, write_aggregation: T.unsafe(nil), deprioritized: T.unsafe(nil)); end

  private

  def filter_stale_servers(candidates, primary = T.unsafe(nil)); end
  def full_doc; end
  def match_tag_sets(candidates); end
  def near_servers(candidates = T.unsafe(nil), local_threshold = T.unsafe(nil)); end
  def primary(candidates); end
  def secondaries(candidates); end
  def select_server_impl(cluster, ping, session, write_aggregation, deprioritized, csot_timeout); end
  def server_selection_diagnostic_message(cluster); end
  def suitable_server(servers, deprioritized); end
  def validate!; end
  def validate_max_staleness_support!(server); end
  def validate_max_staleness_value!(cluster); end
  def validate_max_staleness_value_early!; end
  def wait_for_server_selection(cluster, time_remaining); end
end

Mongo::ServerSelector::LOCAL_THRESHOLD = T.let(T.unsafe(nil), Float)

class Mongo::ServerSelector::Nearest < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::Nearest::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)
Mongo::ServerSelector::PREFERENCES = T.let(T.unsafe(nil), Hash)
Mongo::ServerSelector::PRIMARY = T.let(T.unsafe(nil), Mongo::Options::Redacted)

class Mongo::ServerSelector::Primary < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::Primary::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)

class Mongo::ServerSelector::PrimaryPreferred < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::PrimaryPreferred::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)
Mongo::ServerSelector::SERVER_SELECTION_TIMEOUT = T.let(T.unsafe(nil), Integer)
Mongo::ServerSelector::SMALLEST_MAX_STALENESS_SECONDS = T.let(T.unsafe(nil), Integer)

class Mongo::ServerSelector::Secondary < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::Secondary::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)

class Mongo::ServerSelector::SecondaryPreferred < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::SecondaryPreferred::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)

class Mongo::Session
  include ::Mongo::Retryable
  include ::Mongo::Loggable
  include ::Mongo::ClusterTime::Consumer
  extend ::Forwardable

  def initialize(server_session, client, options = T.unsafe(nil)); end

  def abort_transaction(options = T.unsafe(nil)); end
  def aborting_transaction?; end
  def add_autocommit!(command); end
  def add_start_transaction!(command); end
  def add_txn_num!(command); end
  def add_txn_opts!(command, read, context); end
  def advance_operation_time(new_operation_time); end
  def client; end
  def cluster; end
  def commit_transaction(options = T.unsafe(nil)); end
  def committing_transaction?; end
  def dirty!(mark = T.unsafe(nil)); end
  def dirty?; end
  def end_session; end
  def ended?; end
  def explicit?; end
  def implicit?; end
  def in_transaction?; end
  def inspect; end
  def materialize_if_needed; end
  def materialized?; end
  def next_txn_num; end
  def operation_time; end
  def options; end
  def pin_to_connection(connection_global_id); end
  def pin_to_server(server); end
  def pinned_connection_global_id; end
  def pinned_server; end
  def process(result); end
  def recovery_token; end
  def recovery_token=(_arg0); end
  def retry_reads?; end
  def retry_writes?; end
  def session_id; end
  def snapshot?; end
  def snapshot_timestamp; end
  def snapshot_timestamp=(_arg0); end
  def start_transaction(options = T.unsafe(nil)); end
  def starting_transaction?; end
  def suppress_read_write_concern!(command); end
  def txn_num; end
  def txn_options; end
  def txn_read_preference; end
  def unpin(connection = T.unsafe(nil)); end
  def unpin_maybe(error, connection = T.unsafe(nil)); end
  def update_state!; end
  def validate!(client); end
  def validate_read_preference!(command); end
  def with_transaction(options = T.unsafe(nil)); end
  def with_transaction_deadline; end

  private

  def causal_consistency?; end
  def causal_consistency_doc; end
  def check_if_ended!; end
  def check_if_no_transaction!; end
  def check_matching_cluster!(client); end
  def check_transactions_supported!; end
  def operation_timeouts(opts); end
  def set_operation_time(result); end
  def txn_read_concern; end
  def txn_write_concern; end
  def within_states?(*states); end
end

Mongo::Session::MISMATCHED_CLUSTER_ERROR_MSG = T.let(T.unsafe(nil), String)
Mongo::Session::NO_TRANSACTION_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::SESSIONS_NOT_SUPPORTED = T.let(T.unsafe(nil), String)
Mongo::Session::SESSION_ENDED_ERROR_MSG = T.let(T.unsafe(nil), String)
Mongo::Session::STARTING_TRANSACTION_STATE = T.let(T.unsafe(nil), Symbol)

class Mongo::Session::ServerSession
  include ::Mongo::Session::ServerSession::Dirtyable

  def initialize; end

  def inspect; end
  def last_use; end
  def next_txn_num; end
  def session_id; end
  def set_last_use!; end
  def txn_num; end
end

Mongo::Session::ServerSession::DASH_REGEX = T.let(T.unsafe(nil), Regexp)

module Mongo::Session::ServerSession::Dirtyable
  def dirty!(mark = T.unsafe(nil)); end
  def dirty?; end
end

Mongo::Session::ServerSession::UUID_PACK = T.let(T.unsafe(nil), String)

class Mongo::Session::SessionPool
  def initialize(cluster); end

  def checkin(session); end
  def checkout; end
  def end_sessions; end
  def inspect; end

  private

  def about_to_expire?(session); end
  def prune!; end
  def return_to_queue?(session); end
end

Mongo::Session::TRANSACTION_ABORTED_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::TRANSACTION_COMMITTED_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::TRANSACTION_IN_PROGRESS_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::UNLABELED_WRITE_CONCERN_CODES = T.let(T.unsafe(nil), Array)

class Mongo::Socket
  include ::Socket::Constants

  def initialize(timeout, options); end

  def alive?; end
  def close; end
  def connectable?; end
  def connection_address; end
  def connection_generation; end
  def eof?; end
  def family; end
  def gets(*args); end
  def monitor?; end
  def options; end
  def pipe; end
  def read(length, socket_timeout: T.unsafe(nil), timeout: T.unsafe(nil)); end
  def readbyte; end
  def socket; end
  def summary; end
  def timeout; end
  def write(*args, timeout: T.unsafe(nil)); end

  private

  def allocate_string(capacity); end
  def do_write(*args, timeout: T.unsafe(nil)); end
  def human_address; end
  def map_exceptions; end
  def raise_timeout_error!(message = T.unsafe(nil), csot = T.unsafe(nil)); end
  def read_buffer_size; end
  def read_from_socket(length, socket_timeout: T.unsafe(nil), csot: T.unsafe(nil)); end
  def read_with_timeout(length, timeout); end
  def read_without_timeout(length, socket_timeout = T.unsafe(nil)); end
  def set_keepalive_opts(sock); end
  def set_option(sock, option, default); end
  def set_socket_options(sock); end
  def unix_socket?(sock); end
  def wait_for_socket_to_be_writable(deadline); end
  def write_chunk(chunk, timeout); end
  def write_with_timeout(*args, timeout:); end
  def write_without_timeout(*args); end
end

Mongo::Socket::DEFAULT_TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Mongo::Socket::DEFAULT_TCP_KEEPIDLE = T.let(T.unsafe(nil), Integer)
Mongo::Socket::DEFAULT_TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Mongo::Socket::DEFAULT_TCP_USER_TIMEOUT = T.let(T.unsafe(nil), Integer)

module Mongo::Socket::OcspCache
  private

  def clear; end
  def delete(cert_id); end
  def get(cert_id); end
  def responses; end
  def set(cert_id, response); end

  class << self
    def clear; end
    def delete(cert_id); end
    def get(cert_id); end
    def responses; end
    def set(cert_id, response); end
  end
end

Mongo::Socket::OcspCache::LOCK = T.let(T.unsafe(nil), Thread::Mutex)

class Mongo::Socket::OcspVerifier
  include ::Mongo::Loggable

  def initialize(host_name, cert, ca_cert, cert_store, **opts); end

  def ca_cert; end
  def cert; end
  def cert_id; end
  def cert_store; end
  def host_name; end
  def ocsp_uris; end
  def options; end
  def timeout; end
  def verify; end
  def verify_with_cache; end

  private

  def do_verify; end
  def handle_exceptions; end
  def raise_revoked_error(resp); end
  def report_response_body(body); end
  def report_uri(original_uri, uri); end
  def return_ocsp_response(resp, errors = T.unsafe(nil)); end
  def verify_one_responder(uri); end
end

class Mongo::Socket::SSL < ::Mongo::Socket
  include ::OpenSSL
  include ::Mongo::Loggable

  def initialize(host, port, host_name, timeout, family, options = T.unsafe(nil)); end

  def context; end
  def host; end
  def host_name; end
  def port; end
  def readbyte; end

  private

  def connect!; end
  def connect_tcp_socket_with_timeout(sockaddr, deadline, connect_timeout); end
  def connect_with_timeout(sockaddr, connect_timeout); end
  def connect_without_timeout(sockaddr); end
  def connnect_ssl_socket_with_timeout(deadline, connect_timeout); end
  def create_context(options); end
  def extract_certs(text); end
  def find_issuer(cert, cert_chain); end
  def human_address; end
  def load_private_key(text, passphrase); end
  def read_buffer_size; end
  def run_tls_context_hooks; end
  def set_cert(context, options); end
  def set_cert_verification(context, options); end
  def set_key(context, options); end
  def verify_certificate!(socket); end
  def verify_certificate?; end
  def verify_hostname?; end
  def verify_ocsp_endpoint!(socket, timeout = T.unsafe(nil)); end
  def verify_ocsp_endpoint?; end
  def with_select_timeout(deadline, connect_timeout, &block); end
end

Mongo::Socket::SSL::BEGIN_CERT = T.let(T.unsafe(nil), String)
Mongo::Socket::SSL::END_CERT = T.let(T.unsafe(nil), String)
Mongo::Socket::SSL_ERROR = T.let(T.unsafe(nil), String)

class Mongo::Socket::TCP < ::Mongo::Socket
  def initialize(host, port, timeout, family, options = T.unsafe(nil)); end

  def connect!; end
  def connect_with_timeout(sockaddr, connect_timeout); end
  def connect_without_timeout(sockaddr); end
  def host; end
  def port; end

  private

  def human_address; end
end

Mongo::Socket::TIMEOUT_ERROR = T.let(T.unsafe(nil), String)
Mongo::Socket::TIMEOUT_PACK = T.let(T.unsafe(nil), String)

class Mongo::Socket::Unix < ::Mongo::Socket
  def initialize(path, timeout, options = T.unsafe(nil)); end

  def path; end

  private

  def human_address; end
end

Mongo::Socket::WRITE_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)
module Mongo::Srv; end

class Mongo::Srv::Monitor
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread

  def initialize(cluster, **opts); end

  def cluster; end
  def last_result; end
  def options; end

  private

  def do_work; end
  def scan!; end
  def scan_interval; end
  def timeout; end
end

Mongo::Srv::Monitor::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Mongo::Srv::Monitor::MIN_SCAN_INTERVAL = T.let(T.unsafe(nil), Integer)

class Mongo::Srv::Resolver
  include ::Mongo::Loggable

  def initialize(**opts); end

  def get_records(hostname, srv_service_name = T.unsafe(nil), srv_max_hosts = T.unsafe(nil)); end
  def get_txt_options_string(hostname); end
  def options; end
  def record_prefix(srv_service_name = T.unsafe(nil)); end
  def timeout; end

  private

  def raise_on_invalid?; end
end

Mongo::Srv::Resolver::RECORD_PREFIX = T.let(T.unsafe(nil), String)

class Mongo::Srv::Result
  include ::Mongo::Address::Validator

  def initialize(hostname); end

  def add_record(record); end
  def address_strs; end
  def empty?; end
  def min_ttl; end
  def min_ttl=(_arg0); end
  def query_hostname; end

  private

  def normalize_hostname(host); end
  def validate_same_origin!(record_host); end
end

Mongo::Srv::Result::MISMATCHED_DOMAINNAME = T.let(T.unsafe(nil), String)

module Mongo::Timeout
  private

  def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil)); end

  class << self
    def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil)); end
  end
end

class Mongo::TopologyVersion < ::BSON::Document
  def initialize(doc); end

  def counter; end
  def gt?(other); end
  def gte?(other); end
  def process_id; end
  def to_doc; end
end

class Mongo::URI
  include ::Mongo::Loggable
  include ::Mongo::Address::Validator

  def initialize(string, options = T.unsafe(nil)); end

  def client_options; end
  def credentials; end
  def database; end
  def options; end
  def servers; end
  def srv_records; end
  def to_s; end
  def uri_options; end

  private

  def decode(value); end
  def encode(value); end
  def options_mapper; end
  def parse!(remaining); end
  def parse_database!(string); end
  def parse_password!(string); end
  def parse_uri_options!(string); end
  def parse_user!(string); end
  def raise_invalid_error!(details); end
  def raise_invalid_error_no_fmt!(details); end
  def reconstruct_uri; end
  def scheme; end
  def validate_uri_options!; end

  class << self
    def get(string, opts = T.unsafe(nil)); end
  end
end

Mongo::URI::AUTH_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::AUTH_MECH_MAP = T.let(T.unsafe(nil), Hash)
Mongo::URI::AUTH_USER_PWD_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::DATABASE_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::FORMAT = T.let(T.unsafe(nil), String)
Mongo::URI::HELP = T.let(T.unsafe(nil), String)
Mongo::URI::HOST_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::HOST_PORT_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INDIV_URI_OPTS_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_HOST = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_OPTS_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_OPTS_VALUE_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_PORT = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_SCHEME = T.let(T.unsafe(nil), String)
Mongo::URI::MONGODB_SCHEME = T.let(T.unsafe(nil), String)
Mongo::URI::MONGODB_SRV_SCHEME = T.let(T.unsafe(nil), String)

class Mongo::URI::OptionsMapper
  include ::Mongo::Loggable

  def initialize(**opts); end

  def add_uri_option(key, value, uri_options); end
  def options; end
  def ruby_to_smc(opts); end
  def ruby_to_string(opts); end
  def smc_to_ruby(opts); end

  private

  def apply_transform(key, value, type); end
  def convert_array(name, value); end
  def convert_auth_mech(name, value); end
  def convert_auth_mech_props(name, value); end
  def convert_bool(name, value); end
  def convert_integer(name, value); end
  def convert_inverse_bool(name, value); end
  def convert_max_staleness(name, value); end
  def convert_ms(name, value); end
  def convert_read_mode(name, value); end
  def convert_read_set(name, value); end
  def convert_read_tags(name, value); end
  def convert_repeated_bool(name, value); end
  def convert_symbol(name, value); end
  def convert_w(name, value); end
  def convert_zlib_compression_level(name, value); end
  def hash_extractor(name, value); end
  def merge_uri_option(target, value, name); end
  def revert_array(value); end
  def revert_auth_mech(value); end
  def revert_auth_mech_props(value); end
  def revert_bool(value); end
  def revert_integer(value); end
  def revert_inverse_bool(value); end
  def revert_max_staleness(value); end
  def revert_ms(value); end
  def revert_read_mode(value); end
  def revert_read_tags(value); end
  def revert_repeated_bool(value); end
  def revert_symbol(value); end
  def revert_w(value); end
  def revert_zlib_compression_level(value); end
  def stringify_array(value); end
  def stringify_auth_mech(value); end
  def stringify_auth_mech_props(value); end
  def stringify_bool(value); end
  def stringify_integer(value); end
  def stringify_inverse_bool(value); end
  def stringify_max_staleness(value); end
  def stringify_ms(value); end
  def stringify_read_mode(value); end
  def stringify_read_tags(value); end
  def stringify_repeated_bool(value); end
  def stringify_symbol(value); end
  def stringify_w(value); end
  def stringify_zlib_compression_level(value); end

  class << self
    def uri_option(uri_key, name, **extra); end
  end
end

Mongo::URI::OptionsMapper::URI_OPTION_CANONICAL_NAMES = T.let(T.unsafe(nil), Hash)
Mongo::URI::OptionsMapper::URI_OPTION_MAP = T.let(T.unsafe(nil), Hash)
Mongo::URI::PERCENT_CHAR = T.let(T.unsafe(nil), Regexp)
Mongo::URI::READ_MODE_MAP = T.let(T.unsafe(nil), Hash)
Mongo::URI::REPEATABLE_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::URI::SCHEME = T.let(T.unsafe(nil), String)
Mongo::URI::SCHEME_DELIM = T.let(T.unsafe(nil), String)

class Mongo::URI::SRVProtocol < ::Mongo::URI
  def client_options; end
  def query_hostname; end
  def srv_records; end
  def srv_result; end

  private

  def get_txt_options(hostname); end
  def parse!(remaining); end
  def parse_txt_options!(string); end
  def raise_invalid_error!(details); end
  def resolver; end
  def scheme; end
  def validate_srv_hostname(hostname); end
  def validate_uri_options!; end
end

Mongo::URI::SRVProtocol::DOT_PARTITION = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::FORMAT = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::INVALID_DOMAIN = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::INVALID_HOST = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::INVALID_PORT = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::NO_SRV_RECORDS = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::VALID_TXT_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::URI::UNESCAPED_DATABASE = T.let(T.unsafe(nil), String)
Mongo::URI::UNESCAPED_UNIX_SOCKET = T.let(T.unsafe(nil), String)
Mongo::URI::UNESCAPED_USER_PWD = T.let(T.unsafe(nil), String)
Mongo::URI::UNIX_SOCKET = T.let(T.unsafe(nil), Regexp)
Mongo::URI::UNSAFE = T.let(T.unsafe(nil), Regexp)
Mongo::URI::URI_OPTS_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::URI_OPTS_VALUE_DELIM = T.let(T.unsafe(nil), String)

module Mongo::Utils
  private

  def camelize(sym); end
  def excerpt_backtrace(exc, **opts); end
  def monotonic_time; end
  def shallow_camelize_keys(hash); end
  def shallow_symbolize_keys(hash); end
  def transform_server_api(server_api); end
  def warn_bg_exception(msg, exc, **opts); end

  class << self
    def camelize(sym); end
    def excerpt_backtrace(exc, **opts); end
    def monotonic_time; end
    def shallow_camelize_keys(hash); end
    def shallow_symbolize_keys(hash); end
    def transform_server_api(server_api); end
    def warn_bg_exception(msg, exc, **opts); end
  end
end

class Mongo::Utils::LocalLogger
  include ::Mongo::Loggable

  def initialize(**opts); end

  def options; end
end

Mongo::VERSION = T.let(T.unsafe(nil), String)

module Mongo::WriteConcern
  extend ::Mongo::WriteConcern

  def get(options); end
end

class Mongo::WriteConcern::Acknowledged < ::Mongo::WriteConcern::Base
  def acknowledged?; end
  def get_last_error; end
  def inspect; end
end

class Mongo::WriteConcern::Base
  def initialize(options); end

  def options; end
end

Mongo::WriteConcern::DEFAULT = T.let(T.unsafe(nil), Hash)
Mongo::WriteConcern::FSYNC = T.let(T.unsafe(nil), Symbol)
Mongo::WriteConcern::GET_LAST_ERROR = T.let(T.unsafe(nil), Symbol)
Mongo::WriteConcern::J = T.let(T.unsafe(nil), Symbol)

class Mongo::WriteConcern::Unacknowledged < ::Mongo::WriteConcern::Base
  def acknowledged?; end
  def get_last_error; end
  def inspect; end
end

Mongo::WriteConcern::Unacknowledged::NOOP = T.let(T.unsafe(nil), T.untyped)
Mongo::WriteConcern::W = T.let(T.unsafe(nil), Symbol)
Mongo::WriteConcern::WTIMEOUT = T.let(T.unsafe(nil), Symbol)

class Symbol
  include ::Comparable

  def bson_type; end
end

module UnicodeNormalize; end
