# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-session` gem.
# Please instead update this file by running `bin/tapioca gem rack-session`.


module Rack
  class << self
    def release; end
  end
end

module Rack::Session; end
module Rack::Session::Abstract; end

class Rack::Session::Abstract::ID < ::Rack::Session::Abstract::Persisted
  def delete_session(req, sid, options); end
  def find_session(req, sid); end
  def write_session(req, sid, session, options); end

  class << self
    def inherited(klass); end
  end
end

class Rack::Session::Abstract::Persisted
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end
  def commit_session(req, res); end
  def context(env, app = T.unsafe(nil)); end
  def default_options; end
  def key; end
  def same_site; end
  def sid_secure; end

  private

  def commit_session?(req, session, options); end
  def cookie_value(data); end
  def current_session_id(req); end
  def delete_session(req, sid, options); end
  def extract_session_id(request); end
  def find_session(env, sid); end
  def force_options?(options); end
  def forced_session_update?(session, options); end
  def generate_sid(secure = T.unsafe(nil)); end
  def initialize_sid; end
  def load_session(req); end
  def loaded_session?(session); end
  def make_request(env); end
  def prepare_session(req); end
  def security_matches?(request, options); end
  def session_class; end
  def session_exists?(req); end
  def set_cookie(request, response, cookie); end
  def write_session(req, sid, session, options); end
end

Rack::Session::Abstract::Persisted::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::Abstract::PersistedSecure < ::Rack::Session::Abstract::Persisted
  def extract_session_id(*_arg0); end
  def generate_sid(*_arg0); end

  private

  def cookie_value(data); end
  def session_class; end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash < ::Rack::Session::Abstract::SessionHash
  def [](key); end
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable

  def initialize(store, req); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def destroy; end
  def dig(key, *keys); end
  def each(&block); end
  def empty?; end
  def exists?; end
  def fetch(key, default = T.unsafe(nil), &block); end
  def has_key?(key); end
  def id; end
  def id=(_arg0); end
  def include?(key); end
  def inspect; end
  def key?(key); end
  def keys; end
  def loaded?; end
  def merge!(hash); end
  def options; end
  def replace(hash); end
  def store(key, value); end
  def to_hash; end
  def update(hash); end
  def values; end

  private

  def load!; end
  def load_for_read!; end
  def load_for_write!; end
  def stringify_keys(other); end

  class << self
    def find(req); end
    def set(req, session); end
    def set_options(req, options); end
  end
end

Rack::Session::Abstract::SessionHash::Unspecified = T.let(T.unsafe(nil), Object)

class Rack::Session::Cookie < ::Rack::Session::Abstract::PersistedSecure
  def initialize(app, options = T.unsafe(nil)); end

  def coder; end
  def encryptors; end

  private

  def delete_session(req, session_id, options); end
  def encode_session_data(session); end
  def extract_session_id(request); end
  def find_session(req, sid); end
  def legacy_digest_match?(data, digest); end
  def legacy_generate_hmac(data); end
  def persistent_session_id!(data, sid = T.unsafe(nil)); end
  def secure?(options); end
  def unpacked_cookie_data(request); end
  def write_session(req, session_id, session, options); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::Marshal < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::Base64::ZipJSON < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(obj); end
end

class Rack::Session::Cookie::Identity
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::Marshal
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::SessionId
  def initialize(session_id, cookie_value); end

  def cookie_value; end
end

class Rack::Session::Encryptor
  def initialize(secret, opts = T.unsafe(nil)); end

  def decrypt(base64_data); end
  def encrypt(message); end

  private

  def cipher_secret_from_message_secret(message_secret); end
  def compute_signature(data); end
  def deserialized_message(data); end
  def new_cipher; end
  def new_message_and_cipher_secret; end
  def serialize_payload(message); end
  def serializer; end
  def set_cipher_key(cipher, key); end
  def verify_authenticity!(data, signature); end
end

class Rack::Session::Encryptor::Error < ::StandardError; end
class Rack::Session::Encryptor::InvalidMessage < ::Rack::Session::Encryptor::Error; end
class Rack::Session::Encryptor::InvalidSignature < ::Rack::Session::Encryptor::Error; end
Rack::Session::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::Session::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::Session::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)

class Rack::Session::SessionId
  def initialize(public_id); end

  def cookie_value; end
  def empty?; end
  def inspect; end
  def private_id; end
  def public_id; end
  def to_s; end

  private

  def hash_sid(sid); end
end

Rack::Session::SessionId::ID_VERSION = T.let(T.unsafe(nil), Integer)
