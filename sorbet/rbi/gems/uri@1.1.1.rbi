# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `uri` gem.
# Please instead update this file by running `bin/tapioca gem uri`.


module Kernel
  private

  def URI(uri); end

  class << self
    def URI(uri); end
  end
end

module URI
  class << self
    def const_missing(const); end
    def decode_uri_component(str, enc = T.unsafe(nil)); end
    def decode_www_form(str, enc = T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end
    def decode_www_form_component(str, enc = T.unsafe(nil)); end
    def encode_uri_component(str, enc = T.unsafe(nil)); end
    def encode_www_form(enum, enc = T.unsafe(nil)); end
    def encode_www_form_component(str, enc = T.unsafe(nil)); end
    def extract(str, schemes = T.unsafe(nil), &block); end
    def for(scheme, *arguments, default: T.unsafe(nil)); end
    def get_encoding(label); end
    def join(*str); end
    def parse(uri); end
    def parser=(parser = T.unsafe(nil)); end
    def regexp(schemes = T.unsafe(nil)); end
    def register_scheme(scheme, klass); end
    def scheme_list; end
    def split(uri); end

    private

    def _decode_uri_component(regexp, str, enc); end
    def _encode_uri_component(regexp, table, str, enc); end
  end
end

class URI::FTP < ::URI::Generic
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end

  def merge(oth); end
  def path; end
  def to_s; end
  def typecode; end
  def typecode=(typecode); end

  protected

  def set_path(v); end
  def set_typecode(v); end

  private

  def check_typecode(v); end

  class << self
    def build(args); end
    def new2(user, password, host, port, path, typecode = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  end
end

class URI::File < ::URI::Generic
  def check_password(user); end
  def check_user(user); end
  def check_userinfo(user); end
  def set_host(v); end
  def set_password(v); end
  def set_port(v); end
  def set_user(v); end
  def set_userinfo(v); end

  class << self
    def build(args); end
  end
end

URI::File::COMPONENT = T.let(T.unsafe(nil), Array)
URI::File::DEFAULT_PORT = T.let(T.unsafe(nil), T.untyped)

class URI::Generic
  include ::URI

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end

  def +(oth); end
  def -(oth); end
  def ==(oth); end
  def absolute; end
  def absolute?; end
  def authority; end
  def coerce(oth); end
  def component; end
  def decoded_password; end
  def decoded_user; end
  def default_port; end
  def eql?(oth); end
  def find_proxy(env = T.unsafe(nil)); end
  def fragment; end
  def fragment=(v); end
  def hash; end
  def hierarchical?; end
  def host; end
  def host=(v); end
  def hostname; end
  def hostname=(v); end
  def inspect; end
  def merge(oth); end
  def merge!(oth); end
  def normalize; end
  def normalize!; end
  def opaque; end
  def opaque=(v); end
  def parser; end
  def password; end
  def password=(password); end
  def path; end
  def path=(v); end
  def port; end
  def port=(v); end
  def query; end
  def query=(v); end
  def registry; end
  def registry=(v); end
  def relative?; end
  def route_from(oth); end
  def route_to(oth); end
  def scheme; end
  def scheme=(v); end
  def select(*components); end
  def to_s; end
  def to_str; end
  def user; end
  def user=(user); end
  def userinfo; end
  def userinfo=(userinfo); end

  protected

  def component_ary; end
  def set_authority(user, password, host, port = T.unsafe(nil)); end
  def set_host(v); end
  def set_opaque(v); end
  def set_password(v); end
  def set_path(v); end
  def set_port(v); end
  def set_registry(v); end
  def set_scheme(v); end
  def set_user(v); end
  def set_userinfo(user, password = T.unsafe(nil)); end

  private

  def check_host(v); end
  def check_opaque(v); end
  def check_password(v, user = T.unsafe(nil)); end
  def check_path(v); end
  def check_port(v); end
  def check_registry(v); end
  def check_scheme(v); end
  def check_user(v); end
  def check_userinfo(user, password = T.unsafe(nil)); end
  def escape_userpass(v); end
  def merge_path(base, rel); end
  def replace!(oth); end
  def route_from0(oth); end
  def route_from_path(src, dst); end
  def split_path(path); end
  def split_userinfo(ui); end

  class << self
    def build(args); end
    def build2(args); end
    def component; end
    def default_port; end
    def use_proxy?(hostname, addr, port, no_proxy); end
    def use_registry; end
  end
end

class URI::HTTP < ::URI::Generic
  def authority; end
  def check_host(v); end
  def origin; end
  def request_uri; end

  class << self
    def build(args); end
  end
end

URI::INITIAL_SCHEMES = T.let(T.unsafe(nil), Hash)

class URI::LDAP < ::URI::Generic
  def initialize(*arg); end

  def attributes; end
  def attributes=(val); end
  def dn; end
  def dn=(val); end
  def extensions; end
  def extensions=(val); end
  def filter; end
  def filter=(val); end
  def hierarchical?; end
  def scope; end
  def scope=(val); end

  protected

  def set_attributes(val); end
  def set_dn(val); end
  def set_extensions(val); end
  def set_filter(val); end
  def set_scope(val); end

  private

  def build_path_query; end
  def parse_dn; end
  def parse_query; end

  class << self
    def build(args); end
  end
end

class URI::MailTo < ::URI::Generic
  include ::URI::RFC2396_REGEXP

  def initialize(*arg); end

  def headers; end
  def headers=(v); end
  def to; end
  def to=(v); end
  def to_mailtext; end
  def to_rfc822text; end
  def to_s; end

  protected

  def set_headers(v); end
  def set_to(v); end

  private

  def check_headers(v); end
  def check_to(v); end

  class << self
    def build(args); end
  end
end

URI::PARSER = T.let(T.unsafe(nil), URI::RFC3986_Parser)

class URI::RFC2396_Parser
  include ::URI::RFC2396_REGEXP

  def initialize(opts = T.unsafe(nil)); end

  def escape(str, unsafe = T.unsafe(nil)); end
  def extract(str, schemes = T.unsafe(nil)); end
  def inspect; end
  def join(*uris); end
  def make_regexp(schemes = T.unsafe(nil)); end
  def parse(uri); end
  def pattern; end
  def regexp; end
  def split(uri); end
  def unescape(str, escaped = T.unsafe(nil)); end

  private

  def convert_to_uri(uri); end
  def initialize_pattern(opts = T.unsafe(nil)); end
  def initialize_regexp(pattern); end
end

URI::RFC2396_Parser::TO_S = T.let(T.unsafe(nil), UnboundMethod)

class URI::RFC3986_Parser
  def initialize; end

  def escape(str, unsafe = T.unsafe(nil)); end
  def extract(str, schemes = T.unsafe(nil), &block); end
  def inspect; end
  def join(*uris); end
  def make_regexp(schemes = T.unsafe(nil)); end
  def parse(uri); end
  def regexp; end
  def split(uri); end
  def unescape(str, escaped = T.unsafe(nil)); end

  private

  def convert_to_uri(uri); end
  def default_regexp; end
end

URI::RFC3986_Parser::FRAGMENT = T.let(T.unsafe(nil), String)
URI::RFC3986_Parser::HOST = T.let(T.unsafe(nil), Regexp)
URI::RFC3986_Parser::RFC3986_relative_ref = T.let(T.unsafe(nil), Regexp)
URI::RFC3986_Parser::SCHEME = T.let(T.unsafe(nil), String)
URI::RFC3986_Parser::SEG = T.let(T.unsafe(nil), String)
URI::RFC3986_Parser::SEG_NC = T.let(T.unsafe(nil), String)
URI::RFC3986_Parser::USERINFO = T.let(T.unsafe(nil), Regexp)

module URI::Schemes
  class << self
    def escape(name); end
    def find(name); end
    def list; end
    def register(name, klass); end
    def unescape(name); end
  end
end

URI::Schemes::FILE = URI::File
URI::Schemes::FTP = URI::FTP
URI::Schemes::HTTP = URI::HTTP
URI::Schemes::HTTPS = URI::HTTPS
URI::Schemes::LDAP = URI::LDAP
URI::Schemes::LDAPS = URI::LDAPS
URI::Schemes::MAILTO = URI::MailTo
URI::Schemes::WS = URI::WS
URI::Schemes::WSS = URI::WSS
URI::TBLENCURICOMP_ = T.let(T.unsafe(nil), Hash)

module URI::Util
  private

  def make_components_hash(klass, array_hash); end

  class << self
    def make_components_hash(klass, array_hash); end
  end
end

class URI::WS < ::URI::Generic
  def request_uri; end

  class << self
    def build(args); end
  end
end

class URI::WSS < ::URI::WS; end
URI::WSS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
