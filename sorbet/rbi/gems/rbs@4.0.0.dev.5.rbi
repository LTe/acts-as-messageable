# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rbs` gem.
# Please instead update this file by running `bin/tapioca gem rbs`.


module RBS
  class << self
    def logger; end
    def logger_level; end
    def logger_level=(level); end
    def logger_output; end
    def logger_output=(val); end
    def print_warning; end
  end
end

module RBS::AST; end

class RBS::AST::Annotation
  def initialize(string:, location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def string; end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Comment
  def initialize(string:, location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def string; end
  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Declarations; end

class RBS::AST::Declarations::AliasDecl < ::RBS::AST::Declarations::Base
  def initialize(new_name:, old_name:, location:, comment:, annotations: T.unsafe(nil)); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def new_name; end
  def old_name; end
end

class RBS::AST::Declarations::Base; end

class RBS::AST::Declarations::Class < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper

  def initialize(name:, type_params:, super_class:, members:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def members; end
  def name; end
  def super_class; end
  def to_json(state = T.unsafe(nil)); end
  def type_params; end
  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), super_class: T.unsafe(nil), members: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Class::Super
  def initialize(name:, args:, location:); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Declarations::ClassAlias < ::RBS::AST::Declarations::AliasDecl
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Declarations::Constant < ::RBS::AST::Declarations::Base
  def initialize(name:, type:, location:, comment:, annotations: T.unsafe(nil)); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type; end
end

class RBS::AST::Declarations::Global < ::RBS::AST::Declarations::Base
  def initialize(name:, type:, location:, comment:, annotations: T.unsafe(nil)); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type; end
end

class RBS::AST::Declarations::Interface < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::MixinHelper

  def initialize(name:, type_params:, members:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def members; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type_params; end
  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), members: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

module RBS::AST::Declarations::MixinHelper
  def each_mixin(&block); end
end

class RBS::AST::Declarations::Module < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper

  def initialize(name:, type_params:, members:, self_types:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def members; end
  def name; end
  def self_types; end
  def to_json(state = T.unsafe(nil)); end
  def type_params; end
  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), members: T.unsafe(nil), self_types: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Module::Self
  def initialize(name:, args:, location:); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
end

class RBS::AST::Declarations::ModuleAlias < ::RBS::AST::Declarations::AliasDecl
  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Declarations::NestedDeclarationHelper
  def each_decl; end
  def each_member; end
end

class RBS::AST::Declarations::TypeAlias < ::RBS::AST::Declarations::Base
  def initialize(name:, type_params:, type:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def type; end
  def type_params; end
end

module RBS::AST::Directives; end
class RBS::AST::Directives::Base; end

class RBS::AST::Directives::ResolveTypeNames < ::RBS::AST::Directives::Base
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class RBS::AST::Directives::Use < ::RBS::AST::Directives::Base
  def initialize(clauses:, location:); end

  def clauses; end
  def location; end
end

class RBS::AST::Directives::Use::SingleClause
  def initialize(type_name:, new_name:, location:); end

  def location; end
  def new_name; end
  def type_name; end
end

class RBS::AST::Directives::Use::WildcardClause
  def initialize(namespace:, location:); end

  def location; end
  def namespace; end
end

module RBS::AST::Members; end

class RBS::AST::Members::Alias < ::RBS::AST::Members::Base
  def initialize(new_name:, old_name:, kind:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def instance?; end
  def kind; end
  def location; end
  def new_name; end
  def old_name; end
  def singleton?; end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::AttrAccessor < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::AttrReader < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::AttrWriter < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute

  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Members::Attribute
  def initialize(name:, type:, ivar_name:, kind:, annotations:, location:, comment:, visibility: T.unsafe(nil)); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def ivar_name; end
  def kind; end
  def location; end
  def name; end
  def type; end
  def update(name: T.unsafe(nil), type: T.unsafe(nil), ivar_name: T.unsafe(nil), kind: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), visibility: T.unsafe(nil)); end
  def visibility; end
end

class RBS::AST::Members::Base; end

class RBS::AST::Members::ClassInstanceVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::ClassVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Extend < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Include < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::InstanceVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var

  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Members::LocationOnly
  def initialize(location:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
end

class RBS::AST::Members::MethodDefinition < ::RBS::AST::Members::Base
  def initialize(name:, kind:, overloads:, annotations:, location:, comment:, overloading:, visibility:); end

  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def instance?; end
  def kind; end
  def location; end
  def name; end
  def overloading; end
  def overloading?; end
  def overloads; end
  def singleton?; end
  def to_json(state = T.unsafe(nil)); end
  def update(name: T.unsafe(nil), kind: T.unsafe(nil), overloads: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), overloading: T.unsafe(nil), visibility: T.unsafe(nil)); end
  def visibility; end
end

class RBS::AST::Members::MethodDefinition::Overload
  def initialize(method_type:, annotations:); end

  def ==(other); end
  def annotations; end
  def eql?(other); end
  def hash; end
  def method_type; end
  def sub(subst); end
  def to_json(state = T.unsafe(nil)); end
  def update(annotations: T.unsafe(nil), method_type: T.unsafe(nil)); end
end

module RBS::AST::Members::Mixin
  def initialize(name:, args:, annotations:, location:, comment:); end

  def ==(other); end
  def annotations; end
  def args; end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
end

class RBS::AST::Members::Prepend < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Private < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::LocationOnly

  def to_json(state = T.unsafe(nil)); end
end

class RBS::AST::Members::Public < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::LocationOnly

  def to_json(state = T.unsafe(nil)); end
end

module RBS::AST::Members::Var
  def initialize(name:, type:, location:, comment:); end

  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def location; end
  def name; end
  def type; end
end

module RBS::AST::Ruby; end
module RBS::AST::Ruby::Annotations; end

class RBS::AST::Ruby::Annotations::AliasAnnotation < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, keyword_location:, type_name:, type_name_location:); end

  def keyword_location; end
  def map_type_name; end
  def type_name; end
  def type_name_location; end
end

class RBS::AST::Ruby::Annotations::Base
  def initialize(location, prefix_location); end

  def buffer; end
  def location; end
  def prefix_location; end
end

class RBS::AST::Ruby::Annotations::ClassAliasAnnotation < ::RBS::AST::Ruby::Annotations::AliasAnnotation
  def type_fingerprint; end
end

class RBS::AST::Ruby::Annotations::ColonMethodTypeAnnotation < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, annotations:, method_type:); end

  def annotations; end
  def map_type_name; end
  def method_type; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Annotations::InstanceVariableAnnotation < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, ivar_name:, ivar_name_location:, colon_location:, type:, comment_location:); end

  def colon_location; end
  def comment_location; end
  def ivar_name; end
  def ivar_name_location; end
  def map_type_name(&block); end
  def type; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Annotations::MethodTypesAnnotation < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, overloads:, vertical_bar_locations:); end

  def map_type_name(&block); end
  def overloads; end
  def type_fingerprint; end
  def vertical_bar_locations; end
end

RBS::AST::Ruby::Annotations::MethodTypesAnnotation::Overload = RBS::AST::Members::MethodDefinition::Overload

class RBS::AST::Ruby::Annotations::ModuleAliasAnnotation < ::RBS::AST::Ruby::Annotations::AliasAnnotation
  def type_fingerprint; end
end

class RBS::AST::Ruby::Annotations::NodeTypeAssertion < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, type:); end

  def map_type_name; end
  def type; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Annotations::ReturnTypeAnnotation < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, return_location:, colon_location:, return_type:, comment_location:); end

  def colon_location; end
  def comment_location; end
  def map_type_name(&block); end
  def return_location; end
  def return_type; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Annotations::SkipAnnotation < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, skip_location:, comment_location:); end

  def comment_location; end
  def skip_location; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Annotations::TypeApplicationAnnotation < ::RBS::AST::Ruby::Annotations::Base
  def initialize(location:, prefix_location:, type_args:, close_bracket_location:, comma_locations:); end

  def close_bracket_location; end
  def comma_locations; end
  def map_type_name(&block); end
  def type_args; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::CommentBlock
  def initialize(source_buffer, comments); end

  def as_comment; end
  def comment_buffer; end
  def comments; end
  def each_paragraph(variables, &block); end
  def end_line; end
  def leading?; end
  def leading_annotation?(index); end
  def line_location(start_line, end_line); end
  def line_starts; end
  def location; end
  def name; end
  def offsets; end
  def parse_annotation_lines(start_line, end_line, variables); end
  def start_line; end
  def text(comment_index); end
  def trailing?; end
  def trailing_annotation(variables); end
  def yield_annotation(start_line, end_line, current_line, variables, &block); end
  def yield_paragraph(start_line, current_line, variables, &block); end

  class << self
    def build(buffer, comments); end
  end
end

class RBS::AST::Ruby::CommentBlock::AnnotationSyntaxError < ::Struct
  def error; end
  def error=(_); end
  def location; end
  def location=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RBS::AST::Ruby::Declarations; end

class RBS::AST::Ruby::Declarations::Base
  include ::RBS::AST::Ruby::Helpers::ConstantHelper
  include ::RBS::AST::Ruby::Helpers::LocationHelper

  def initialize(buffer); end

  def buffer; end
end

class RBS::AST::Ruby::Declarations::ClassDecl < ::RBS::AST::Ruby::Declarations::Base
  def initialize(buffer, name, node, super_class); end

  def class_name; end
  def each_decl(&block); end
  def location; end
  def members; end
  def name_location; end
  def node; end
  def super_class; end
  def type_fingerprint; end
  def type_params; end
end

class RBS::AST::Ruby::Declarations::ClassDecl::SuperClass
  def initialize(type_name_location, operator_location, type_name, type_annotation); end

  def args; end
  def location; end
  def name; end
  def operator_location; end
  def type_annotation; end
  def type_args; end
  def type_fingerprint; end
  def type_name; end
  def type_name_location; end
end

class RBS::AST::Ruby::Declarations::ClassModuleAliasDecl < ::RBS::AST::Ruby::Declarations::Base
  def initialize(buffer, node, new_name, infered_old_name, leading_comment, annotation); end

  def annotation; end
  def comment; end
  def infered_old_name; end
  def leading_comment; end
  def location; end
  def name_location; end
  def new_name; end
  def node; end
  def old_name; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Declarations::ConstantDecl < ::RBS::AST::Ruby::Declarations::Base
  def initialize(buffer, constant_name, node, leading_comment, type_annotation); end

  def comment; end
  def constant_name; end
  def leading_comment; end
  def location; end
  def name_location; end
  def node; end
  def type; end
  def type_annotation; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Declarations::ModuleDecl < ::RBS::AST::Ruby::Declarations::Base
  def initialize(buffer, name, node); end

  def each_decl(&block); end
  def location; end
  def members; end
  def module_name; end
  def name_location; end
  def node; end
  def self_types; end
  def type_fingerprint; end
  def type_params; end
end

module RBS::AST::Ruby::Helpers; end

module RBS::AST::Ruby::Helpers::ConstantHelper
  private

  def constant_as_type_name(node); end

  class << self
    def constant_as_type_name(node); end
  end
end

module RBS::AST::Ruby::Helpers::LocationHelper
  def rbs_location(location); end
end

module RBS::AST::Ruby::Members; end
class RBS::AST::Ruby::Members::AttrAccessorMember < ::RBS::AST::Ruby::Members::AttributeMember; end
class RBS::AST::Ruby::Members::AttrReaderMember < ::RBS::AST::Ruby::Members::AttributeMember; end
class RBS::AST::Ruby::Members::AttrWriterMember < ::RBS::AST::Ruby::Members::AttributeMember; end

class RBS::AST::Ruby::Members::AttributeMember < ::RBS::AST::Ruby::Members::Base
  def initialize(buffer, node, name_nodes, leading_comment, type_annotation); end

  def leading_comment; end
  def location; end
  def name_locations; end
  def name_nodes; end
  def names; end
  def node; end
  def type; end
  def type_annotation; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Members::Base
  include ::RBS::AST::Ruby::Helpers::LocationHelper

  def initialize(buffer); end

  def buffer; end
end

class RBS::AST::Ruby::Members::DefMember < ::RBS::AST::Ruby::Members::Base
  def initialize(buffer, name, node, method_type, leading_comment); end

  def annotations; end
  def leading_comment; end
  def location; end
  def method_type; end
  def name; end
  def name_location; end
  def node; end
  def overloading?; end
  def overloads; end
  def type_fingerprint; end
end

RBS::AST::Ruby::Members::DefMember::Overload = RBS::AST::Members::MethodDefinition::Overload
class RBS::AST::Ruby::Members::ExtendMember < ::RBS::AST::Ruby::Members::MixinMember; end
class RBS::AST::Ruby::Members::IncludeMember < ::RBS::AST::Ruby::Members::MixinMember; end

class RBS::AST::Ruby::Members::InstanceVariableMember < ::RBS::AST::Ruby::Members::Base
  def initialize(buffer, annotation); end

  def annotation; end
  def location; end
  def name; end
  def type; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Members::MethodTypeAnnotation
  def initialize(type_annotations:); end

  def empty?; end
  def map_type_name(&block); end
  def overloads; end
  def type_annotations; end
  def type_fingerprint; end

  class << self
    def build(leading_block, trailing_block, variables); end
  end
end

class RBS::AST::Ruby::Members::MethodTypeAnnotation::DocStyle
  def initialize; end

  def map_type_name(&block); end
  def method_type; end
  def return_type_annotation; end
  def return_type_annotation=(_arg0); end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Members::MixinMember < ::RBS::AST::Ruby::Members::Base
  def initialize(buffer, node, module_name, annotation); end

  def annotation; end
  def location; end
  def module_name; end
  def name_location; end
  def node; end
  def type_args; end
  def type_fingerprint; end
end

class RBS::AST::Ruby::Members::PrependMember < ::RBS::AST::Ruby::Members::MixinMember; end

class RBS::AST::TypeParam
  def initialize(name:, variance:, upper_bound:, lower_bound:, location:, default_type: T.unsafe(nil), unchecked: T.unsafe(nil)); end

  def ==(other); end
  def default_type; end
  def eql?(other); end
  def hash; end
  def location; end
  def lower_bound; end
  def lower_bound_type; end
  def map_type(&block); end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
  def unchecked!(value = T.unsafe(nil)); end
  def unchecked?; end
  def upper_bound; end
  def upper_bound_type; end
  def variance; end

  class << self
    def application(params, args); end
    def normalize_args(params, args); end
    def rename(params, new_names:); end
    def resolve_variables(params); end
    def subst_var(vars, type); end
    def validate(type_params); end
  end
end

class RBS::AST::Visitor
  def visit(node); end
  def visit_all(nodes); end
  def visit_declaration_class(node); end
  def visit_declaration_constant(node); end
  def visit_declaration_global(node); end
  def visit_declaration_interface(node); end
  def visit_declaration_module(node); end
  def visit_declaration_type_alias(node); end
  def visit_member_alias(node); end
  def visit_member_attr_accessor(node); end
  def visit_member_attr_reader(node); end
  def visit_member_attr_writer(node); end
  def visit_member_class_instance_variable(node); end
  def visit_member_class_variable(node); end
  def visit_member_extend(node); end
  def visit_member_include(node); end
  def visit_member_instance_variable(node); end
  def visit_member_method_definition(node); end
  def visit_member_prepend(node); end
  def visit_member_private(node); end
  def visit_member_public(node); end
end

class RBS::AncestorGraph
  def initialize(env:, ancestor_builder: T.unsafe(nil)); end

  def ancestor_builder; end
  def build; end
  def build_ancestors(node, ancestors); end
  def children; end
  def each_ancestor(node, yielded: T.unsafe(nil), &block); end
  def each_child(node, &block); end
  def each_descendant(node, yielded: T.unsafe(nil), &block); end
  def each_parent(node, &block); end
  def env; end
  def parents; end
  def register(parent:, child:); end
end

class RBS::AncestorGraph::InstanceNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::AncestorGraph::SingletonNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::BaseError < ::StandardError; end

class RBS::Buffer
  def initialize(content:, name: T.unsafe(nil), parent: T.unsafe(nil)); end

  def absolute_position(position); end
  def content; end
  def detach; end
  def inspect; end
  def last_position; end
  def line_count; end
  def lines; end
  def loc_to_pos(loc); end
  def name; end
  def parent; end
  def parent_buffer; end
  def parent_position(position); end
  def pos_to_loc(pos); end
  def ranges; end
  def rbs_location(location, loc2 = T.unsafe(nil)); end
  def sub_buffer(lines:); end
  def top_buffer; end
end

module RBS::BuiltinNames; end
RBS::BuiltinNames::Array = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::BasicObject = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Class = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Comparable = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Enumerable = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Enumerator = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::FalseClass = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Float = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Hash = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Integer = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Kernel = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Module = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

class RBS::BuiltinNames::Name
  def initialize(name:); end

  def instance_type(*args); end
  def instance_type?(type); end
  def name; end
  def singleton_type; end
  def singleton_type?(type); end
  def to_s; end

  class << self
    def define(name, namespace: T.unsafe(nil)); end
  end
end

RBS::BuiltinNames::Numeric = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Object = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Range = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Regexp = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Set = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::String = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::Symbol = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
RBS::BuiltinNames::TrueClass = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)
class RBS::CLI; end

class RBS::CLI::ColoredIO
  def initialize(stdout:); end

  def puts(*_arg0, **_arg1, &_arg2); end
  def puts_green(string); end
  def puts_red(string); end
  def stdout; end

  private

  def are_colors_disabled?; end
  def are_colors_supported?; end
  def can_display_colors?; end
end

class RBS::ClassInstanceVariableDuplicationError < ::RBS::VariableDuplicationError
  def kind; end
end

module RBS::Collection; end

class RBS::Collection::Cleaner
  def initialize(lockfile_path:); end

  def clean; end
  def lock; end
  def needed?(gem_name, version); end
end

class RBS::Collection::Config
  def initialize(data, config_path:); end

  def config_path; end
  def data; end
  def gem(gem_name); end
  def gems; end
  def repo_path; end
  def repo_path_data; end
  def sources; end

  class << self
    def find_config_path; end
    def from_path(path); end
    def generate_lockfile(config_path:, definition:, with_lockfile: T.unsafe(nil)); end
    def to_lockfile_path(config_path); end
  end
end

class RBS::Collection::Config::CollectionNotAvailable < ::StandardError
  def initialize; end
end

class RBS::Collection::Config::Lockfile
  def initialize(lockfile_path:, path:, gemfile_lock_path:); end

  def check_rbs_availability!; end
  def fullpath; end
  def gemfile_lock_fullpath; end
  def gemfile_lock_path; end
  def gems; end
  def library_data(lib); end
  def lockfile_dir; end
  def lockfile_path; end
  def path; end
  def sources; end
  def to_lockfile; end

  class << self
    def from_lockfile(lockfile_path:, data:); end
  end
end

class RBS::Collection::Config::LockfileGenerator
  def initialize(config:, definition:, with_lockfile:); end

  def config; end
  def definition; end
  def existing_lockfile; end
  def gem_entries; end
  def gem_hash; end
  def generate; end
  def lockfile; end

  private

  def assign_gem(name:, version:, skip: T.unsafe(nil)); end
  def assign_stdlib(name:, from_gem: T.unsafe(nil)); end
  def find_best_version(version:, versions:); end
  def find_source(name:); end
  def validate_gemfile_lock_path!(lock:, gemfile_lock_path:); end

  class << self
    def generate(config:, definition:, with_lockfile: T.unsafe(nil)); end
  end
end

RBS::Collection::Config::LockfileGenerator::ALUMNI_STDLIBS = T.let(T.unsafe(nil), Hash)

class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError < ::StandardError
  def initialize(expected:, actual:); end

  def message; end
end

RBS::Collection::Config::PATH = T.let(T.unsafe(nil), Pathname)

class RBS::Collection::Installer
  def initialize(lockfile_path:, stdout: T.unsafe(nil)); end

  def install_from_lockfile; end
  def lockfile; end
  def stdout; end
end

module RBS::Collection::Sources
  class << self
    def from_config_entry(source_entry, base_directory:); end
  end
end

module RBS::Collection::Sources::Base
  def dependencies_of(name, version); end
end

class RBS::Collection::Sources::Git
  include ::RBS::Collection::Sources::Base

  def initialize(name:, revision:, remote:, repo_dir:); end

  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def load_metadata(dir:); end
  def manifest_of(name, version); end
  def metadata_content(name:, version:); end
  def name; end
  def remote; end
  def repo_dir; end
  def resolved_revision; end
  def revision; end
  def to_lockfile; end
  def versions(name); end
  def write_metadata(dir:, name:, version:); end

  private

  def _install(dest:, name:, version:); end
  def commit_hash?; end
  def cp_r(src, dest); end
  def format_config_entry(name, version); end
  def gem_repo_dir; end
  def gems_versions; end
  def git(*cmd, **opt); end
  def git?(*cmd, **opt); end
  def git_dir; end
  def need_to_fetch?(revision); end
  def setup!; end
  def sh!(*cmd, **opt); end
end

class RBS::Collection::Sources::Git::CommandError < ::StandardError; end
RBS::Collection::Sources::Git::METADATA_FILENAME = T.let(T.unsafe(nil), String)

class RBS::Collection::Sources::Local
  include ::RBS::Collection::Sources::Base

  def initialize(path:, base_directory:); end

  def full_path; end
  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def manifest_of(name, version); end
  def path; end
  def to_lockfile; end
  def versions(name); end

  private

  def _install(src, dst); end
end

class RBS::Collection::Sources::Rubygems
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def manifest_of(name, version); end
  def to_lockfile; end
  def versions(name); end

  private

  def gem_sig_path(name, version); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

class RBS::Collection::Sources::Stdlib
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def has?(name, version); end
  def install(dest:, name:, version:, stdout:); end
  def manifest_of(name, version); end
  def to_lockfile; end
  def versions(name); end

  private

  def lookup(name, version); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

RBS::Collection::Sources::Stdlib::REPO = T.let(T.unsafe(nil), RBS::Repository)

class RBS::Constant
  def initialize(name:, type:, entry:); end

  def ==(other); end
  def entry; end
  def eql?(other); end
  def hash; end
  def name; end
  def type; end
end

class RBS::CyclicClassAliasDefinitionError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(entry); end

  def alias_entry; end
  def location; end
end

class RBS::CyclicTypeParameterBound < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, method_name:, params:, location:); end

  def location; end
  def method_name; end
  def params; end
  def type_name; end
end

class RBS::Definition
  def initialize(type_name:, entry:, self_type:, ancestors:); end

  def ancestors; end
  def class?; end
  def class_type?; end
  def class_variables; end
  def each_type(&block); end
  def entry; end
  def instance_type?; end
  def instance_variables; end
  def interface?; end
  def interface_type?; end
  def map_method_type(&block); end
  def methods; end
  def module?; end
  def self_type; end
  def sub(s); end
  def type_name; end
  def type_params; end
  def type_params_decl; end
end

module RBS::Definition::Ancestor; end

class RBS::Definition::Ancestor::Instance
  def initialize(name:, args:, source:); end

  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def name; end
  def source; end
end

class RBS::Definition::Ancestor::Singleton
  def initialize(name:); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def name; end
end

class RBS::Definition::InstanceAncestors
  def initialize(type_name:, params:, ancestors:); end

  def ancestors; end
  def apply(args, env:, location:); end
  def params; end
  def type_name; end
end

class RBS::Definition::Method
  def initialize(super_method:, defs:, accessibility:, alias_of:, annotations: T.unsafe(nil), alias_member: T.unsafe(nil)); end

  def ==(other); end
  def accessibility; end
  def alias_member; end
  def alias_of; end
  def annotations; end
  def comments; end
  def defined_in; end
  def defs; end
  def eql?(other); end
  def extra_annotations; end
  def hash; end
  def implemented_in; end
  def map_method_type(&block); end
  def map_type(&block); end
  def map_type_bound(&block); end
  def members; end
  def method_types; end
  def private?; end
  def public?; end
  def sub(s); end
  def super_method; end
  def update(super_method: T.unsafe(nil), defs: T.unsafe(nil), accessibility: T.unsafe(nil), alias_of: T.unsafe(nil), annotations: T.unsafe(nil), alias_member: T.unsafe(nil)); end
end

class RBS::Definition::Method::TypeDef
  def initialize(type:, member:, defined_in:, implemented_in:, overload_annotations: T.unsafe(nil)); end

  def ==(other); end
  def annotations; end
  def comment; end
  def defined_in; end
  def each_annotation(&block); end
  def eql?(other); end
  def hash; end
  def implemented_in; end
  def member; end
  def member_annotations; end
  def overload?; end
  def overload_annotations; end
  def type; end
  def update(type: T.unsafe(nil), member: T.unsafe(nil), defined_in: T.unsafe(nil), implemented_in: T.unsafe(nil)); end
end

class RBS::Definition::SingletonAncestors
  def initialize(type_name:, ancestors:); end

  def ancestors; end
  def type_name; end
end

class RBS::Definition::Variable
  def initialize(parent_variable:, type:, declared_in:, source:); end

  def declared_in; end
  def parent_variable; end
  def source; end
  def sub(s); end
  def type; end
end

class RBS::DefinitionBuilder
  def initialize(env:, ancestor_builder: T.unsafe(nil), method_builder: T.unsafe(nil)); end

  def ancestor_builder; end
  def build_instance(type_name); end
  def build_interface(type_name); end
  def build_singleton(type_name); end
  def build_singleton0(type_name); end
  def define_instance(definition, type_name, subst, define_class_vars:); end
  def define_interface(definition, type_name, subst); end
  def define_method(methods, definition, method, subst, self_type_methods, defined_in:, implemented_in: T.unsafe(nil)); end
  def ensure_namespace!(namespace, location:); end
  def env; end
  def expand_alias(type_name); end
  def expand_alias1(type_name); end
  def expand_alias2(type_name, args); end
  def import_methods(definition, module_name, module_methods, interfaces_methods, subst, self_type_methods); end
  def insert_variable(type_name, variables, name:, type:, source:); end
  def instance_cache; end
  def interface_cache; end
  def interface_methods(interface_ancestors); end
  def method_builder; end
  def singleton0_cache; end
  def singleton_cache; end
  def source_location(source, decl); end
  def tapp_subst(name, args); end
  def try_cache(type_name, cache:); end
  def update(env:, except:, ancestor_builder:); end
  def validate_params_with(type_params, result:); end
  def validate_type_name(name, location); end
  def validate_type_params(definition, ancestors:, methods:); end
  def validate_type_presence(type); end
  def validate_variable(var); end
end

class RBS::DefinitionBuilder::AncestorBuilder
  def initialize(env:); end

  def env; end
  def fill_ancestor_source(ancestor, name:, source:, &block); end
  def instance_ancestors(type_name, building_ancestors: T.unsafe(nil)); end
  def instance_ancestors_cache; end
  def interface_ancestors(type_name, building_ancestors: T.unsafe(nil)); end
  def interface_ancestors_cache; end
  def mixin_ancestors(entry, type_name, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end
  def mixin_ancestors0(decl, type_name, align_params:, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end
  def one_instance_ancestors(type_name); end
  def one_instance_ancestors_cache; end
  def one_interface_ancestors(type_name); end
  def one_interface_ancestors_cache; end
  def one_singleton_ancestors(type_name); end
  def one_singleton_ancestors_cache; end
  def singleton_ancestors(type_name, building_ancestors: T.unsafe(nil)); end
  def singleton_ancestors_cache; end
  def validate_super_class!(type_name, entry); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def initialize(type_name:, params:, super_class:, self_types:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  def each_ancestor(&block); end
  def each_extended_interface(&block); end
  def each_extended_module(&block); end
  def each_included_interface(&block); end
  def each_included_module(&block); end
  def each_prepended_module(&block); end
  def each_self_type(&block); end
  def extended_interfaces; end
  def extended_modules; end
  def included_interfaces; end
  def included_modules; end
  def params; end
  def prepended_modules; end
  def self_types; end
  def super_class; end
  def type_name; end

  class << self
    def class_instance(type_name:, params:, super_class:); end
    def interface(type_name:, params:); end
    def module_instance(type_name:, params:); end
    def singleton(type_name:, super_class:); end
  end
end

class RBS::DefinitionBuilder::MethodBuilder
  def initialize(env:); end

  def build_alias(methods, type, member:); end
  def build_attribute(methods, type, member:, accessibility:); end
  def build_instance(type_name); end
  def build_interface(type_name); end
  def build_method(methods, type, member:, accessibility:); end
  def build_ruby_attribute(methods, type, member:, accessibility:); end
  def build_singleton(type_name); end
  def each_rbs_member_with_accessibility(members, accessibility: T.unsafe(nil)); end
  def env; end
  def instance_methods; end
  def interface_methods; end
  def singleton_methods; end
  def update(env:, except:); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods
  def initialize(type:); end

  def each; end
  def methods; end
  def type; end
  def validate!; end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition < ::Struct
  def accessibility; end
  def original; end

  class << self
    def empty(name:, type:); end
  end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
  include ::TSort

  def initialize(methods); end

  def methods; end
  def tsort_each_child(defn); end
  def tsort_each_node(&block); end
end

class RBS::DefinitionError < ::RBS::BaseError; end

module RBS::DetailedMessageable
  def detailed_message(highlight: T.unsafe(nil), **_arg1); end
end

class RBS::Diff
  def initialize(type_name:, library_options:, after_path: T.unsafe(nil), before_path: T.unsafe(nil), detail: T.unsafe(nil)); end

  def each_diff(&block); end

  private

  def build_builder(env); end
  def build_env(path); end
  def build_methods(path); end
  def constant_to_s(constant); end
  def definition_method_to_s(key, kind, definition_method); end
  def each_diff_constants(before_constant_children, after_constant_children); end
  def each_diff_methods(kind, before_methods, after_methods); end
end

class RBS::DuplicatedDeclarationError < ::RBS::LoadingError
  def initialize(name, *decls); end

  def decls; end
  def name; end
end

class RBS::DuplicatedInterfaceMethodDefinitionError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type:, method_name:, member:); end

  def location; end
  def member; end
  def method_name; end
  def qualified_method_name; end
  def type; end
  def type_name; end
end

class RBS::DuplicatedMethodDefinitionError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type:, method_name:, members:); end

  def location; end
  def members; end
  def method_name; end
  def other_locations; end
  def qualified_method_name; end
  def type; end
  def type_name; end
end

class RBS::Environment
  def initialize; end

  def absolute_type(resolver, map, type, context:); end
  def absolute_type_name(resolver, map, type_name, context:); end
  def add_source(source); end
  def append_context(context, decl); end
  def buffers; end
  def class_alias?(name); end
  def class_alias_decls; end
  def class_decl?(name); end
  def class_decls; end
  def class_entry(type_name, normalized: T.unsafe(nil)); end
  def constant_decl?(name); end
  def constant_decls; end
  def constant_entry(type_name, normalized: T.unsafe(nil)); end
  def constant_name?(name); end
  def declarations; end
  def each_rbs_source(&block); end
  def each_ruby_source(&block); end
  def global_decls; end
  def insert_rbs_decl(decl, context:, namespace:); end
  def insert_ruby_decl(decl, context:, namespace:); end
  def inspect; end
  def interface_decls; end
  def interface_name?(name); end
  def module_alias?(name); end
  def module_class_entry(type_name, normalized: T.unsafe(nil)); end
  def module_decl?(name); end
  def module_entry(type_name, normalized: T.unsafe(nil)); end
  def module_name?(name); end
  def normalize_module_name(name); end
  def normalize_module_name!(name); end
  def normalize_module_name?(name); end
  def normalize_type_name(name); end
  def normalize_type_name!(name); end
  def normalize_type_name?(name); end
  def normalized_class_entry(type_name); end
  def normalized_module_class_entry(type_name); end
  def normalized_module_entry(type_name); end
  def normalized_type_name!(name); end
  def normalized_type_name?(type_name); end
  def resolve_declaration(resolver, map, decl, context:, prefix:); end
  def resolve_member(resolver, map, member, context:); end
  def resolve_method_type(resolver, map, type, context:); end
  def resolve_ruby_decl(resolver, decl, context:, prefix:); end
  def resolve_ruby_member(resolver, member, context:); end
  def resolve_signature(resolver, table, dirs, decls, only: T.unsafe(nil)); end
  def resolve_type_names(only: T.unsafe(nil)); end
  def resolve_type_params(resolver, map, params, context:); end
  def resolver_context(*nesting); end
  def sources; end
  def type_alias_decls; end
  def type_alias_name?(name); end
  def type_name?(name); end
  def unload(paths); end
  def validate_type_params; end

  private

  def initialize_copy(other); end

  class << self
    def from_loader(loader); end
  end
end

class RBS::Environment::ClassAliasEntry < ::RBS::Environment::SingleEntry; end

class RBS::Environment::ClassEntry
  def initialize(name); end

  def <<(context_decl); end
  def context_decls; end
  def each_decl(&block); end
  def empty?; end
  def name; end
  def primary_decl; end
  def type_params; end
  def validate_type_params; end
end

class RBS::Environment::ConstantEntry < ::RBS::Environment::SingleEntry; end
class RBS::Environment::GlobalEntry < ::RBS::Environment::SingleEntry; end
class RBS::Environment::InterfaceEntry < ::RBS::Environment::SingleEntry; end
class RBS::Environment::ModuleAliasEntry < ::RBS::Environment::SingleEntry; end

class RBS::Environment::ModuleEntry
  def initialize(name); end

  def <<(context_decl); end
  def context_decls; end
  def each_decl(&block); end
  def empty?; end
  def name; end
  def primary_decl; end
  def self_types; end
  def type_params; end
  def validate_type_params; end
end

class RBS::Environment::SingleEntry
  def initialize(name:, decl:, context:); end

  def context; end
  def decl; end
  def name; end
end

class RBS::Environment::TypeAliasEntry < ::RBS::Environment::SingleEntry; end

class RBS::Environment::UseMap
  def initialize(table:); end

  def build_map(clause); end
  def resolve(type_name); end
  def resolve?(type_name); end
  def use_dirs; end
end

class RBS::Environment::UseMap::Table
  def initialize; end

  def children; end
  def compute_children; end
  def known_types; end
end

class RBS::EnvironmentLoader
  include ::RBS::FileFinder

  def initialize(core_root: T.unsafe(nil), repository: T.unsafe(nil)); end

  def add(path: T.unsafe(nil), library: T.unsafe(nil), version: T.unsafe(nil), resolve_dependencies: T.unsafe(nil)); end
  def add_collection(lockfile); end
  def core_root; end
  def dirs; end
  def each_dir; end
  def each_signature; end
  def has_library?(library:, version:); end
  def libs; end
  def load(env:); end
  def repository; end
  def resolve_dependencies(library:, version:); end

  class << self
    def gem_sig_path(name, version); end
  end
end

RBS::EnvironmentLoader::DEFAULT_CORE_ROOT = T.let(T.unsafe(nil), Pathname)
class RBS::EnvironmentLoader::Library < ::Struct; end

class RBS::EnvironmentLoader::UnknownLibraryError < ::StandardError
  def initialize(lib:); end

  def library; end
end

class RBS::EnvironmentWalker
  include ::TSort

  def initialize(env:); end

  def builder; end
  def each_type_name(type, &block); end
  def each_type_node(type, &block); end
  def env; end
  def only_ancestors!(only = T.unsafe(nil)); end
  def only_ancestors?; end
  def tsort_each_child(node, &block); end
  def tsort_each_node(&block); end
end

class RBS::EnvironmentWalker::InstanceNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::EnvironmentWalker::SingletonNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::EnvironmentWalker::TypeNameNode < ::Struct
  def type_name; end
  def type_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class RBS::Factory
  def type_name(string); end
end

module RBS::FileFinder
  class << self
    def each_file(path, skip_hidden:, immediate: T.unsafe(nil), &block); end
  end
end

class RBS::GenericParameterMismatchError < ::RBS::LoadingError
  def initialize(name:, decl:, location: T.unsafe(nil)); end

  def decl; end
  def name; end
end

class RBS::InconsistentClassModuleAliasError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(entry); end

  def alias_entry; end
  def location; end
end

class RBS::InheritModuleError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(super_decl); end

  def location; end
  def super_decl; end

  class << self
    def check!(super_decl, env:); end
  end
end

class RBS::InlineParser
  class << self
    def parse(buffer, prism); end
  end
end

class RBS::InlineParser::CommentAssociation
  def initialize(blocks); end

  def associated_blocks; end
  def blocks; end
  def each_enclosed_block(node); end
  def each_unassociated_block; end
  def end_line_map; end
  def leading_block(node); end
  def leading_block!(node); end
  def start_line_map; end
  def trailing_block(node); end
  def trailing_block!(node); end

  class << self
    def build(buffer, result); end
  end
end

class RBS::InlineParser::CommentAssociation::Reference
  def initialize(block, association); end

  def associate!; end
  def associated?; end
  def block; end
end

module RBS::InlineParser::Diagnostic; end
class RBS::InlineParser::Diagnostic::AnnotationSyntaxError < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::AttributeNonSymbolName < ::RBS::InlineParser::Diagnostic::Base; end

class RBS::InlineParser::Diagnostic::Base
  def initialize(location, message); end

  def location; end
  def message; end
end

class RBS::InlineParser::Diagnostic::ClassModuleAliasDeclarationMissingTypeName < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::MixinMultipleArguments < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::MixinNonConstantModule < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::NonConstantClassName < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::NonConstantConstantDeclaration < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::NonConstantModuleName < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::NonConstantSuperClassName < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::NotImplementedYet < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::TopLevelAttributeDefinition < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::TopLevelMethodDefinition < ::RBS::InlineParser::Diagnostic::Base; end
class RBS::InlineParser::Diagnostic::UnusedInlineAnnotation < ::RBS::InlineParser::Diagnostic::Base; end

class RBS::InlineParser::Parser < ::Prism::Visitor
  include ::RBS::AST::Ruby::Helpers::ConstantHelper
  include ::RBS::AST::Ruby::Helpers::LocationHelper

  def initialize(result); end

  def buffer; end
  def comments; end
  def current_module; end
  def current_module!; end
  def diagnostics; end
  def insert_declaration(decl); end
  def module_nesting; end
  def parse_attribute_call(node); end
  def parse_constant_declaration(node); end
  def parse_mixin_call(node); end
  def parse_super_class(super_class_expr, inheritance_operator_loc); end
  def push_module_nesting(mod); end
  def report_unused_annotation(*annotations); end
  def report_unused_block(block); end
  def result; end
  def skip_node?(node); end
  def visit_call_node(node); end
  def visit_class_node(node); end
  def visit_constant_path_write_node(node); end
  def visit_constant_write_node(node); end
  def visit_def_node(node); end
  def visit_module_node(node); end
end

class RBS::InlineParser::Result
  def initialize(buffer, prism); end

  def buffer; end
  def declarations; end
  def diagnostics; end
  def prism_result; end
  def type_fingerprint; end
end

class RBS::InstanceVariableDuplicationError < ::RBS::VariableDuplicationError
  def kind; end
end

class RBS::InvalidOverloadMethodError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, method_name:, kind:, members:); end

  def kind; end
  def location; end
  def members; end
  def method_name; end
  def type_name; end
end

class RBS::InvalidTypeApplicationError < ::RBS::DefinitionError
  def initialize(type_name:, args:, params:, location:); end

  def args; end
  def location; end
  def params; end
  def type_name; end
  def type_params; end

  class << self
    def check!(type_name:, args:, params:, location:); end
    def check2!(env:, type_name:, args:, location:); end
  end
end

class RBS::InvalidVarianceAnnotationError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, param:, location:); end

  def location; end
  def param; end
  def type_name; end
end

class RBS::LoadingError < ::RBS::BaseError; end

class RBS::Location
  def initialize(_arg0, _arg1, _arg2); end

  def ==(other); end
  def [](_arg0); end
  def _add_optional_child(_arg0, _arg1, _arg2); end
  def _add_optional_no_child(_arg0); end
  def _add_required_child(_arg0, _arg1, _arg2); end
  def _end_pos; end
  def _optional_keys; end
  def _required_keys; end
  def _start_pos; end
  def add_optional_child(name, range); end
  def add_required_child(name, range); end
  def aref(_arg0); end
  def buffer; end
  def each_optional_key(&block); end
  def each_required_key(&block); end
  def end_column; end
  def end_line; end
  def end_loc; end
  def end_pos; end
  def inspect; end
  def key?(name); end
  def local_location; end
  def local_source; end
  def name; end
  def optional_key?(name); end
  def range; end
  def required_key?(name); end
  def source; end
  def start_column; end
  def start_line; end
  def start_loc; end
  def start_pos; end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end

  private

  def initialize_copy(_arg0); end

  class << self
    def new(buffer_ = T.unsafe(nil), start_pos_ = T.unsafe(nil), end_pos_ = T.unsafe(nil), buffer: T.unsafe(nil), start_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
    def to_string(location, default: T.unsafe(nil)); end
  end
end

RBS::Location::WithChildren = RBS::Location

class RBS::Locator
  def initialize(buffer:, dirs:, decls:); end

  def buffer; end
  def decls; end
  def dirs; end
  def find(line:, column:); end
  def find2(line:, column:); end
  def find_in_decl(pos, decl:, array:); end
  def find_in_directive(pos, dir, array); end
  def find_in_loc(pos, location:, array:); end
  def find_in_member(pos, member:, array:); end
  def find_in_method_type(pos, method_type:, array:); end
  def find_in_type(pos, type:, array:); end
  def find_in_type_param(pos, type_param:, array:); end
  def test_loc(pos, location:); end
end

module RBS::MethodNameHelper
  def method_name_string; end
end

class RBS::MethodType
  def initialize(type_params:, type:, block:, location:); end

  def ==(other); end
  def block; end
  def each_type(&block); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def location; end
  def map_type(&block); end
  def map_type_bound(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
  def type; end
  def type_param_names; end
  def type_params; end
  def update(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end
  def with_nonreturn_void?; end
end

class RBS::MixinClassError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, member:); end

  def location; end
  def member; end
  def type_name; end

  private

  def member_name(member); end
  def mixin_name; end

  class << self
    def check!(type_name:, env:, member:); end
  end
end

class RBS::Namespace
  def initialize(path:, absolute:); end

  def +(other); end
  def ==(other); end
  def absolute!; end
  def absolute?; end
  def append(component); end
  def ascend; end
  def empty?; end
  def eql?(other); end
  def hash; end
  def parent; end
  def path; end
  def relative!; end
  def relative?; end
  def split; end
  def to_s; end
  def to_type_name; end

  class << self
    def empty; end
    def parse(string); end
    def root; end
  end
end

class RBS::NoMixinFoundError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, member:); end

  def location; end
  def member; end
  def type_name; end

  class << self
    def check!(type_name, env:, member:); end
  end
end

class RBS::NoSelfTypeFoundError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, location:); end

  def location; end
  def type_name; end

  class << self
    def check!(self_type, env:); end
  end
end

class RBS::NoSuperclassFoundError < ::RBS::DefinitionError
  def initialize(type_name:, location:); end

  def location; end
  def type_name; end

  class << self
    def check!(type_name, env:, location:); end
  end
end

class RBS::NoTypeFoundError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, location:); end

  def location; end
  def type_name; end

  class << self
    def check!(type_name, env:, location:); end
  end
end

class RBS::NonregularTypeAliasError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(diagnostic:, location:); end

  def diagnostic; end
  def location; end
end

class RBS::Parser
  class << self
    def _lex(_arg0, _arg1); end
    def _parse_inline_leading_annotation(_arg0, _arg1, _arg2, _arg3); end
    def _parse_inline_trailing_annotation(_arg0, _arg1, _arg2, _arg3); end
    def _parse_method_type(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def _parse_signature(_arg0, _arg1, _arg2); end
    def _parse_type(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6); end
    def _parse_type_params(_arg0, _arg1, _arg2, _arg3); end
    def buffer(source); end
    def lex(source); end
    def magic_comment(buf); end
    def parse_inline_leading_annotation(source, range, variables: T.unsafe(nil)); end
    def parse_inline_trailing_annotation(source, range, variables: T.unsafe(nil)); end
    def parse_method_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil)); end
    def parse_signature(source); end
    def parse_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil), void_allowed: T.unsafe(nil), self_allowed: T.unsafe(nil)); end
    def parse_type_params(source, module_type_params: T.unsafe(nil)); end
  end
end

RBS::Parser::KEYWORDS = T.let(T.unsafe(nil), Hash)

class RBS::Parser::LexResult
  def initialize(buffer:, value:); end

  def buffer; end
  def value; end
end

class RBS::Parser::Token
  def initialize(type:, location:); end

  def comment?; end
  def location; end
  def type; end
  def value; end
end

class RBS::ParsingError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(location, error_message, token_type); end

  def error_message; end
  def location; end
  def token_type; end
end

module RBS::Prototype; end

module RBS::Prototype::Helpers
  private

  def any_node?(node, nodes: T.unsafe(nil), &block); end
  def args_from_node(args_node); end
  def block_from_body(node); end
  def each_child(node, &block); end
  def each_node(nodes); end
  def keyword_hash?(node); end
  def symbol_literal_node?(node); end
  def untyped; end
end

class RBS::Prototype::NodeUsage
  include ::RBS::Prototype::Helpers

  def initialize(node); end

  def calculate(node, conditional:); end
  def conditional_nodes; end
  def each_conditional_node(&block); end
end

class RBS::Prototype::RB
  include ::RBS::Prototype::Helpers

  def initialize; end

  def block_type(node); end
  def body_type(node); end
  def const_to_name(node, context:); end
  def const_to_name!(node, context: T.unsafe(nil)); end
  def current_accessibility(decls, index = T.unsafe(nil)); end
  def decls; end
  def find_def_index_by_name(decls, name); end
  def function_return_type_from_body(node); end
  def function_type_from_body(node, def_name); end
  def if_unless_type(node); end
  def is_accessibility?(decl); end
  def literal_to_symbol(node); end
  def literal_to_type(node); end
  def node_type(node, default: T.unsafe(nil)); end
  def param_type(node, default: T.unsafe(nil)); end
  def parse(string); end
  def private; end
  def process(node, decls:, comments:, context:); end
  def process_children(node, decls:, comments:, context:); end
  def public; end
  def range_element_type(types); end
  def remove_unnecessary_accessibility_methods!(decls); end
  def sort_members!(decls); end
  def source_decls; end
  def toplevel_members; end
  def types_to_union_type(types); end
end

class RBS::Prototype::RB::Context < ::Struct
  def attribute_kind; end
  def enter_namespace(namespace); end
  def method_kind; end
  def update(module_function: T.unsafe(nil), singleton: T.unsafe(nil), in_def: T.unsafe(nil)); end

  class << self
    def initial(namespace: T.unsafe(nil)); end
  end
end

class RBS::Prototype::RBI
  include ::RBS::Prototype::Helpers

  def initialize; end

  def call_node?(node, name:, receiver: T.unsafe(nil), args: T.unsafe(nil)); end
  def const_to_name(node); end
  def current_module; end
  def current_module!; end
  def current_namespace; end
  def decls; end
  def each_arg(array, &block); end
  def each_child(node); end
  def join_comments(nodes, comments); end
  def last_sig; end
  def method_type(args_node, type_node, variables:, overloads:); end
  def modules; end
  def nested_name(name); end
  def node_to_hash(node); end
  def parse(string); end
  def parse_params(args_node, args, method_type, variables:, overloads:); end
  def pop_sig; end
  def proc_type?(type_node); end
  def process(node, comments:, outer: T.unsafe(nil)); end
  def push_class(name, super_class, comment:); end
  def push_module(name, comment:); end
  def push_sig(node); end
  def type_of(type_node, variables:); end
  def type_of0(type_node, variables:); end
end

class RBS::Prototype::Runtime
  include ::RBS::Prototype::Helpers
  include ::RBS::Prototype::Runtime::Helpers

  def initialize(patterns:, env:, merge:, todo: T.unsafe(nil), owners_included: T.unsafe(nil)); end

  def block_from_ast_of(method); end
  def builder; end
  def decls; end
  def ensure_outer_module_declarations(mod); end
  def env; end
  def generate_class(mod); end
  def generate_constants(mod, decls); end
  def generate_methods(mod, module_name, members); end
  def generate_mixin(mod, decl, type_name, type_name_absolute); end
  def generate_module(mod); end
  def generate_super_class(mod); end
  def merge; end
  def merge_rbs(module_name, members, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end
  def method_type(method); end
  def outline; end
  def outline=(_arg0); end
  def owners_included; end
  def parse(file); end
  def patterns; end
  def target?(const); end
  def target_method?(mod, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end
  def todo; end
  def todo_object; end
  def type_args(type_name); end
  def type_params(mod); end

  private

  def can_alias?(mod, method); end
  def each_mixined_module(type_name, mod); end
  def each_mixined_module_one(type_name, mod); end
end

class RBS::Prototype::Runtime::DataGenerator < ::RBS::Prototype::Runtime::ValueObjectBase
  private

  def add_decl_members(decl); end
  def build_s_new; end
  def build_super_class; end

  class << self
    def generatable?(target); end
  end
end

module RBS::Prototype::Runtime::Helpers
  private

  def const_name(const); end
  def const_name!(const); end
  def only_name(mod); end
  def to_type_name(name, full_name: T.unsafe(nil)); end
  def untyped; end
end

module RBS::Prototype::Runtime::Reflection
  class << self
    def constants_of(mod, inherit = T.unsafe(nil)); end
    def object_class(value); end
  end
end

class RBS::Prototype::Runtime::StructGenerator < ::RBS::Prototype::Runtime::ValueObjectBase
  private

  def add_decl_members(decl); end
  def build_overload_for_keyword_arguments; end
  def build_overload_for_positional_arguments; end
  def build_s_keyword_init_p; end
  def build_s_new; end
  def build_super_class; end

  class << self
    def generatable?(target); end
  end
end

RBS::Prototype::Runtime::StructGenerator::CAN_CALL_KEYWORD_INIT_P = T.let(T.unsafe(nil), TrueClass)

class RBS::Prototype::Runtime::Todo
  def initialize(builder:); end

  def skip_constant?(module_name:, name:); end
  def skip_instance_method?(module_name:, method:, accessibility:); end
  def skip_mixin?(type_name:, module_name:, mixin_class:); end
  def skip_singleton_method?(module_name:, method:, accessibility:); end

  private

  def mixin_decls(type_name); end
end

class RBS::Prototype::Runtime::ValueObjectBase
  include ::RBS::Prototype::Runtime::Helpers

  def initialize(target_class); end

  def build_decl; end

  private

  def build_member_accessors(ast_members_class); end
  def build_s_members; end
end

module RBS::RDocPlugin; end

class RBS::RDocPlugin::Parser
  def initialize(top_level, content); end

  def content; end
  def content=(_arg0); end
  def parse_attr_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_class_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_constant_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_extend_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_include_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_member(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_method_alias_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_method_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def parse_module_decl(decl:, context:, outer_name: T.unsafe(nil)); end
  def scan; end
  def top_level; end
  def top_level=(_arg0); end

  private

  def comment_string(with_comment); end
  def construct_comment(context:, comment:); end
  def fully_qualified_name(outer_name:, decl:); end
end

class RBS::RecursiveAliasDefinitionError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type:, defs:); end

  def defs; end
  def location; end
  def type; end
end

class RBS::RecursiveAncestorError < ::RBS::DefinitionError
  def initialize(ancestors:, location:); end

  def ancestors; end
  def location; end

  class << self
    def check!(self_ancestor, ancestors:, location:); end
  end
end

class RBS::RecursiveTypeAliasError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  def initialize(alias_names:, location:); end

  def alias_names; end
  def location; end
  def name; end
end

class RBS::Repository
  def initialize(no_stdlib: T.unsafe(nil)); end

  def add(dir); end
  def dirs; end
  def gems; end
  def lookup(gem, version); end
  def lookup_path(gem, version); end

  class << self
    def default; end
    def find_best_version(version, candidates); end
  end
end

RBS::Repository::DEFAULT_STDLIB_ROOT = T.let(T.unsafe(nil), Pathname)

class RBS::Repository::GemRBS
  def initialize(name:); end

  def empty?; end
  def find_best_version(version); end
  def latest_version; end
  def load!; end
  def name; end
  def oldest_version; end
  def paths; end
  def version_names; end
  def versions; end
end

class RBS::Repository::VersionPath < ::Struct
  def gem; end
  def gem=(_); end
  def path; end
  def path=(_); end
  def version; end
  def version=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module RBS::Resolver; end

class RBS::Resolver::ConstantResolver
  def initialize(builder:); end

  def builder; end
  def child_constants_cache; end
  def children(module_name); end
  def constants(context); end
  def constants_from_ancestors(module_name, constants:); end
  def constants_from_context(context, constants:); end
  def constants_itself(context, constants:); end
  def context_constants_cache; end
  def load_child_constants(name); end
  def load_context_constants(context); end
  def resolve(name, context:); end
  def resolve_child(module_name, name); end
  def table; end
end

class RBS::Resolver::ConstantResolver::Table
  def initialize(environment); end

  def children(name); end
  def children_table; end
  def constant(name); end
  def constant_of_constant(name, entry); end
  def constant_of_module(name, entry); end
  def constants_table; end
  def toplevel; end
end

class RBS::Resolver::TypeNameResolver
  def initialize(all_names, aliases); end

  def aliased_name?(type_name); end
  def aliases; end
  def all_names; end
  def cache; end
  def has_type_name?(full_name); end
  def normalize_namespace(type_name, rhs, context, visited); end
  def resolve(type_name, context:); end
  def resolve_head_namespace(head, context); end
  def resolve_namespace(type_name, context:); end
  def resolve_namespace0(type_name, context, visited); end
  def resolve_type_name(type_name, context); end
  def try_cache(query); end

  class << self
    def build(env); end
  end
end

module RBS::Source; end

class RBS::Source::RBS
  def initialize(buffer, directives, decls); end

  def buffer; end
  def declarations; end
  def directives; end
  def each_declaration_type_name(names, decl, &block); end
  def each_type_name(&block); end
end

class RBS::Source::Ruby
  def initialize(buffer, prism, declarations, diagnostics); end

  def buffer; end
  def declarations; end
  def diagnostics; end
  def each_declaration_type_name(names, decl, &block); end
  def each_type_name(&block); end
  def prism_result; end
end

class RBS::Substitution
  def initialize; end

  def +(other); end
  def [](ty); end
  def add(from:, to:); end
  def apply(ty); end
  def empty?; end
  def instance_type; end
  def instance_type=(_arg0); end
  def mapping; end
  def without(*vars); end

  class << self
    def build(variables, types, instance_type: T.unsafe(nil), &block); end
  end
end

class RBS::Subtractor
  def initialize(minuend, subtrahend); end

  def call(minuend = T.unsafe(nil), context: T.unsafe(nil)); end

  private

  def absolute_typename(name, context:); end
  def access_modifier?(decl); end
  def cvar_exist?(owner, name); end
  def each_member(owner, &block); end
  def filter_members(decl, context:); end
  def filter_redundant_access_modifiers(decls); end
  def ivar_exist?(owner, name, kind); end
  def member_exist?(owner, member, context:); end
  def method_exist?(owner, method_name, kind); end
  def mixin_exist?(owner, mixin, context:); end
  def typename_candidates(name, context:); end
  def update_decl(decl, members:); end
end

class RBS::SuperclassMismatchError < ::RBS::DefinitionError
  def initialize(name:, entry:); end

  def entry; end
  def name; end
end

class RBS::TypeAliasDependency
  def initialize(env:); end

  def build_dependencies; end
  def circular_definition?(alias_name); end
  def dependencies; end
  def dependencies_of(name); end
  def direct_dependencies; end
  def direct_dependencies_of(name); end
  def env; end
  def transitive_closure; end

  private

  def dependency(start, vertex, nested = T.unsafe(nil)); end
  def direct_dependency(type, result = T.unsafe(nil)); end
end

class RBS::TypeAliasRegularity
  def initialize(env:); end

  def build_alias_type(name); end
  def builder; end
  def compatible_args?(args1, args2); end
  def diagnostics; end
  def each_alias_type(type, &block); end
  def each_mutual_alias_defs(&block); end
  def env; end
  def nonregular?(type_name); end
  def validate; end
  def validate_alias_type(alias_type, names, types); end

  class << self
    def validate(env:); end
  end
end

class RBS::TypeAliasRegularity::Diagnostic
  def initialize(type_name:, nonregular_type:); end

  def nonregular_type; end
  def type_name; end
end

class RBS::TypeName
  def initialize(namespace:, name:); end

  def +(other); end
  def ==(other); end
  def absolute!; end
  def absolute?; end
  def alias?; end
  def class?; end
  def eql?(other); end
  def hash; end
  def interface?; end
  def kind; end
  def name; end
  def namespace; end
  def relative!; end
  def split; end
  def to_json(state = T.unsafe(nil)); end
  def to_namespace; end
  def to_s; end
  def with_prefix(namespace); end

  class << self
    def parse(string); end
  end
end

class RBS::TypeParamDefaultReferenceError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_param, location:); end

  def location; end
  def type_param; end

  class << self
    def check!(type_params); end
  end
end

module RBS::Types; end

class RBS::Types::Alias
  include ::RBS::Types::Application

  def initialize(name:, args:, location:); end

  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
end

module RBS::Types::Application
  def ==(other); end
  def args; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def name; end
  def to_s(level = T.unsafe(nil)); end
  def with_nonreturn_void?; end
end

module RBS::Types::Bases; end

class RBS::Types::Bases::Any < ::RBS::Types::Bases::Base
  def initialize(location:, todo: T.unsafe(nil)); end

  def to_s(level = T.unsafe(nil)); end
end

class RBS::Types::Bases::Base
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName

  def initialize(location:); end

  def ==(other); end
  def eql?(other); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def with_nonreturn_void?; end
end

class RBS::Types::Bases::Bool < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Bottom < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Class < ::RBS::Types::Bases::Base; end

class RBS::Types::Bases::Instance < ::RBS::Types::Bases::Base
  def sub(s); end
end

class RBS::Types::Bases::Nil < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Self < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Top < ::RBS::Types::Bases::Base; end
class RBS::Types::Bases::Void < ::RBS::Types::Bases::Base; end

class RBS::Types::Block
  def initialize(type:, required:, location: T.unsafe(nil), self_type: T.unsafe(nil)); end

  def ==(other); end
  def location; end
  def map_type(&block); end
  def required; end
  def self_type; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def type; end
end

class RBS::Types::ClassInstance
  include ::RBS::Types::Application

  def initialize(name:, args:, location:); end

  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::Types::ClassSingleton
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType

  def initialize(name:, location:); end

  def ==(other); end
  def eql?(other); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def map_type_name(&_arg0); end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def with_nonreturn_void?; end
end

module RBS::Types::EmptyEachType
  def each_type; end
  def map_type(&block); end
end

class RBS::Types::Function
  def initialize(required_positionals:, optional_positionals:, rest_positionals:, trailing_positionals:, required_keywords:, optional_keywords:, rest_keywords:, return_type:); end

  def ==(other); end
  def amap(array, &block); end
  def drop_head; end
  def drop_tail; end
  def each_param(&block); end
  def each_type; end
  def empty?; end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_keyword?; end
  def has_self_type?; end
  def hash; end
  def hmapv(hash, &block); end
  def map_type(&block); end
  def map_type_name(&block); end
  def optional_keywords; end
  def optional_positionals; end
  def param_to_s; end
  def required_keywords; end
  def required_positionals; end
  def rest_keywords; end
  def rest_positionals; end
  def return_to_s; end
  def return_type; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def trailing_positionals; end
  def update(required_positionals: T.unsafe(nil), optional_positionals: T.unsafe(nil), rest_positionals: T.unsafe(nil), trailing_positionals: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil), return_type: T.unsafe(nil)); end
  def with_nonreturn_void?; end
  def with_return_type(type); end

  class << self
    def empty(return_type); end
  end
end

class RBS::Types::Function::Param
  def initialize(type:, name:, location: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def location; end
  def map_type(&block); end
  def name; end
  def to_json(state = T.unsafe(nil)); end
  def to_s; end
  def type; end
end

class RBS::Types::Interface
  include ::RBS::Types::Application

  def initialize(name:, args:, location:); end

  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
end

class RBS::Types::Intersection
  def initialize(types:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def types; end
  def with_nonreturn_void?; end
end

class RBS::Types::Literal
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName

  def initialize(literal:, location:); end

  def ==(other); end
  def eql?(other); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def literal; end
  def location; end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def with_nonreturn_void?; end

  class << self
    def unescape_string(string, is_double_quote); end
  end
end

RBS::Types::Literal::TABLE = T.let(T.unsafe(nil), Hash)

module RBS::Types::NoFreeVariables
  def free_variables(set = T.unsafe(nil)); end
end

module RBS::Types::NoSubst
  def sub(s); end
end

module RBS::Types::NoTypeName
  def map_type_name(&_arg0); end
end

class RBS::Types::Optional
  def initialize(type:, location:); end

  def ==(other); end
  def each_type; end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def type; end
  def with_nonreturn_void?; end
end

class RBS::Types::Proc
  def initialize(location:, type:, block:, self_type: T.unsafe(nil)); end

  def ==(other); end
  def block; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def self_type; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def type; end
  def with_nonreturn_void?; end
end

class RBS::Types::Record
  def initialize(location:, all_fields: T.unsafe(nil), fields: T.unsafe(nil)); end

  def ==(other); end
  def all_fields; end
  def each_type(&block); end
  def eql?(other); end
  def fields; end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def optional_fields; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def with_nonreturn_void?; end
end

module RBS::Types::SelfTypeBindingHelper
  private

  def self_type_binding_to_s(t); end

  class << self
    def self_type_binding_to_s(t); end
  end
end

class RBS::Types::Tuple
  def initialize(types:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def types; end
  def with_nonreturn_void?; end
end

class RBS::Types::Union
  def initialize(types:, location:); end

  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def types; end
  def with_nonreturn_void?; end
end

class RBS::Types::UntypedFunction
  def initialize(return_type:); end

  def ==(other); end
  def each_param(&block); end
  def each_type(&block); end
  def empty?; end
  def eql?(other); end
  def free_variables(acc = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def map_type(&block); end
  def map_type_name(&block); end
  def param_to_s; end
  def return_to_s; end
  def return_type; end
  def sub(subst); end
  def to_json(state = T.unsafe(nil)); end
  def update(return_type: T.unsafe(nil)); end
  def with_nonreturn_void?; end
  def with_return_type(ty); end
end

class RBS::Types::Variable
  include ::RBS::Types::NoTypeName
  include ::RBS::Types::EmptyEachType

  def initialize(name:, location:); end

  def ==(other); end
  def eql?(other); end
  def free_variables(set = T.unsafe(nil)); end
  def has_classish_type?; end
  def has_self_type?; end
  def hash; end
  def location; end
  def name; end
  def sub(s); end
  def to_json(state = T.unsafe(nil)); end
  def to_s(level = T.unsafe(nil)); end
  def with_nonreturn_void?; end

  class << self
    def build(v); end
    def fresh(v = T.unsafe(nil)); end
  end
end

class RBS::UnknownMethodAliasError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, original_name:, aliased_name:, location:); end

  def aliased_name; end
  def location; end
  def original_name; end
  def type_name; end
end

RBS::VERSION = T.let(T.unsafe(nil), String)

class RBS::Validator
  def initialize(env:, resolver: T.unsafe(nil)); end

  def absolute_type(type, context:, &block); end
  def definition_builder; end
  def env; end
  def resolver; end
  def type_alias_dependency; end
  def type_alias_regularity; end
  def validate_class_alias(entry:); end
  def validate_method_definition(method_def, type_name:); end
  def validate_type(type, context:); end
  def validate_type_alias(entry:); end
  def validate_type_params(params, type_name:, location:, method_name: T.unsafe(nil)); end
  def validate_variable(var); end
end

class RBS::VariableDuplicationError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(type_name:, variable_name:, location:); end

  def location; end
  def type_name; end
  def variable_name; end
end

class RBS::VarianceCalculator
  def initialize(builder:); end

  def builder; end
  def env; end
  def function(type, result:, context:); end
  def in_inherit(name:, args:, variables:); end
  def in_method_type(method_type:, variables:); end
  def in_type_alias(name:); end
  def negate(variance); end
  def type(type, result:, context:); end
end

class RBS::VarianceCalculator::Result
  def initialize(variables:); end

  def compatible?(var, with_annotation:); end
  def contravariant(x); end
  def covariant(x); end
  def each(&block); end
  def include?(name); end
  def incompatible?(params); end
  def invariant(x); end
  def result; end
end

class RBS::Vendorer
  def initialize(vendor_dir:, loader:); end

  def clean!; end
  def copy!; end
  def ensure_dir; end
  def loader; end
  def vendor_dir; end
end

class RBS::WillSyntaxError < ::RBS::DefinitionError
  include ::RBS::DetailedMessageable

  def initialize(message, location:); end

  def location; end
end

class RBS::Writer
  def initialize(out:); end

  def attribute(kind, attr); end
  def format_annotation(annotation); end
  def indent(size = T.unsafe(nil)); end
  def indentation; end
  def method_name(name); end
  def name_and_args(name, args); end
  def name_and_params(name, params); end
  def out; end
  def prefix; end
  def preserve!(preserve: T.unsafe(nil)); end
  def preserve?; end
  def preserve_empty_line(prev, decl); end
  def put_lines(lines, leading_spaces:); end
  def puts(string = T.unsafe(nil)); end
  def write(contents); end
  def write_annotation(annotations); end
  def write_comment(comment); end
  def write_decl(decl); end
  def write_def(member); end
  def write_loc_source(located); end
  def write_member(member); end
  def write_use_directive(dir); end
end

class RDoc::Parser::RBS < ::RDoc::Parser
  def scan; end
end
