# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ancestry` gem.
# Please instead update this file by running `bin/tapioca gem ancestry`.

# source://ancestry//lib/ancestry/version.rb#1
module Ancestry
  class << self
    # The value changes the default way that ancestry is updated for associated records
    #
    #    :ruby (default and legacy value)
    #
    #        Child records will be loaded into memory and updated. callbacks will get called
    #        The callbacks of interest are those that cache values based upon the ancestry value
    #
    #    :sql (currently only valid in postgres)
    #
    #        Child records are updated in sql and callbacks will not get called.
    #        Associated records in memory will have the wrong ancestry value
    #
    # source://ancestry//lib/ancestry.rb#30
    def default_update_strategy; end

    # source://ancestry//lib/ancestry.rb#34
    def default_update_strategy=(value); end
  end
end

# source://ancestry//lib/ancestry/exceptions.rb#2
class Ancestry::AncestryException < ::RuntimeError; end

# source://ancestry//lib/ancestry/exceptions.rb#5
class Ancestry::AncestryIntegrityException < ::Ancestry::AncestryException; end

# source://ancestry//lib/ancestry/class_methods.rb#2
module Ancestry::ClassMethods
  # Get all nodes and sort them into an empty hash
  #
  # source://ancestry//lib/ancestry/class_methods.rb#41
  def arrange(options = T.unsafe(nil)); end

  # Arrange array of nodes into a nested hash of the form
  # {node => children}, where children = {} if the node has no children
  # If a node's parent is not included, the node will be included as if it is a top level node
  #
  # source://ancestry//lib/ancestry/class_methods.rb#52
  def arrange_nodes(nodes); end

  # Arrangement to nested array for serialization
  # You can also supply your own serialization logic using blocks
  # also allows you to pass the order just as you can pass it to the arrange method
  #
  # source://ancestry//lib/ancestry/class_methods.rb#66
  def arrange_serializable(options = T.unsafe(nil), nodes = T.unsafe(nil), &block); end

  # Build ancestry from parent ids for migration purposes
  #
  # source://ancestry//lib/ancestry/class_methods.rb#209
  def build_ancestry_from_parent_ids!(column = T.unsafe(nil), parent_id = T.unsafe(nil), ancestor_ids = T.unsafe(nil)); end

  # Integrity checking
  # compromised tree integrity is unlikely without explicitly setting cyclic parents or invalid ancestry and circumventing validation
  # just in case, raise an AncestryIntegrityException if issues are detected
  # specify :report => :list to return an array of exceptions or :report => :echo to echo any error messages
  #
  # source://ancestry//lib/ancestry/class_methods.rb#121
  def check_ancestry_integrity!(options = T.unsafe(nil)); end

  # Orphan strategy writer
  #
  # source://ancestry//lib/ancestry/class_methods.rb#25
  def orphan_strategy=(orphan_strategy); end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/class_methods.rb#238
  def primary_key_is_an_integer?; end

  # Rebuild depth cache if it got corrupted or if depth caching was just turned on
  #
  # @raise [Ancestry::AncestryException]
  #
  # source://ancestry//lib/ancestry/class_methods.rb#221
  def rebuild_depth_cache!; end

  # Integrity restoration
  #
  # source://ancestry//lib/ancestry/class_methods.rb#169
  def restore_ancestry_integrity!; end

  # Scope on relative depth options
  #
  # source://ancestry//lib/ancestry/class_methods.rb#13
  def scope_depth(depth_options, depth); end

  # Pseudo-preordered array of nodes.  Children will always follow parents,
  #
  # source://ancestry//lib/ancestry/class_methods.rb#92
  def sort_by_ancestry(nodes, &block); end

  # Fetch tree node if necessary
  #
  # source://ancestry//lib/ancestry/class_methods.rb#4
  def to_node(object); end

  # source://ancestry//lib/ancestry/class_methods.rb#77
  def tree_view(column, data = T.unsafe(nil)); end

  # @yield [self.ancestry_base_class.default_scoped.unscope(:where)]
  #
  # source://ancestry//lib/ancestry/class_methods.rb#233
  def unscoped_where; end
end

# source://ancestry//lib/ancestry/class_methods.rb#237
Ancestry::ClassMethods::ANCESTRY_UNCAST_TYPES = T.let(T.unsafe(nil), Array)

# source://ancestry//lib/ancestry/has_ancestry.rb#2
module Ancestry::HasAncestry
  # source://ancestry//lib/ancestry/has_ancestry.rb#98
  def acts_as_tree(*args); end

  # @raise [Ancestry::AncestryException]
  #
  # source://ancestry//lib/ancestry/has_ancestry.rb#3
  def has_ancestry(options = T.unsafe(nil)); end

  private

  # source://ancestry//lib/ancestry/has_ancestry.rb#115
  def derive_materialized2_pattern(primary_key_format, delimiter = T.unsafe(nil)); end

  # source://ancestry//lib/ancestry/has_ancestry.rb#105
  def derive_materialized_pattern(primary_key_format, delimiter = T.unsafe(nil)); end
end

# source://ancestry//lib/ancestry/instance_methods.rb#2
module Ancestry::InstanceMethods
  # source://ancestry//lib/ancestry/instance_methods.rb#92
  def _counter_cache_column; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#152
  def ancestor_of?(node); end

  # source://ancestry//lib/ancestry/instance_methods.rb#127
  def ancestors(depth_options = T.unsafe(nil)); end

  # Ancestors
  #
  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#98
  def ancestors?; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#304
  def ancestry_callbacks_disabled?; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#103
  def ancestry_changed?; end

  # Validate that the ancestors don't include itself
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#4
  def ancestry_exclude_self; end

  # Apply orphan strategy (before destroy - no changes)
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#24
  def apply_orphan_strategy; end

  # source://ancestry//lib/ancestry/instance_methods.rb#148
  def cache_depth; end

  # source://ancestry//lib/ancestry/instance_methods.rb#214
  def child_ids; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#228
  def child_of?(node); end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#223
  def childless?; end

  # Children
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#210
  def children; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#218
  def children?; end

  # source://ancestry//lib/ancestry/instance_methods.rb#68
  def decrease_parent_counter_cache; end

  # source://ancestry//lib/ancestry/instance_methods.rb#144
  def depth; end

  # source://ancestry//lib/ancestry/instance_methods.rb#263
  def descendant_ids(depth_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#267
  def descendant_of?(node); end

  # Descendants
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#259
  def descendants(depth_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#218
  def has_children?; end

  # Ancestors
  #
  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#98
  def has_parent?; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#243
  def has_siblings?; end

  # Counter Cache
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#64
  def increase_parent_counter_cache; end

  # source://ancestry//lib/ancestry/instance_methods.rb#277
  def indirect_ids(depth_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#281
  def indirect_of?(node); end

  # Indirects
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#273
  def indirects(depth_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#223
  def is_childless?; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#248
  def is_only_child?; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#199
  def is_root?; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#248
  def only_child?; end

  # source://ancestry//lib/ancestry/instance_methods.rb#173
  def parent; end

  # currently parent= does not work in after save callbacks
  # assuming that parent hasn't changed
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#160
  def parent=(parent); end

  # source://ancestry//lib/ancestry/instance_methods.rb#168
  def parent_id; end

  # source://ancestry//lib/ancestry/instance_methods.rb#164
  def parent_id=(new_parent_id); end

  # Ancestors
  #
  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#98
  def parent_id?; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#181
  def parent_of?(node); end

  # source://ancestry//lib/ancestry/instance_methods.rb#140
  def path(depth_options = T.unsafe(nil)); end

  # source://ancestry//lib/ancestry/instance_methods.rb#132
  def path_ids; end

  # source://ancestry//lib/ancestry/instance_methods.rb#136
  def path_ids_in_database; end

  # source://ancestry//lib/ancestry/instance_methods.rb#191
  def root; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#199
  def root?; end

  # Root
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#187
  def root_id; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#204
  def root_of?(node); end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#110
  def sane_ancestor_ids?; end

  # NOTE: includes self
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#239
  def sibling_ids; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#253
  def sibling_of?(node); end

  # Siblings
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#234
  def siblings; end

  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#243
  def siblings?; end

  # Subtree
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#287
  def subtree(depth_options = T.unsafe(nil)); end

  # source://ancestry//lib/ancestry/instance_methods.rb#291
  def subtree_ids(depth_options = T.unsafe(nil)); end

  # Touch each of this record's ancestors (after save)
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#52
  def touch_ancestors_callback; end

  # Update descendants with new ancestry (before save)
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#9
  def update_descendants_with_new_ancestry; end

  # source://ancestry//lib/ancestry/instance_methods.rb#80
  def update_parent_counter_cache; end

  # Callback disabling
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#297
  def without_ancestry_callbacks; end

  private

  # works with after save context (hence before_last_save)
  #
  # source://ancestry//lib/ancestry/instance_methods.rb#316
  def unscoped_current_and_previous_ancestors; end

  # source://ancestry//lib/ancestry/instance_methods.rb#309
  def unscoped_descendants; end

  # source://ancestry//lib/ancestry/instance_methods.rb#322
  def unscoped_find(id); end

  # source://ancestry//lib/ancestry/instance_methods.rb#328
  def unscoped_where; end
end

# store ancestry as grandparent_id/parent_id
# root a=nil,id=1   children=id,id/%      == 1, 1/%
# 3: a=1/2,id=3     children=a/id,a/id/%  == 1/2/3, 1/2/3/%
#
# source://ancestry//lib/ancestry/materialized_path.rb#5
module Ancestry::MaterializedPath
  # source://ancestry//lib/ancestry/materialized_path.rb#23
  def ancestors_of(object); end

  # source://ancestry//lib/ancestry/materialized_path.rb#35
  def children_of(object); end

  # deprecated
  #
  # source://ancestry//lib/ancestry/materialized_path.rb#54
  def descendant_conditions(object); end

  # source://ancestry//lib/ancestry/materialized_path.rb#48
  def descendants_of(object); end

  # indirect = anyone who is a descendant, but not a child
  #
  # source://ancestry//lib/ancestry/materialized_path.rb#42
  def indirects_of(object); end

  # source://ancestry//lib/ancestry/materialized_path.rb#29
  def inpath_of(object); end

  # source://ancestry//lib/ancestry/materialized_path.rb#72
  def ordered_by_ancestry(order = T.unsafe(nil)); end

  # source://ancestry//lib/ancestry/materialized_path.rb#85
  def ordered_by_ancestry_and(order); end

  # source://ancestry//lib/ancestry/materialized_path.rb#15
  def path_of(object); end

  # source://ancestry//lib/ancestry/materialized_path.rb#19
  def roots; end

  # source://ancestry//lib/ancestry/materialized_path.rb#66
  def siblings_of(object); end

  # source://ancestry//lib/ancestry/materialized_path.rb#60
  def subtree_of(object); end

  class << self
    # @private
    #
    # source://ancestry//lib/ancestry/materialized_path.rb#11
    def extended(base); end
  end
end

# source://ancestry//lib/ancestry/materialized_path.rb#8
Ancestry::MaterializedPath::ANCESTRY_DELIMITER = T.let(T.unsafe(nil), String)

# source://ancestry//lib/ancestry/materialized_path.rb#6
Ancestry::MaterializedPath::BEFORE_LAST_SAVE_SUFFIX = T.let(T.unsafe(nil), String)

# source://ancestry//lib/ancestry/materialized_path.rb#7
Ancestry::MaterializedPath::IN_DATABASE_SUFFIX = T.let(T.unsafe(nil), String)

# source://ancestry//lib/ancestry/materialized_path.rb#89
module Ancestry::MaterializedPath::InstanceMethods
  # source://ancestry//lib/ancestry/materialized_path.rb#101
  def ancestor_ids; end

  # source://ancestry//lib/ancestry/materialized_path.rb#96
  def ancestor_ids=(value); end

  # source://ancestry//lib/ancestry/materialized_path.rb#109
  def ancestor_ids_before_last_save; end

  # source://ancestry//lib/ancestry/materialized_path.rb#105
  def ancestor_ids_in_database; end

  # optimization - better to go directly to column and avoid parsing
  #
  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/materialized_path.rb#91
  def ancestors?; end

  # private (public so class methods can find it)
  # The ancestry value for this record's children (before save)
  # This is technically child_ancestry_was
  #
  # @raise [Ancestry::AncestryException]
  #
  # source://ancestry//lib/ancestry/materialized_path.rb#128
  def child_ancestry; end

  # source://ancestry//lib/ancestry/materialized_path.rb#141
  def generate_ancestry(ancestor_ids); end

  # optimization - better to go directly to column and avoid parsing
  #
  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/materialized_path.rb#91
  def has_parent?; end

  # source://ancestry//lib/ancestry/materialized_path.rb#113
  def parent_id_before_last_save; end

  # source://ancestry//lib/ancestry/materialized_path.rb#135
  def parse_ancestry_column(obj); end

  # optimization - better to go directly to column and avoid parsing
  #
  # @return [Boolean]
  #
  # source://ancestry//lib/ancestry/materialized_path.rb#121
  def sibling_of?(node); end
end

# source://ancestry//lib/ancestry/materialized_path.rb#9
Ancestry::MaterializedPath::ROOT = T.let(T.unsafe(nil), T.untyped)

# source://ancestry//lib/ancestry/materialized_path_pg.rb#2
module Ancestry::MaterializedPathPg
  # Update descendants with new ancestry (before save)
  #
  # source://ancestry//lib/ancestry/materialized_path_pg.rb#4
  def update_descendants_with_new_ancestry; end
end

# source://ancestry//lib/ancestry/version.rb#2
Ancestry::VERSION = T.let(T.unsafe(nil), String)
