# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `jeweler` gem.
# Please instead update this file by running `bin/tapioca gem jeweler`.

class Jeweler
  def initialize(gemspec, base_dir = T.unsafe(nil)); end

  def base_dir; end
  def base_dir=(_arg0); end
  def build_gem; end
  def bump_major_version; end
  def bump_minor_version; end
  def bump_patch_version; end
  def check_dependencies(type = T.unsafe(nil)); end
  def commit; end
  def commit=(_arg0); end
  def expects_version_file?; end
  def gemspec; end
  def gemspec_helper; end
  def git_base_dir(base_dir = T.unsafe(nil)); end
  def in_git_repo?; end
  def install_gem; end
  def major_version; end
  def minor_version; end
  def output; end
  def output=(_arg0); end
  def patch_version; end
  def release_gem_to_rubyforge; end
  def release_gem_to_rubygems; end
  def release_gemspec(args); end
  def release_to_git(args); end
  def repo; end
  def repo=(_arg0); end
  def setup_rubyforge; end
  def valid_gemspec?; end
  def validate_gemspec; end
  def version; end
  def version_file_exist?; end
  def version_helper; end
  def write_gemspec; end
  def write_version(major, minor, patch, build, _options = T.unsafe(nil)); end
end

module Jeweler::Commands; end

class Jeweler::Commands::BuildGem
  def initialize; end

  def base_dir; end
  def base_dir=(_arg0); end
  def file_utils; end
  def file_utils=(_arg0); end
  def gemspec_helper; end
  def gemspec_helper=(_arg0); end
  def run; end
  def version_helper; end
  def version_helper=(_arg0); end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::Commands::CheckDependencies
  def dependencies; end
  def find_missing_dependencies; end
  def gemspec; end
  def gemspec=(_arg0); end
  def run; end
  def type; end
  def type=(_arg0); end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::Commands::CheckDependencies::MissingDependenciesError < ::RuntimeError
  def dependencies; end
  def dependencies=(_arg0); end
  def type; end
  def type=(_arg0); end
end

class Jeweler::Commands::InstallGem
  include ::FileUtils::StreamUtils_
  include ::FileUtils

  def initialize; end

  def gem_command; end
  def gemspec_helper; end
  def gemspec_helper=(_arg0); end
  def output; end
  def output=(_arg0); end
  def run; end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::Commands::ReleaseGemspec
  def initialize(attributes = T.unsafe(nil)); end

  def base_dir; end
  def base_dir=(_arg0); end
  def base_dir_path; end
  def clean_staging_area?; end
  def commit_gemspec!; end
  def gemspec; end
  def gemspec=(_arg0); end
  def gemspec_changed?; end
  def gemspec_helper; end
  def gemspec_helper=(_arg0); end
  def output; end
  def output=(_arg0); end
  def regenerate_gemspec!; end
  def repo; end
  def repo=(_arg0); end
  def run(args = T.unsafe(nil)); end
  def version; end
  def version=(_arg0); end
  def working_subdir; end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::Commands::ReleaseToGit
  def initialize(attributes = T.unsafe(nil)); end

  def base_dir; end
  def base_dir=(_arg0); end
  def clean_staging_area?; end
  def gemspec; end
  def gemspec=(_arg0); end
  def gemspec_helper; end
  def gemspec_helper=(_arg0); end
  def output; end
  def output=(_arg0); end
  def release_not_tagged?; end
  def release_tag; end
  def repo; end
  def repo=(_arg0); end
  def run(args = T.unsafe(nil)); end
  def version; end
  def version=(_arg0); end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::Commands::ReleaseToRubygems
  include ::FileUtils::StreamUtils_
  include ::FileUtils

  def initialize; end

  def gemspec; end
  def gemspec=(_arg0); end
  def gemspec_helper; end
  def gemspec_helper=(_arg0); end
  def output; end
  def output=(_arg0); end
  def run; end
  def version; end
  def version=(_arg0); end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::Commands::ValidateGemspec
  def initialize; end

  def gemspec_helper; end
  def gemspec_helper=(_arg0); end
  def output; end
  def output=(_arg0); end
  def run; end

  class << self
    def build_for(jeweler); end
  end
end

module Jeweler::Commands::Version; end

class Jeweler::Commands::Version::Base
  def base_dir; end
  def base_dir=(_arg0); end
  def base_dir_path; end
  def commit; end
  def commit=(_arg0); end
  def commit_version; end
  def gemspec; end
  def gemspec=(_arg0); end
  def repo; end
  def repo=(_arg0); end
  def run; end
  def update_version; end
  def version_helper; end
  def version_helper=(_arg0); end
  def working_subdir; end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::Commands::Version::BumpMajor < ::Jeweler::Commands::Version::Base
  def update_version; end
end

class Jeweler::Commands::Version::BumpMinor < ::Jeweler::Commands::Version::Base
  def update_version; end
end

class Jeweler::Commands::Version::BumpPatch < ::Jeweler::Commands::Version::Base
  def update_version; end
end

class Jeweler::Commands::Version::Write < ::Jeweler::Commands::Version::Base
  def build; end
  def build=(_arg0); end
  def major; end
  def major=(_arg0); end
  def minor; end
  def minor=(_arg0); end
  def patch; end
  def patch=(_arg0); end
  def update_version; end
end

class Jeweler::Commands::WriteGemspec
  def initialize; end

  def base_dir; end
  def base_dir=(_arg0); end
  def gemspec; end
  def gemspec=(_arg0); end
  def gemspec_helper; end
  def gemspec_helper=(_arg0); end
  def output; end
  def output=(_arg0); end
  def run; end
  def version; end
  def version=(_arg0); end
  def version_helper; end
  def version_helper=(_arg0); end

  class << self
    def build_for(jeweler); end
  end
end

class Jeweler::GemSpecHelper
  def initialize(spec, base_dir = T.unsafe(nil)); end

  def base_dir; end
  def base_dir=(_arg0); end
  def gem_path; end
  def has_version?; end
  def normalize_files(array_attribute); end
  def parse; end
  def path; end
  def prettyify_array(gemspec_ruby, array_name); end
  def spec; end
  def spec=(_arg0); end
  def to_ruby; end
  def update_version(version); end
  def valid?; end
  def write; end
end

Jeweler::GemSpecHelper::PARSE_SAFE = T.let(T.unsafe(nil), Integer)
class Jeweler::GemcutterTasks < ::Jeweler::RubygemsDotOrgTasks; end
class Jeweler::GemspecError < ::StandardError; end

class Jeweler::RubyforgeTasks < ::Rake::TaskLib
  def initialize; end

  def define; end
  def doc_task; end
  def doc_task=(_arg0); end
  def jeweler; end
  def jeweler=(_arg0); end
  def project; end
  def project=(_arg0); end
  def publish_documentation?; end
  def remote_doc_path; end
  def remote_doc_path=(_arg0); end
end

class Jeweler::RubygemsDotOrgTasks < ::Rake::TaskLib
  def initialize; end

  def define; end
  def jeweler; end
  def jeweler=(_arg0); end
end

module Jeweler::Specification
  def extra_rdoc_files; end
  def extra_rdoc_files=(value); end
  def files; end
  def files=(value); end
  def ruby_code(obj); end
  def set_jeweler_defaults(base_dir, git_base_dir = T.unsafe(nil)); end

  private

  def blank?(value); end
  def bundler_dependencies_for(bundler_runtime, *groups); end

  class << self
    def filelist_attribute(name); end
  end
end

class Jeweler::Tasks < ::Rake::TaskLib
  def initialize(gemspec = T.unsafe(nil), &gemspec_building_block); end

  def gemspec; end
  def gemspec=(_arg0); end
  def gemspec_building_block; end
  def gemspec_building_block=(_arg0); end
  def jeweler; end
  def jeweler=(_arg0); end

  private

  def define; end
  def jeweler!; end
  def release_args; end
  def yield_gemspec_set_version?; end
end

module Jeweler::Version; end
Jeweler::Version::BUILD = T.let(T.unsafe(nil), T.untyped)
Jeweler::Version::MAJOR = T.let(T.unsafe(nil), Integer)
Jeweler::Version::MINOR = T.let(T.unsafe(nil), Integer)
Jeweler::Version::PATCH = T.let(T.unsafe(nil), Integer)
Jeweler::Version::STRING = T.let(T.unsafe(nil), String)

class Jeweler::VersionHelper
  def initialize(base_dir); end

  def base_dir; end
  def base_dir=(_arg0); end
  def build; end
  def bump_major; end
  def bump_minor; end
  def bump_patch; end
  def major; end
  def minor; end
  def patch; end
  def plaintext_path; end
  def to_s; end
  def update_to(major, minor, patch, build = T.unsafe(nil)); end
  def yaml_path; end

  private

  def path_to_version_file(filename); end
end

module Jeweler::VersionHelper::PlaintextExtension
  def parse_plaintext; end
  def path; end
  def read_plaintext; end
  def refresh; end
  def write; end
end

module Jeweler::VersionHelper::YamlExtension
  def parse_yaml; end
  def path; end
  def read_yaml; end
  def refresh; end
  def to_hash; end
  def write; end
end

class Jeweler::VersionYmlError < ::StandardError; end

class Rake::Application
  def initialize; end

  def add_import(fn); end
  def add_loader(ext, loader); end
  def collect_command_line_tasks(args); end
  def default_task_name; end
  def deprecate(old_usage, new_usage, call_site); end
  def display_cause_details(ex); end
  def display_error_message(ex); end
  def display_exception_backtrace(ex); end
  def display_exception_details(ex); end
  def display_exception_details_seen; end
  def display_exception_message_details(ex); end
  def display_prerequisites; end
  def display_tasks_and_comments; end
  def dynamic_width; end
  def dynamic_width_stty; end
  def dynamic_width_tput; end
  def exit_because_of_exception(ex); end
  def find_rakefile_location; end
  def handle_options(argv); end
  def has_cause?(ex); end
  def have_rakefile; end
  def init(app_name = T.unsafe(nil), argv = T.unsafe(nil)); end
  def invoke_task(task_string); end
  def jeweler; end
  def jeweler_tasks; end
  def jeweler_tasks=(_arg0); end
  def load_imports; end
  def load_rakefile; end
  def name; end
  def options; end
  def original_dir; end
  def parse_task_string(string); end
  def print_rakefile_directory(location); end
  def rake_require(file_name, paths = T.unsafe(nil), loaded = T.unsafe(nil)); end
  def rakefile; end
  def rakefile_location(backtrace = T.unsafe(nil)); end
  def raw_load_rakefile; end
  def run(argv = T.unsafe(nil)); end
  def run_with_threads; end
  def set_default_options; end
  def standard_exception_handling; end
  def standard_rake_options; end
  def system_dir; end
  def terminal_columns; end
  def terminal_columns=(_arg0); end
  def terminal_width; end
  def thread_pool; end
  def top_level; end
  def top_level_tasks; end
  def trace(*strings); end
  def truncate(string, width); end
  def truncate_output?; end
  def tty_output=(_arg0); end
  def tty_output?; end
  def unix?; end
  def windows?; end

  private

  def glob(path, &block); end
  def has_chain?(exception); end
  def load_debug_at_stop_feature; end
  def select_tasks_to_show(options, show_tasks, value); end
  def select_trace_output(options, trace_option, value); end
  def sort_options(options); end
  def standard_system_dir; end
end
