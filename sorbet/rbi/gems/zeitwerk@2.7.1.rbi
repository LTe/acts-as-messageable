# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `zeitwerk` gem.
# Please instead update this file by running `bin/tapioca gem zeitwerk`.


module Kernel
  private

  def require(path); end

  class << self
    def require(path); end
  end
end

class Module
  include ::Zeitwerk::ConstAdded
end

module Zeitwerk
  class << self
    def with_loader; end
  end
end

module Zeitwerk::ConstAdded
  def const_added(cname); end
end

class Zeitwerk::Cref
  include ::Zeitwerk::RealModName

  def initialize(mod, cname); end

  def autoload(abspath); end
  def autoload?; end
  def cname; end
  def defined?; end
  def get; end
  def mod; end
  def path; end
  def remove; end
  def set(value); end
end

class Zeitwerk::Error < ::StandardError; end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName

  class << self
    def __clear; end
    def __loader_for(mod, cname); end
    def __register(cref, loader); end
    def __registered?(cname_or_cpath); end
    def __unregister_loader(loader); end

    private

    def clear; end
    def loader_for(mod, cname); end
    def register(cref, loader); end
    def registered?(cname_or_cpath); end
    def unregister_loader(loader); end
  end
end

class Zeitwerk::GemInflector < ::Zeitwerk::Inflector
  def initialize(root_file); end

  def camelize(basename, abspath); end
end

class Zeitwerk::GemLoader < ::Zeitwerk::Loader
  def initialize(root_file, namespace:, warn_on_extra_files:); end

  def setup; end

  private

  def warn_on_extra_files; end

  class << self
    def __new(root_file, namespace:, warn_on_extra_files:); end

    private

    def new(*_arg0); end
  end
end

class Zeitwerk::Inflector
  def camelize(basename, _abspath); end
  def inflect(inflections); end

  private

  def overrides; end
end

module Zeitwerk::Internal
  def internal(method_name); end
end

class Zeitwerk::Loader
  include ::Zeitwerk::RealModName
  include ::Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::Loader::Helpers
  include ::Zeitwerk::Loader::Config
  include ::Zeitwerk::Loader::EagerLoad
  extend ::Zeitwerk::Internal
  extend ::Zeitwerk::RealModName

  def initialize; end

  def __autoloaded_dirs; end
  def __autoloads; end
  def __namespace_dirs; end
  def __shadowed_file?(file); end
  def __shadowed_files; end
  def __to_unload; end
  def all_expected_cpaths; end
  def cpath_expected_at(path); end
  def reload; end
  def setup; end
  def unload; end
  def unloadable_cpath?(cpath); end
  def unloadable_cpaths; end
  def unregister; end

  private

  def autoload_file(cref, file); end
  def autoload_path_set_by_me_for?(cref); end
  def autoload_subdir(cref, subdir); end
  def autoloaded_dirs; end
  def autoloads; end
  def define_autoload(cref, abspath); end
  def define_autoloads_for_dir(dir, parent); end
  def dirs_autoload_monitor; end
  def mutex; end
  def namespace_dirs; end
  def promote_namespace_from_implicit_to_explicit(dir:, file:, cref:); end
  def raise_if_conflicting_directory(dir); end
  def register_explicit_namespace(cref); end
  def run_on_unload_callbacks(cpath, value, abspath); end
  def shadowed_file?(file); end
  def shadowed_files; end
  def to_unload; end
  def unload_autoload(cref); end
  def unload_cref(cref); end

  class << self
    def all_dirs; end
    def default_logger; end
    def default_logger=(_arg0); end
    def eager_load_all; end
    def eager_load_namespace(mod); end
    def for_gem(warn_on_extra_files: T.unsafe(nil)); end
    def for_gem_extension(namespace); end
  end
end

module Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::RealModName
  extend ::Zeitwerk::Internal

  def __on_dir_autoloaded(dir); end
  def __on_file_autoloaded(file); end
  def on_namespace_loaded(namespace); end

  private

  def on_dir_autoloaded(dir); end
  def on_file_autoloaded(file); end
  def run_on_load_callbacks(cpath, value, abspath); end
end

module Zeitwerk::Loader::Config
  include ::Zeitwerk::RealModName
  extend ::Zeitwerk::Internal

  def initialize; end

  def __ignores?(abspath); end
  def __roots; end
  def collapse(*glob_patterns); end
  def dirs(namespaces: T.unsafe(nil), ignored: T.unsafe(nil)); end
  def do_not_eager_load(*paths); end
  def enable_reloading; end
  def ignore(*glob_patterns); end
  def inflector; end
  def inflector=(_arg0); end
  def log!; end
  def logger; end
  def logger=(_arg0); end
  def on_load(cpath = T.unsafe(nil), &block); end
  def on_setup(&block); end
  def on_unload(cpath = T.unsafe(nil), &block); end
  def push_dir(path, namespace: T.unsafe(nil)); end
  def reloading_enabled?; end
  def tag; end
  def tag=(tag); end

  private

  def actual_roots; end
  def collapse?(dir); end
  def collapse_dirs; end
  def collapse_glob_patterns; end
  def eager_load_exclusions; end
  def excluded_from_eager_load?(abspath); end
  def expand_glob_patterns(glob_patterns); end
  def expand_paths(paths); end
  def ignored_glob_patterns; end
  def ignored_path?(abspath); end
  def ignored_paths; end
  def ignores?(abspath); end
  def on_load_callbacks; end
  def on_setup_callbacks; end
  def on_unload_callbacks; end
  def recompute_collapse_dirs; end
  def recompute_ignored_paths; end
  def root_dir?(dir); end
  def roots; end
end

module Zeitwerk::Loader::EagerLoad
  def eager_load(force: T.unsafe(nil)); end
  def eager_load_dir(path); end
  def eager_load_namespace(mod); end
  def load_file(path); end

  private

  def actual_eager_load_dir(dir, namespace, force: T.unsafe(nil)); end
  def eager_load_child_namespace(child, child_name, root_dir, root_namespace); end
end

module Zeitwerk::Loader::Helpers
  private

  def cname_for(basename, abspath); end
  def dir?(path); end
  def has_at_least_one_ruby_file?(dir); end
  def hidden?(basename); end
  def log(message); end
  def ls(dir); end
  def ruby?(path); end
  def walk_up(abspath); end
end

module Zeitwerk::Loader::Helpers::CNAME_VALIDATOR; end
Zeitwerk::Loader::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
class Zeitwerk::NameError < ::NameError; end

class Zeitwerk::NullInflector
  def camelize(basename, _abspath); end
end

module Zeitwerk::RealModName
  def real_mod_name(mod); end
end

Zeitwerk::RealModName::UNBOUND_METHOD_MODULE_NAME = T.let(T.unsafe(nil), UnboundMethod)

module Zeitwerk::Registry
  class << self
    def autoloads; end
    def gem_loaders_by_root_file; end
    def inception?(cpath, registered_by_loader = T.unsafe(nil)); end
    def inceptions; end
    def loader_for(path); end
    def loader_for_gem(root_file, namespace:, warn_on_extra_files:); end
    def loaders; end
    def on_unload(loader); end
    def register_autoload(loader, abspath); end
    def register_inception(cpath, abspath, loader); end
    def register_loader(loader); end
    def unregister_autoload(abspath); end
    def unregister_loader(loader); end
  end
end

class Zeitwerk::ReloadingDisabledError < ::Zeitwerk::Error
  def initialize; end
end

class Zeitwerk::SetupRequired < ::Zeitwerk::Error
  def initialize; end
end

Zeitwerk::VERSION = T.let(T.unsafe(nil), String)
