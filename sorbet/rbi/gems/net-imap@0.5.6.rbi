# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-imap` gem.
# Please instead update this file by running `bin/tapioca gem net-imap`.


class Net::IMAP < ::Net::Protocol
  include ::Net::IMAP::DeprecatedClientOptions
  include ::MonitorMixin
  include ::OpenSSL
  include ::OpenSSL::SSL
  extend ::Net::IMAP::Authenticators

  def initialize(host, port_or_options = T.unsafe(nil), *deprecated, **options); end

  def add_response_handler(handler = T.unsafe(nil), &block); end
  def append(mailbox, message, flags = T.unsafe(nil), date_time = T.unsafe(nil)); end
  def auth_capable?(mechanism); end
  def auth_mechanisms; end
  def authenticate(*args, sasl_ir: T.unsafe(nil), **props, &callback); end
  def capabilities; end
  def capabilities_cached?; end
  def capability; end
  def capability?(capability); end
  def capable?(capability); end
  def check; end
  def clear_cached_capabilities; end
  def clear_responses(type = T.unsafe(nil)); end
  def close; end
  def config; end
  def copy(set, mailbox); end
  def create(mailbox); end
  def delete(mailbox); end
  def disconnect; end
  def disconnected?; end
  def enable(*capabilities); end
  def examine(mailbox, condstore: T.unsafe(nil)); end
  def expunge; end
  def extract_responses(type); end
  def fetch(*_arg0, **_arg1, &_arg2); end
  def getacl(mailbox); end
  def getquota(mailbox); end
  def getquotaroot(mailbox); end
  def greeting; end
  def host; end
  def id(client_id = T.unsafe(nil)); end
  def idle(timeout = T.unsafe(nil), &response_handler); end
  def idle_done; end
  def idle_response_timeout; end
  def list(refname, mailbox); end
  def login(user, password); end
  def logout; end
  def logout!; end
  def lsub(refname, mailbox); end
  def move(set, mailbox); end
  def namespace; end
  def noop; end
  def open_timeout; end
  def port; end
  def remove_response_handler(handler); end
  def rename(mailbox, newname); end
  def response_handlers; end
  def responses(type = T.unsafe(nil)); end
  def search(*_arg0, **_arg1, &_arg2); end
  def select(mailbox, condstore: T.unsafe(nil)); end
  def setacl(mailbox, user, rights); end
  def setquota(mailbox, quota); end
  def sort(sort_keys, search_keys, charset); end
  def ssl_ctx; end
  def ssl_ctx_params; end
  def starttls(*deprecated, **options); end
  def status(mailbox, attr); end
  def store(set, attr, flags, unchangedsince: T.unsafe(nil)); end
  def subscribe(mailbox); end
  def thread(algorithm, search_keys, charset); end
  def tls_verified?; end
  def uid_copy(set, mailbox); end
  def uid_expunge(uid_set); end
  def uid_fetch(*_arg0, **_arg1, &_arg2); end
  def uid_move(set, mailbox); end
  def uid_search(*_arg0, **_arg1, &_arg2); end
  def uid_sort(sort_keys, search_keys, charset); end
  def uid_store(set, attr, flags, unchangedsince: T.unsafe(nil)); end
  def uid_thread(algorithm, search_keys, charset); end
  def unselect; end
  def unsubscribe(mailbox); end
  def xlist(refname, mailbox); end

  private

  def build_ssl_ctx(ssl); end
  def capabilities_from_resp_code(resp); end
  def coerce_search_arg_to_seqset?(obj); end
  def coerce_search_array_arg_to_seqset?(obj); end
  def convert_return_opts(unconverted); end
  def copy_internal(cmd, set, mailbox); end
  def enforce_logindisabled?; end
  def expunge_internal(*_arg0, **_arg1, &_arg2); end
  def fetch_internal(cmd, set, attr, mod = T.unsafe(nil), partial: T.unsafe(nil), changedsince: T.unsafe(nil)); end
  def generate_tag; end
  def get_response; end
  def get_server_greeting; end
  def get_tagged_response(tag, cmd, timeout = T.unsafe(nil)); end
  def normalize_searching_criteria(criteria); end
  def put_string(str); end
  def receive_responses; end
  def record_untagged_response(resp); end
  def record_untagged_response_code(resp); end
  def sasl_adapter; end
  def search_args(keys, charset_arg = T.unsafe(nil), return: T.unsafe(nil), charset: T.unsafe(nil)); end
  def search_internal(cmd, *_arg1, **_arg2, &_arg3); end
  def send_command(cmd, *args, &block); end
  def send_command_returning_fetch_results(*_arg0, **_arg1, &_arg2); end
  def send_command_with_continuations(cmd, *args); end
  def send_data(data, tag = T.unsafe(nil)); end
  def send_date_data(date); end
  def send_list_data(list, tag = T.unsafe(nil)); end
  def send_literal(str, tag = T.unsafe(nil)); end
  def send_number_data(num); end
  def send_quoted_string(str); end
  def send_string_data(str, tag = T.unsafe(nil)); end
  def send_symbol_data(symbol); end
  def send_time_data(time); end
  def sort_internal(cmd, sort_keys, search_keys, charset); end
  def start_imap_connection; end
  def start_receiver_thread; end
  def start_tls_session; end
  def store_internal(cmd, set, attr, flags, unchangedsince: T.unsafe(nil)); end
  def tcp_socket(host, port); end
  def thread_internal(cmd, algorithm, search_keys, charset); end
  def validate_data(data); end

  class << self
    def config; end
    def debug; end
    def debug=(val); end
    def decode_date(string); end
    def decode_datetime(string); end
    def decode_time(string); end
    def decode_utf7(s); end
    def default_imap_port; end
    def default_imaps_port; end
    def default_port; end
    def default_ssl_port; end
    def default_tls_port; end
    def encode_date(date); end
    def encode_datetime(time); end
    def encode_time(time); end
    def encode_utf7(s); end
    def format_date(date); end
    def format_datetime(time); end
    def format_time(time); end
    def parse_date(string); end
    def parse_datetime(string); end
    def parse_time(string); end
    def saslprep(string, **opts); end
  end
end

Net::IMAP::ALL = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ARCHIVE = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::AppendUIDData < ::Net::IMAP::DataLite
  def initialize(uidvalidity:, assigned_uids:); end

  def size; end
end

class Net::IMAP::Atom < ::Net::IMAP::CommandData
  def send_data(imap, tag); end
end

module Net::IMAP::Authenticators
  def add_authenticator(*_arg0, **_arg1, &_arg2); end
  def authenticator(*_arg0, **_arg1, &_arg2); end
end

module Net::IMAP::BodyStructure; end

class Net::IMAP::BodyTypeBasic < ::Struct
  include ::Net::IMAP::BodyStructure

  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::BodyTypeMessage < ::Struct
  include ::Net::IMAP::BodyStructure

  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::BodyTypeMultipart < ::Struct
  include ::Net::IMAP::BodyStructure

  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::BodyTypeText < ::Struct
  include ::Net::IMAP::BodyStructure

  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::ClientID < ::Net::IMAP::CommandData
  def send_data(imap, tag); end
  def validate; end

  private

  def format_internal(client_id); end
  def validate_internal(client_id); end
end

class Net::IMAP::CommandData < ::Net::IMAP::DataLite
  def data; end
  def send_data(imap, tag); end
  def validate; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Net::IMAP::Config
  include ::Net::IMAP::Config::AttrAccessors
  include ::Net::IMAP::Config::AttrInheritance
  include ::Net::IMAP::Config::AttrTypeCoercion
  extend ::Net::IMAP::Config::AttrAccessors::Macros
  extend ::Net::IMAP::Config::AttrInheritance::Macros
  extend ::Net::IMAP::Config::AttrTypeCoercion::Macros

  def initialize(parent = T.unsafe(nil), **attrs); end

  def load_defaults(version); end
  def responses_without_args; end
  def responses_without_args=(val); end
  def to_h; end
  def update(**attrs); end
  def with(**attrs); end

  protected

  def defaults_hash; end

  class << self
    def [](config); end
    def default; end
    def global; end
    def version_defaults; end
  end
end

module Net::IMAP::Config::AttrAccessors
  extend ::Forwardable

  mixes_in_class_methods ::Net::IMAP::Config::AttrAccessors::Macros

  def initialize; end

  def debug(*args, **_arg1, &block); end
  def debug=(*args, **_arg1, &block); end
  def enforce_logindisabled(*args, **_arg1, &block); end
  def enforce_logindisabled=(*args, **_arg1, &block); end
  def freeze; end
  def idle_response_timeout(*args, **_arg1, &block); end
  def idle_response_timeout=(*args, **_arg1, &block); end
  def open_timeout(*args, **_arg1, &block); end
  def open_timeout=(*args, **_arg1, &block); end
  def parser_max_deprecated_uidplus_data_size(*args, **_arg1, &block); end
  def parser_max_deprecated_uidplus_data_size=(*args, **_arg1, &block); end
  def parser_use_deprecated_uidplus_data(*args, **_arg1, &block); end
  def parser_use_deprecated_uidplus_data=(*args, **_arg1, &block); end
  def responses_without_block(*args, **_arg1, &block); end
  def responses_without_block=(*args, **_arg1, &block); end
  def sasl_ir(*args, **_arg1, &block); end
  def sasl_ir=(*args, **_arg1, &block); end

  protected

  def data; end

  private

  def initialize_clone(other); end
  def initialize_dup(other); end

  class << self
    def attr_accessor(name); end
    def struct; end

    private

    def attributes; end
    def included(mod); end
  end
end

module Net::IMAP::Config::AttrAccessors::Macros
  def attr_accessor(name); end
end

class Net::IMAP::Config::AttrAccessors::Struct < ::Struct
  def debug; end
  def debug=(_); end
  def enforce_logindisabled; end
  def enforce_logindisabled=(_); end
  def idle_response_timeout; end
  def idle_response_timeout=(_); end
  def open_timeout; end
  def open_timeout=(_); end
  def parser_max_deprecated_uidplus_data_size; end
  def parser_max_deprecated_uidplus_data_size=(_); end
  def parser_use_deprecated_uidplus_data; end
  def parser_use_deprecated_uidplus_data=(_); end
  def responses_without_block; end
  def responses_without_block=(_); end
  def sasl_ir; end
  def sasl_ir=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module Net::IMAP::Config::AttrInheritance
  mixes_in_class_methods ::Net::IMAP::Config::AttrInheritance::Macros

  def initialize(parent = T.unsafe(nil)); end

  def debug; end
  def enforce_logindisabled; end
  def idle_response_timeout; end
  def inherited?(attr); end
  def new(**attrs); end
  def open_timeout; end
  def parent; end
  def parser_max_deprecated_uidplus_data_size; end
  def parser_use_deprecated_uidplus_data; end
  def reset(attr = T.unsafe(nil)); end
  def responses_without_block; end
  def sasl_ir; end

  private

  def initialize_copy(other); end

  class << self
    def attr_accessor(name); end

    private

    def included(mod); end
  end
end

module Net::IMAP::Config::AttrInheritance::INHERITED; end

module Net::IMAP::Config::AttrInheritance::Macros
  def attr_accessor(name); end
end

module Net::IMAP::Config::AttrTypeCoercion
  mixes_in_class_methods ::Net::IMAP::Config::AttrTypeCoercion::Macros

  def debug=(val); end
  def debug?; end
  def enforce_logindisabled=(val); end
  def idle_response_timeout=(val); end
  def open_timeout=(val); end
  def parser_max_deprecated_uidplus_data_size=(val); end
  def parser_use_deprecated_uidplus_data=(val); end
  def responses_without_block=(val); end
  def sasl_ir=(val); end
  def sasl_ir?; end

  class << self
    def attr_accessor(attr, type: T.unsafe(nil)); end
    def boolean(attr); end
    def enum(attr, enum); end
    def integer(attr); end

    private

    def included(mod); end
  end
end

module Net::IMAP::Config::AttrTypeCoercion::Macros
  def attr_accessor(attr, type: T.unsafe(nil)); end
end

Net::IMAP::Config::DEFAULT_TO_INHERIT = T.let(T.unsafe(nil), Array)

class Net::IMAP::CopyUIDData < ::Net::IMAP::DataLite
  def initialize(uidvalidity:, source_uids:, assigned_uids:); end

  def [](source_uid); end
  def assigned_uid_for(source_uid); end
  def each; end
  def each_pair; end
  def each_uid_pair; end
  def size; end
  def source_uid_for(assigned_uid); end
  def uid_mapping; end
end

Net::IMAP::DRAFTS = T.let(T.unsafe(nil), Symbol)
Net::IMAP::Data = Net::IMAP::DataLite

class Net::IMAP::DataLite < ::Data
  def encode_with(coder); end
  def init_with(coder); end
end

module Net::IMAP::DeprecatedClientOptions
  def initialize(host, port_or_options = T.unsafe(nil), *deprecated, **options); end

  def starttls(*deprecated, **options); end

  private

  def create_ssl_params(certs = T.unsafe(nil), verify = T.unsafe(nil)); end
end

Net::IMAP::ENABLE_ALIASES = T.let(T.unsafe(nil), Hash)

class Net::IMAP::ESearchResult < ::Net::IMAP::DataLite
  def initialize(tag: T.unsafe(nil), uid: T.unsafe(nil), data: T.unsafe(nil)); end

  def all; end
  def count; end
  def max; end
  def min; end
  def modseq; end
  def partial; end
  def to_a; end
  def uid?; end
end

class Net::IMAP::ESearchResult::PartialResult < ::Net::IMAP::DataLite
  def initialize(range:, results:); end

  def to_a; end
end

class Net::IMAP::ExtensionData < ::Struct; end

class Net::IMAP::FetchStruct < ::Struct
  def attr_upcase; end
  def binary(*part_nums, offset: T.unsafe(nil)); end
  def binary_size(*part_nums); end
  def body; end
  def body_structure; end
  def bodystructure; end
  def emailid; end
  def envelope; end
  def flags; end
  def header(*part_nums, fields: T.unsafe(nil), except: T.unsafe(nil), offset: T.unsafe(nil)); end
  def header_fields(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end
  def header_fields_not(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end
  def internal_date; end
  def internaldate; end
  def message(offset: T.unsafe(nil)); end
  def mime(part, *subparts, offset: T.unsafe(nil)); end
  def modseq; end
  def part(index, *subparts, offset: T.unsafe(nil)); end
  def rfc822; end
  def rfc822_header; end
  def rfc822_size; end
  def rfc822_text; end
  def size; end
  def text(*part, offset: T.unsafe(nil)); end
  def threadid; end
  def uid; end

  private

  def body_section_attr(*_arg0, **_arg1, &_arg2); end
  def section_attr(attr, part = T.unsafe(nil), text = T.unsafe(nil), offset: T.unsafe(nil)); end
end

Net::IMAP::HASCHILDREN = T.let(T.unsafe(nil), Symbol)
Net::IMAP::HASNOCHILDREN = T.let(T.unsafe(nil), Symbol)
Net::IMAP::HAS_CHILDREN = T.let(T.unsafe(nil), Symbol)
Net::IMAP::HAS_NO_CHILDREN = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::IgnoredResponse < ::Net::IMAP::UntaggedResponse; end
class Net::IMAP::InvalidResponseError < ::Net::IMAP::Error; end
Net::IMAP::JUNK = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::Literal < ::Net::IMAP::CommandData
  def send_data(imap, tag); end
end

class Net::IMAP::LoginDisabledError < ::Net::IMAP::Error
  def initialize(msg = T.unsafe(nil), *_arg1, **_arg2, &_arg3); end
end

class Net::IMAP::MessageSet < ::Net::IMAP::CommandData
  def initialize(data:); end

  def send_data(imap, tag); end
  def validate; end

  private

  def format_internal(data); end
  def validate_internal(data); end
end

Net::IMAP::NONEXISTENT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::NO_INFERIORS = T.let(T.unsafe(nil), Symbol)
Net::IMAP::NO_SELECT = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::Namespace < ::Struct; end
class Net::IMAP::Namespaces < ::Struct; end

module Net::IMAP::NumValidator
  private

  def ensure_mod_sequence_value(num); end
  def ensure_number(num); end
  def ensure_nz_number(num); end
  def valid_mod_sequence_value?(num); end
  def valid_number?(num); end
  def valid_nz_number?(num); end

  class << self
    def ensure_mod_sequence_value(num); end
    def ensure_number(num); end
    def ensure_nz_number(num); end
    def valid_mod_sequence_value?(num); end
    def valid_number?(num); end
    def valid_nz_number?(num); end
  end
end

class Net::IMAP::PartialRange < ::Net::IMAP::CommandData
  def initialize(data:); end

  def formatted; end
  def send_data(imap, tag); end
end

Net::IMAP::PartialRange::NEG_RANGE = T.let(T.unsafe(nil), Range)
Net::IMAP::PartialRange::Negative = T.let(T.unsafe(nil), Proc)
Net::IMAP::PartialRange::POS_RANGE = T.let(T.unsafe(nil), Range)
Net::IMAP::PartialRange::Positive = T.let(T.unsafe(nil), Proc)

class Net::IMAP::QuotedString < ::Net::IMAP::CommandData
  def send_data(imap, tag); end
end

Net::IMAP::REMOTE = T.let(T.unsafe(nil), Symbol)
Net::IMAP::RESPONSES_DEPRECATION_MSG = T.let(T.unsafe(nil), String)
Net::IMAP::RESPONSE_ERRORS = T.let(T.unsafe(nil), Hash)
Net::IMAP::RETURN_START = T.let(T.unsafe(nil), Regexp)
Net::IMAP::RETURN_WHOLE = T.let(T.unsafe(nil), Regexp)

class Net::IMAP::RawData < ::Net::IMAP::CommandData
  def send_data(imap, tag); end
end

class Net::IMAP::ResponseError < ::Net::IMAP::Error
  def initialize(response); end

  def response; end
  def response=(_arg0); end
end

class Net::IMAP::ResponseParser
  include ::Net::IMAP::ResponseParser::ParserUtils
  include ::Net::IMAP::ResponseParser::ResponseConditions
  extend ::Net::IMAP::ResponseParser::ParserUtils::Generator

  def initialize(config: T.unsafe(nil)); end

  def CRLF!; end
  def CRLF?; end
  def EOF!; end
  def EOF?; end
  def NIL!; end
  def NIL?; end
  def PLUS!; end
  def PLUS?; end
  def SP!; end
  def SP?; end
  def STAR!; end
  def STAR?; end
  def body_fld_enc; end
  def body_fld_lines; end
  def body_fld_octets; end
  def case_insensitive__string; end
  def case_insensitive__string?; end
  def config; end
  def date_time; end
  def lbra; end
  def lbra?; end
  def lookahead_CRLF!; end
  def lookahead_EOF!; end
  def lookahead_NIL!; end
  def lookahead_PLUS?; end
  def lookahead_SP?; end
  def lookahead_STAR?; end
  def lookahead_body?; end
  def lookahead_case_insensitive__string!; end
  def lookahead_lbra?; end
  def lookahead_lpar?; end
  def lookahead_number!; end
  def lookahead_quoted!; end
  def lookahead_rbra?; end
  def lookahead_rpar?; end
  def lookahead_string!; end
  def lookahead_string8!; end
  def lookahead_tagged_ext_label!; end
  def lookahead_thread_list?; end
  def lookahead_thread_nested?; end
  def lpar; end
  def lpar?; end
  def media_subtype; end
  def mod_sequence_value; end
  def mod_sequence_valzer; end
  def number; end
  def number64; end
  def number64?; end
  def number?; end
  def nz_number; end
  def nz_number64; end
  def nz_number?; end
  def parse(str); end
  def peek_PLUS?; end
  def peek_SP?; end
  def peek_STAR?; end
  def peek_lbra?; end
  def peek_lpar?; end
  def peek_rbra?; end
  def peek_rpar?; end
  def permsg_modsequence; end
  def quirky_SP?; end
  def quoted; end
  def quoted?; end
  def rbra; end
  def rbra?; end
  def rpar; end
  def rpar?; end
  def search_modifier_name; end
  def string; end
  def string8; end
  def string8?; end
  def string?; end
  def tagged_ext_label; end
  def tagged_ext_label?; end
  def uniqueid; end
  def x_gm_id; end

  private

  def AppendUID(*_arg0, **_arg1, &_arg2); end
  def CopyUID(*_arg0, **_arg1, &_arg2); end
  def DeprecatedUIDPlus(validity, src_uids = T.unsafe(nil), dst_uids); end
  def accept_spaces; end
  def acl_data; end
  def addr_adl; end
  def addr_host; end
  def addr_mailbox; end
  def addr_name; end
  def address; end
  def astring; end
  def astring?; end
  def astring_chars; end
  def atom; end
  def atom?; end
  def body; end
  def body_ext_1part; end
  def body_ext_mpart; end
  def body_extension; end
  def body_extensions; end
  def body_fields; end
  def body_fld_desc; end
  def body_fld_dsp; end
  def body_fld_id; end
  def body_fld_lang; end
  def body_fld_loc; end
  def body_fld_md5; end
  def body_fld_param; end
  def body_type_1part; end
  def body_type_basic; end
  def body_type_mixed; end
  def body_type_mpart; end
  def body_type_msg; end
  def body_type_text; end
  def capability; end
  def capability?; end
  def capability__list; end
  def capability_data__untagged; end
  def case_insensitive__atom; end
  def case_insensitive__atom?; end
  def case_insensitive__nstring; end
  def charset; end
  def charset__list; end
  def comparator_data(klass = T.unsafe(nil)); end
  def continue_req; end
  def enable_data; end
  def env_bcc; end
  def env_cc; end
  def env_date; end
  def env_from; end
  def env_in_reply_to; end
  def env_message_id; end
  def env_reply_to; end
  def env_sender; end
  def env_subject; end
  def env_to; end
  def envelope; end
  def esearch_response; end
  def expunged_resp; end
  def flag_list; end
  def flag_perm__list; end
  def gt__number__lt; end
  def header_fld_name; end
  def header_list; end
  def id_response; end
  def known_uids; end
  def label(word); end
  def label_in(*labels); end
  def language_data(klass = T.unsafe(nil)); end
  def listrights_data(klass = T.unsafe(nil)); end
  def mailbox; end
  def mailbox_data__exists; end
  def mailbox_data__flags; end
  def mailbox_data__list; end
  def mailbox_data__lsub; end
  def mailbox_data__recent; end
  def mailbox_data__search; end
  def mailbox_data__status; end
  def mailbox_data__xlist; end
  def mailbox_list; end
  def mbx_list_flags; end
  def media_basic; end
  def media_message; end
  def media_text; end
  def media_type; end
  def message_data__converted(klass = T.unsafe(nil)); end
  def message_data__expunge; end
  def message_data__fetch; end
  def metadata_resp(klass = T.unsafe(nil)); end
  def msg_att(n); end
  def msg_att__label; end
  def myrights_data(klass = T.unsafe(nil)); end
  def namespace; end
  def namespace_descr; end
  def namespace_response; end
  def namespace_response_extensions; end
  def ndatetime; end
  def next_token; end
  def nil_atom; end
  def nlist__address; end
  def nparens__objectid; end
  def nquoted; end
  def nstring; end
  def nstring8; end
  def objectid; end
  def parens__modseq; end
  def parens__objectid; end
  def partial_range; end
  def partial_results; end
  def quirky__flag_list(name); end
  def quota_response; end
  def quotaroot_response; end
  def remaining_unparsed; end
  def resp_code__capability; end
  def resp_code_apnd__data; end
  def resp_code_copy__data; end
  def resp_cond_auth; end
  def resp_cond_auth__name; end
  def resp_cond_bye; end
  def resp_cond_state; end
  def resp_cond_state__name; end
  def resp_cond_state__untagged; end
  def resp_text; end
  def resp_text_code; end
  def resp_text_code__name; end
  def response; end
  def response_data; end
  def response_data__ignored; end
  def response_data__noop; end
  def response_data__simple_numeric; end
  def response_data__unhandled(klass = T.unsafe(nil)); end
  def response_tagged; end
  def ret_data_partial__value; end
  def search_correlator; end
  def search_return_data; end
  def search_return_value; end
  def section; end
  def section_binary; end
  def section_part; end
  def section_spec; end
  def sequence_set; end
  def sort_data; end
  def status_att_list; end
  def status_att_val; end
  def tag; end
  def tag_string; end
  def tagged_ext_comp; end
  def tagged_ext_simple; end
  def tagged_ext_val; end
  def text; end
  def text?; end
  def text_chars_except_rbra; end
  def thread_data; end
  def thread_list; end
  def thread_members; end
  def thread_nested; end
  def uid_set; end
  def uidfetch_resp; end
  def x_gm_label; end
  def x_gm_labels; end
end

Net::IMAP::ResponseParser::ASTRING_CHARS_TOKENS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::ASTRING_TOKENS = T.let(T.unsafe(nil), Array)

module Net::IMAP::ResponseParser::ParserUtils
  private

  def accept(*args); end
  def accept_re(re); end
  def assert_no_lookahead; end
  def combine_adjacent(*tokens); end
  def lookahead; end
  def lookahead!(*args); end
  def lookahead?(*symbols); end
  def match(*args); end
  def match_re(re, name); end
  def parse_error(fmt, *args); end
  def peek_re(re); end
  def peek_re?(re); end
  def peek_str?(str); end
  def shift_token; end
end

module Net::IMAP::ResponseParser::ParserUtils::Generator
  def def_char_matchers(name, char, token); end
  def def_token_matchers(name, *token_symbols, coerce: T.unsafe(nil), send: T.unsafe(nil)); end
end

Net::IMAP::ResponseParser::ParserUtils::Generator::LOOKAHEAD = T.let(T.unsafe(nil), String)
Net::IMAP::ResponseParser::ParserUtils::Generator::SHIFT_TOKEN = T.let(T.unsafe(nil), String)

module Net::IMAP::ResponseParser::Patterns
  include ::Net::IMAP::ResponseParser::Patterns::RFC5234
  include ::Net::IMAP::ResponseParser::Patterns::RFC3629

  private

  def unescape_quoted(quoted); end
  def unescape_quoted!(quoted); end

  class << self
    def unescape_quoted(quoted); end
    def unescape_quoted!(quoted); end
  end
end

Net::IMAP::ResponseParser::Patterns::ASTRING_CHAR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::ASTRING_CHARS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::ASTRING_SPECIALS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::ATOM = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::ATOMISH = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::ATOM_CHAR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::ATOM_SPECIALS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::CHAR8 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::CODE_TEXT = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::CODE_TEXT_CHAR = T.let(T.unsafe(nil), Regexp)
module Net::IMAP::ResponseParser::Patterns::CharClassSubtraction; end
Net::IMAP::ResponseParser::Patterns::FLAG = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::FLAG_EXTENSION = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::FLAG_KEYWORD = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::FLAG_LIST = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::FLAG_PERM = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::FLAG_PERM_LIST = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::LIST_WILDCARDS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::LITERAL = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::LITERAL8 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::MBX_FLAG = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::MBX_LIST_FLAGS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::NZ_NUMBER = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::PARTIAL_RANGE = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::PARTIAL_RANGE_FIRST = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::PARTIAL_RANGE_LAST = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUIRKY_FLAG = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUIRKY_FLAGS_LIST = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_esc = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_rev1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_rev2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_safe = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUOTED_SPECIALS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUOTED_rev1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::QUOTED_rev2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RESP_SPECIALS = T.let(T.unsafe(nil), Regexp)
module Net::IMAP::ResponseParser::Patterns::RFC3629; end
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_3 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_4 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_CHAR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_OCTETS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_TAIL = T.let(T.unsafe(nil), Regexp)
module Net::IMAP::ResponseParser::Patterns::RFC5234; end
Net::IMAP::ResponseParser::Patterns::RFC5234::ALPHA = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::CHAR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::CRLF = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::CTL = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::DIGIT = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::DQUOTE = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::HEXDIG = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::OCTET = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::RFC5234::SP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::SEQUENCE_SET = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::SEQUENCE_SET_ITEM = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::SEQUENCE_SET_STR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::SEQ_NUMBER = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::SEQ_RANGE = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::TAG = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::TAGGED_EXT_LABEL = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::TAGGED_LABEL_CHAR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::TAGGED_LABEL_FCHAR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::TEXT_CHAR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::TEXT_rev1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::Patterns::TEXT_rev2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::RE_RESPONSE_TYPE = T.let(T.unsafe(nil), Regexp)
module Net::IMAP::ResponseParser::ResponseConditions; end
Net::IMAP::ResponseParser::ResponseConditions::AUTH_CONDS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::ResponseConditions::BAD = T.let(T.unsafe(nil), String)
Net::IMAP::ResponseParser::ResponseConditions::BYE = T.let(T.unsafe(nil), String)
Net::IMAP::ResponseParser::ResponseConditions::GREETING_CONDS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::ResponseConditions::NO = T.let(T.unsafe(nil), String)
Net::IMAP::ResponseParser::ResponseConditions::OK = T.let(T.unsafe(nil), String)
Net::IMAP::ResponseParser::ResponseConditions::PREAUTH = T.let(T.unsafe(nil), String)
Net::IMAP::ResponseParser::ResponseConditions::RESP_CONDS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::ResponseConditions::RESP_COND_STATES = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::ResponseConditions::RESP_DATA_CONDS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::SEQUENCE_SET_TOKENS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::SPACES_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::TAG_TOKENS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::T_LITERAL8 = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseText::EMPTY = T.let(T.unsafe(nil), Net::IMAP::ResponseText)

module Net::IMAP::SASL
  private

  def saslprep(string, **opts); end

  class << self
    def add_authenticator(*_arg0, **_arg1, &_arg2); end
    def authenticator(*args, registry: T.unsafe(nil), **kwargs, &block); end
    def authenticators; end
    def saslprep(string, **opts); end
  end
end

class Net::IMAP::SASL::AnonymousAuthenticator
  def initialize(anon_msg = T.unsafe(nil), anonymous_message: T.unsafe(nil), **_arg2); end

  def anonymous_message; end
  def done?; end
  def initial_response?; end
  def process(_server_challenge_string); end
end

class Net::IMAP::SASL::AuthenticationCanceled < ::Net::IMAP::SASL::Error; end
class Net::IMAP::SASL::AuthenticationError < ::Net::IMAP::SASL::Error; end

class Net::IMAP::SASL::AuthenticationExchange
  def initialize(client, mechanism, authenticator, sasl_ir: T.unsafe(nil)); end

  def authenticate; end
  def authenticator; end
  def done?; end
  def mechanism; end
  def send_initial_response?; end

  private

  def client; end
  def initial_response; end
  def process(challenge); end

  class << self
    def authenticate(*_arg0, **_arg1, &_arg2); end
    def build(client, mechanism, *args, sasl_ir: T.unsafe(nil), **kwargs, &block); end
  end
end

class Net::IMAP::SASL::AuthenticationFailed < ::Net::IMAP::SASL::Error; end

class Net::IMAP::SASL::AuthenticationIncomplete < ::Net::IMAP::SASL::AuthenticationFailed
  def initialize(response, message = T.unsafe(nil)); end

  def response; end
end

class Net::IMAP::SASL::Authenticators
  def initialize(use_defaults: T.unsafe(nil), use_deprecated: T.unsafe(nil)); end

  def add_authenticator(name, authenticator = T.unsafe(nil)); end
  def authenticator(mechanism, *_arg1, **_arg2, &_arg3); end
  def mechanism?(name); end
  def names; end
  def new(mechanism, *_arg1, **_arg2, &_arg3); end
  def remove_authenticator(name); end

  class << self
    def normalize_name(mechanism); end
  end
end

Net::IMAP::SASL::BidiStringError = Net::IMAP::StringPrep::BidiStringError

class Net::IMAP::SASL::ClientAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  extend ::Forwardable

  def initialize(client, &command_proc); end

  def auth_capable?(*args, **_arg1, &block); end
  def authenticate(*_arg0, **_arg1, &_arg2); end
  def client; end
  def command_proc; end
  def drop_connection(*args, **_arg1, &block); end
  def drop_connection!(*args, **_arg1, &block); end
  def host(*args, **_arg1, &block); end
  def port(*args, **_arg1, &block); end
  def response_errors; end
  def run_command(mechanism, initial_response = T.unsafe(nil), &continuations_handler); end
  def sasl_ir_capable?(*args, **_arg1, &block); end
end

class Net::IMAP::SASL::CramMD5Authenticator
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **_arg7); end

  def done?; end
  def initial_response?; end
  def process(challenge); end

  private

  def hmac_md5(text, key); end
end

class Net::IMAP::SASL::DigestMD5Authenticator
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authz = T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), realm: T.unsafe(nil), service: T.unsafe(nil), host: T.unsafe(nil), service_name: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **_arg13); end

  def authcid; end
  def authzid; end
  def charset; end
  def digest_uri; end
  def done?; end
  def host; end
  def initial_response?; end
  def nonce; end
  def password; end
  def process(challenge); end
  def qop; end
  def realm; end
  def service; end
  def service_name; end
  def sparams; end
  def username; end

  private

  def compute_a0(response); end
  def compute_a1(response); end
  def compute_a2(response); end
  def format_response(response); end
  def nc(nonce); end
  def parse_challenge(challenge); end
  def qdval(k, v); end
  def response_value(response); end
  def split_quoted_list(value, challenge); end
end

Net::IMAP::SASL::DigestMD5Authenticator::AUTH_PARAM = T.let(T.unsafe(nil), Regexp)
Net::IMAP::SASL::DigestMD5Authenticator::DataFormatError = Net::IMAP::DataFormatError
Net::IMAP::SASL::DigestMD5Authenticator::LIST_DELIM = T.let(T.unsafe(nil), Regexp)
Net::IMAP::SASL::DigestMD5Authenticator::LWS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::SASL::DigestMD5Authenticator::NO_MULTIPLES = T.let(T.unsafe(nil), Array)
Net::IMAP::SASL::DigestMD5Authenticator::QUOTED_LISTABLE = T.let(T.unsafe(nil), Array)
Net::IMAP::SASL::DigestMD5Authenticator::QUOTED_STR = T.let(T.unsafe(nil), Regexp)
Net::IMAP::SASL::DigestMD5Authenticator::REQUIRED = T.let(T.unsafe(nil), Array)
Net::IMAP::SASL::DigestMD5Authenticator::ResponseParseError = Net::IMAP::ResponseParseError
Net::IMAP::SASL::DigestMD5Authenticator::STAGE_DONE = T.let(T.unsafe(nil), Symbol)
Net::IMAP::SASL::DigestMD5Authenticator::STAGE_ONE = T.let(T.unsafe(nil), Symbol)
Net::IMAP::SASL::DigestMD5Authenticator::STAGE_TWO = T.let(T.unsafe(nil), Symbol)
Net::IMAP::SASL::DigestMD5Authenticator::TOKEN = T.let(T.unsafe(nil), Regexp)
class Net::IMAP::SASL::Error < ::StandardError; end

class Net::IMAP::SASL::ExternalAuthenticator
  def initialize(user = T.unsafe(nil), authzid: T.unsafe(nil), username: T.unsafe(nil), **_arg3); end

  def authzid; end
  def done?; end
  def initial_response?; end
  def process(_); end
  def username; end
end

module Net::IMAP::SASL::GS2Header
  def gs2_authzid; end
  def gs2_cb_flag; end
  def gs2_header; end

  private

  def gs2_saslname_encode(str); end

  class << self
    def gs2_saslname_encode(str); end
  end
end

Net::IMAP::SASL::GS2Header::NO_NULL_CHARS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::SASL::GS2Header::RFC5801_SASLNAME = T.let(T.unsafe(nil), Regexp)

class Net::IMAP::SASL::LoginAuthenticator
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **_arg7); end

  def done?; end
  def initial_response?; end
  def process(data); end
end

Net::IMAP::SASL::LoginAuthenticator::STATE_DONE = T.let(T.unsafe(nil), Symbol)
Net::IMAP::SASL::LoginAuthenticator::STATE_PASSWORD = T.let(T.unsafe(nil), Symbol)
Net::IMAP::SASL::LoginAuthenticator::STATE_USER = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::SASL::OAuthAuthenticator
  include ::Net::IMAP::SASL::GS2Header

  def initialize(authzid: T.unsafe(nil), host: T.unsafe(nil), port: T.unsafe(nil), username: T.unsafe(nil), query: T.unsafe(nil), mthd: T.unsafe(nil), path: T.unsafe(nil), post: T.unsafe(nil), qs: T.unsafe(nil), **_arg9); end

  def authorization; end
  def authzid; end
  def done?; end
  def host; end
  def initial_client_response; end
  def last_server_response; end
  def mthd; end
  def path; end
  def port; end
  def post; end
  def process(data); end
  def qs; end
  def query; end
  def username; end
end

class Net::IMAP::SASL::OAuthBearerAuthenticator < ::Net::IMAP::SASL::OAuthAuthenticator
  def initialize(arg1 = T.unsafe(nil), arg2 = T.unsafe(nil), oauth2_token: T.unsafe(nil), secret: T.unsafe(nil), **args, &blk); end

  def authorization; end
  def initial_response?; end
  def oauth2_token; end
  def secret; end
end

class Net::IMAP::SASL::PlainAuthenticator
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), **_arg7); end

  def authcid; end
  def authzid; end
  def done?; end
  def initial_response?; end
  def password; end
  def process(data); end
  def secret; end
  def username; end
end

Net::IMAP::SASL::PlainAuthenticator::NULL = T.let(T.unsafe(nil), String)
Net::IMAP::SASL::ProhibitedCodepoint = Net::IMAP::StringPrep::ProhibitedCodepoint
module Net::IMAP::SASL::ProtocolAdapters; end

module Net::IMAP::SASL::ProtocolAdapters::Generic
  def cancel_response; end
  def command_name; end
  def decode(string); end
  def encode(string); end
  def encode_ir(string); end
  def service; end
end

module Net::IMAP::SASL::ProtocolAdapters::IMAP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic

  def service; end
end

module Net::IMAP::SASL::ProtocolAdapters::POP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic

  def command_name; end
  def service; end
end

module Net::IMAP::SASL::ProtocolAdapters::SMTP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic

  def command_name; end
  def service; end
end

Net::IMAP::SASL::SASLprep = Net::IMAP::StringPrep::SASLprep

module Net::IMAP::SASL::ScramAlgorithm
  def H(str); end
  def HMAC(key, data); end
  def Hi(str, salt, iterations); end
  def Normalize(str); end
  def XOR(str1, str2); end
  def auth_message; end
  def client_key; end
  def client_proof; end
  def client_signature; end
  def salted_password; end
  def server_key; end
  def server_signature; end
  def stored_key; end
end

class Net::IMAP::SASL::ScramAuthenticator
  include ::Net::IMAP::SASL::GS2Header
  include ::Net::IMAP::SASL::ScramAlgorithm

  def initialize(username_arg = T.unsafe(nil), password_arg = T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), authzid: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), min_iterations: T.unsafe(nil), cnonce: T.unsafe(nil), **options); end

  def authcid; end
  def authzid; end
  def cbind_input; end
  def cnonce; end
  def digest; end
  def done?; end
  def initial_client_response; end
  def iterations; end
  def min_iterations; end
  def password; end
  def process(challenge); end
  def salt; end
  def secret; end
  def server_error; end
  def snonce; end
  def username; end

  private

  def client_final_message_without_proof; end
  def client_first_message_bare; end
  def final_message_with_proof; end
  def format_message(hash); end
  def parse_challenge(challenge); end
  def recv_server_final_message(server_final_message); end
  def recv_server_first_message(server_first_message); end
  def server_first_message; end
end

class Net::IMAP::SASL::ScramSHA1Authenticator < ::Net::IMAP::SASL::ScramAuthenticator; end
Net::IMAP::SASL::ScramSHA1Authenticator::DIGEST_NAME = T.let(T.unsafe(nil), String)
class Net::IMAP::SASL::ScramSHA256Authenticator < ::Net::IMAP::SASL::ScramAuthenticator; end
Net::IMAP::SASL::ScramSHA256Authenticator::DIGEST_NAME = T.let(T.unsafe(nil), String)
Net::IMAP::SASL::StringPrep = Net::IMAP::StringPrep
Net::IMAP::SASL::StringPrepError = Net::IMAP::StringPrep::StringPrepError

class Net::IMAP::SASL::XOAuth2Authenticator
  def initialize(user = T.unsafe(nil), token = T.unsafe(nil), username: T.unsafe(nil), oauth2_token: T.unsafe(nil), authzid: T.unsafe(nil), secret: T.unsafe(nil), **_arg6); end

  def authzid; end
  def done?; end
  def initial_response?; end
  def oauth2_token; end
  def process(_data); end
  def secret; end
  def username; end

  private

  def build_oauth2_string(username, oauth2_token); end
end

class Net::IMAP::SASLAdapter < ::Net::IMAP::SASL::ClientAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::IMAP

  def drop_connection; end
  def drop_connection!; end
  def response_errors; end
  def sasl_ir_capable?; end
end

Net::IMAP::SASLAdapter::RESPONSE_ERRORS = T.let(T.unsafe(nil), Array)
Net::IMAP::SENT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::STRFDATE = T.let(T.unsafe(nil), String)
Net::IMAP::STRFTIME = T.let(T.unsafe(nil), String)
Net::IMAP::SUBSCRIBED = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::SearchResult < ::Array
  def initialize(seq_nums, modseq: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def modseq; end
  def pretty_print(pp); end
  def to_s(type = T.unsafe(nil)); end
  def to_sequence_set; end

  class << self
    def [](*seq_nums, modseq: T.unsafe(nil)); end
  end
end

class Net::IMAP::SequenceSet
  def initialize(input = T.unsafe(nil)); end

  def &(other); end
  def +(other); end
  def -(other); end
  def <<(object); end
  def ==(other); end
  def ===(other); end
  def [](index, length = T.unsafe(nil)); end
  def ^(other); end
  def add(object); end
  def add?(object); end
  def append(object); end
  def at(index); end
  def clear; end
  def complement; end
  def complement!; end
  def count; end
  def count_duplicates; end
  def count_with_duplicates; end
  def cover?(other); end
  def deconstruct; end
  def delete(object); end
  def delete?(object); end
  def delete_at(index); end
  def difference(other); end
  def disjoint?(other); end
  def each_element; end
  def each_entry(&block); end
  def each_number(&block); end
  def each_ordered_number(&block); end
  def each_range; end
  def elements; end
  def empty?; end
  def entries; end
  def eql?(other); end
  def find_index(number); end
  def find_ordered_index(number); end
  def freeze; end
  def full?; end
  def has_duplicates?; end
  def hash; end
  def include?(element); end
  def include_star?; end
  def inspect; end
  def intersect?(other); end
  def intersection(other); end
  def limit(max:); end
  def limit!(max:); end
  def max(star: T.unsafe(nil)); end
  def member?(element); end
  def merge(*inputs); end
  def min(star: T.unsafe(nil)); end
  def minmax(star: T.unsafe(nil)); end
  def normalize; end
  def normalize!; end
  def normalized_string; end
  def numbers; end
  def ordered_at(index); end
  def overlap?(other); end
  def ranges; end
  def replace(other); end
  def send_data(imap, tag); end
  def size; end
  def slice(index, length = T.unsafe(nil)); end
  def slice!(index, length = T.unsafe(nil)); end
  def string; end
  def string=(str); end
  def subtract(*objects); end
  def to_a; end
  def to_s; end
  def to_sequence_set; end
  def to_set; end
  def union(other); end
  def valid?; end
  def valid_string; end
  def validate; end
  def xor(other); end
  def |(other); end
  def ~; end

  protected

  def tuples; end

  private

  def each_entry_tuple(&block); end
  def each_number_in_tuple(min, max, &block); end
  def each_tuple_with_index(tuples); end
  def from_tuple_int(num); end
  def include_tuple?(_arg0); end
  def initialize_clone(other); end
  def initialize_dup(other); end
  def input_to_tuple(obj); end
  def input_to_tuples(obj); end
  def input_try_convert(input); end
  def intersect_tuple?(_arg0); end
  def lookup_number_by_tuple_index(tuples, index); end
  def modifying!; end
  def nz_number(num); end
  def range_gte_to(num); end
  def range_to_tuple(range); end
  def remain_frozen(set); end
  def reverse_each_tuple_with_index(tuples); end
  def slice_length(start, length); end
  def slice_range(range); end
  def str_to_tuple(str); end
  def str_to_tuples(str); end
  def to_tuple_int(obj); end
  def tuple_add(tuple); end
  def tuple_coalesce(lower, lower_idx, min, max); end
  def tuple_gte_with_index(num); end
  def tuple_subtract(tuple); end
  def tuple_to_entry(_arg0); end
  def tuple_to_str(tuple); end
  def tuple_trim_or_split(lower, idx, tmin, tmax); end
  def tuples_add(tuples); end
  def tuples_subtract(tuples); end
  def tuples_trim_or_delete(lower, lower_idx, tmin, tmax); end

  class << self
    def [](first, *rest); end
    def empty; end
    def full; end
    def try_convert(obj); end
  end
end

Net::IMAP::SequenceSet::EMPTY = T.let(T.unsafe(nil), Net::IMAP::SequenceSet)
Net::IMAP::SequenceSet::FULL = T.let(T.unsafe(nil), Net::IMAP::SequenceSet)
Net::IMAP::SequenceSet::STARS = T.let(T.unsafe(nil), Array)
Net::IMAP::SequenceSet::STAR_INT = T.let(T.unsafe(nil), Integer)
Net::IMAP::SequenceSet::UINT32_MAX = T.let(T.unsafe(nil), Integer)

module Net::IMAP::StringFormatter
  private

  def nstring(str); end
  def string(str); end
  def valid_nstring?(str); end
  def valid_string?(str); end

  class << self
    def nstring(str); end
    def string(str); end
    def valid_nstring?(str); end
    def valid_string?(str); end
  end
end

Net::IMAP::StringFormatter::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)

module Net::IMAP::StringPrep
  private

  def check_bidi!(string, c_8: T.unsafe(nil), profile: T.unsafe(nil)); end
  def check_prohibited!(string, *tables, bidi: T.unsafe(nil), unassigned: T.unsafe(nil), stored: T.unsafe(nil), profile: T.unsafe(nil)); end
  def map_tables!(string, *tables); end
  def stringprep(string, maps:, normalization:, prohibited:, **opts); end

  class << self
    def [](table); end
    def check_bidi!(string, c_8: T.unsafe(nil), profile: T.unsafe(nil)); end
    def check_prohibited!(string, *tables, bidi: T.unsafe(nil), unassigned: T.unsafe(nil), stored: T.unsafe(nil), profile: T.unsafe(nil)); end
    def map_tables!(string, *tables); end
    def stringprep(string, maps:, normalization:, prohibited:, **opts); end
  end
end

class Net::IMAP::StringPrep::BidiStringError < ::Net::IMAP::StringPrep::StringPrepError; end

module Net::IMAP::StringPrep::NamePrep
  private

  def nameprep(string, **opts); end

  class << self
    def nameprep(string, **opts); end
  end
end

Net::IMAP::StringPrep::NamePrep::CHECK_BIDI = T.let(T.unsafe(nil), TrueClass)
Net::IMAP::StringPrep::NamePrep::MAPPING_TABLES = T.let(T.unsafe(nil), Array)
Net::IMAP::StringPrep::NamePrep::NORMALIZATION = T.let(T.unsafe(nil), Symbol)
Net::IMAP::StringPrep::NamePrep::PROHIBITED_TABLES = T.let(T.unsafe(nil), Array)
Net::IMAP::StringPrep::NamePrep::STRINGPREP_PROFILE = T.let(T.unsafe(nil), String)
Net::IMAP::StringPrep::NamePrep::UNASSIGNED_TABLE = T.let(T.unsafe(nil), String)

class Net::IMAP::StringPrep::ProhibitedCodepoint < ::Net::IMAP::StringPrep::StringPrepError
  def initialize(table, *args, **kwargs); end

  def table; end
end

module Net::IMAP::StringPrep::SASLprep
  private

  def saslprep(str, stored: T.unsafe(nil), exception: T.unsafe(nil)); end

  class << self
    def saslprep(str, stored: T.unsafe(nil), exception: T.unsafe(nil)); end
  end
end

Net::IMAP::StringPrep::SASLprep::ASCII_NO_CTRLS = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::BIDI_FAILURE = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::MAP_TO_NOTHING = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::MAP_TO_SPACE = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::PROHIBITED = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::PROHIBITED_OUTPUT = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::PROHIBITED_OUTPUT_STORED = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::PROHIBITED_STORED = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::SASLprep::TABLES_PROHIBITED = T.let(T.unsafe(nil), Array)
Net::IMAP::StringPrep::SASLprep::TABLES_PROHIBITED_STORED = T.let(T.unsafe(nil), Array)
Net::IMAP::StringPrep::SASLprep::UNASSIGNED = T.let(T.unsafe(nil), Regexp)

class Net::IMAP::StringPrep::StringPrepError < ::ArgumentError
  def initialize(*args, string: T.unsafe(nil), profile: T.unsafe(nil)); end

  def profile; end
  def string; end
end

module Net::IMAP::StringPrep::Tables; end
Net::IMAP::StringPrep::Tables::BIDI_DESC_REQ2 = T.let(T.unsafe(nil), String)
Net::IMAP::StringPrep::Tables::BIDI_DESC_REQ3 = T.let(T.unsafe(nil), String)
Net::IMAP::StringPrep::Tables::BIDI_FAILS_REQ2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::BIDI_FAILS_REQ3 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::BIDI_FAILURE = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_A_1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_B_1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_B_2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_B_3 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_1_1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_1_2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_2_1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_2_2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_3 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_4 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_5 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_6 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_7 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_8 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_C_9 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_D_1 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_D_1_NEGATED = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::IN_D_2 = T.let(T.unsafe(nil), Regexp)
Net::IMAP::StringPrep::Tables::MAPPINGS = T.let(T.unsafe(nil), Hash)
Net::IMAP::StringPrep::Tables::MAP_B_1 = T.let(T.unsafe(nil), String)
Net::IMAP::StringPrep::Tables::MAP_B_2 = T.let(T.unsafe(nil), Hash)
Net::IMAP::StringPrep::Tables::MAP_B_3 = T.let(T.unsafe(nil), Hash)
Net::IMAP::StringPrep::Tables::REGEXPS = T.let(T.unsafe(nil), Hash)
Net::IMAP::StringPrep::Tables::TITLES = T.let(T.unsafe(nil), Hash)

module Net::IMAP::StringPrep::Trace
  private

  def stringprep_trace(string, **opts); end

  class << self
    def stringprep_trace(string, **opts); end
  end
end

Net::IMAP::StringPrep::Trace::CHECK_BIDI = T.let(T.unsafe(nil), TrueClass)
Net::IMAP::StringPrep::Trace::MAPPING_TABLES = T.let(T.unsafe(nil), T.untyped)
Net::IMAP::StringPrep::Trace::NORMALIZATION = T.let(T.unsafe(nil), T.untyped)
Net::IMAP::StringPrep::Trace::PROHIBITED_TABLES = T.let(T.unsafe(nil), Array)
Net::IMAP::StringPrep::Trace::STRINGPREP_PROFILE = T.let(T.unsafe(nil), String)
Net::IMAP::StringPrep::Trace::UNASSIGNED_TABLE = T.let(T.unsafe(nil), String)
Net::IMAP::TRASH = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::ThreadMember < ::Struct
  def to_sequence_set; end

  protected

  def all_seqnos(node = T.unsafe(nil)); end
end

class Net::IMAP::UIDFetchData < ::Net::IMAP::FetchStruct
  def initialize(*_arg0, **_arg1, &_arg2); end
end

class Net::IMAP::UIDPlusData < ::Struct
  def uid_mapping; end
end

class Net::IMAP::UnknownResponseError < ::Net::IMAP::ResponseError; end
class Net::IMAP::UnparsedData < ::Struct; end
class Net::IMAP::UnparsedNumericResponseData < ::Struct; end
Net::IMAP::VERSION = T.let(T.unsafe(nil), String)

class Net::IMAP::VanishedData < ::Net::IMAP::DataLite
  def initialize(uids:, earlier:); end

  def earlier?; end
  def to_a; end
end

Net::IMAP::XOauth2Authenticator = Net::IMAP::SASL::XOAuth2Authenticator
